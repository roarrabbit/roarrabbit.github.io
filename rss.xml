<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://vuepress-theme-hope-demo.mrhope.site/rss.xml" rel="self" type="application/rss+xml"/>
    <title>Rabbit's Blog</title>
    <link>https://vuepress-theme-hope-demo.mrhope.site/</link>
    <description>A place for roar</description>
    <language>zh-CN</language>
    <pubDate>Mon, 17 Jan 2022 15:46:16 GMT</pubDate>
    <lastBuildDate>Mon, 17 Jan 2022 15:46:16 GMT</lastBuildDate>
    <generator>@mr-hope/vuepress-plugin-feed</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <copyright>Copyright by RoarRabbit</copyright>
    <category>求知</category>
    <category>杂物间</category>
    <category>笔记</category>
    <category>杂谈</category>
    <category>折腾</category>
    <item>
      <title>Blog</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/blog/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/blog/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">Blog</source>
    </item>
    <item>
      <title>JAVASE | 00JAVA学习导读</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/hungry/JAVASE_00JAVA%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AF%BB/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/hungry/JAVASE_00JAVA%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AF%BB/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">JAVASE | 00JAVA学习导读</source>
      <category>求知</category>
      <pubDate>Fri, 17 Sep 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="导读部分"> 导读部分</h1>
<p>学习企划开始于2021.09.17</p>
<p><a href="https://www.bilibili.com/video/BV1Kb411W75N" target="_blank" rel="noopener noreferrer">尚硅谷Java零基础入门教程</a></p>
<p>没有最好的语言，每个语言都有它的长处和短处，每个人都需要学习多门语言。</p>
<h2 id="心态部分"> 心态部分</h2>
<ul>
<li>不是“没听懂”，而是记不住</li>
<li>要为成功找理由，不为失败找借口</li>
<li>战略上藐视”对手“，战术上重视对手</li>
<li>代码虐我千万遍，我视代码如初恋</li>
</ul>
<p>保持一定的代码写作量</p>
<h1 id="各个阶段"> 各个阶段</h1>
<ul>
<li>第一阶段：JavaSE
<ul>
<li>java基础</li>
<li>java8新特性</li>
<li>数据库</li>
<li>JDBC</li>
</ul>
</li>
<li>第二阶段
<ul>
<li>Html基础与CSS</li>
<li>JS DOM与JQuery</li>
<li>XML与Tomcat</li>
<li>HTTP协议</li>
<li>服务器端组件Servlet</li>
<li>JSP</li>
<li>EL表达式</li>
<li>JSTL</li>
<li>会话控制Cookie和Session</li>
<li>服务器端组件Filter</li>
<li>服务器端组件Listener</li>
<li>国际化</li>
<li>异步数据传输架构Ajax</li>
<li>文件的上传下载</li>
<li>vue（案例）</li>
</ul>
</li>
<li><strong>第三阶段JavaEE框架</strong>
<ul>
<li>SSM主流三大框架（以前是SSH）
<ul>
<li>系统整体分层解耦框架spring</li>
<li>轻量级web框架springmvc</li>
<li>轻量级持久层框架mybatis</li>
</ul>
</li>
<li>服务器操作系统Linux</li>
<li>内存数据库Redis</li>
<li>项目框架、jar包管理Maven</li>
<li>案例</li>
</ul>
</li>
<li>第四阶段JavaEE高级
<ul>
<li>SVN/IDEA开发工具</li>
<li>分布式把呢不能管理工具Git与Github</li>
<li>Mysql高级</li>
<li>Mycat实现MySQL的分布式、分库分表、读写分离</li>
<li>Nginx反向代理、负载均衡、动静分离</li>
<li>JVM内存模型、参数调优</li>
<li>JUC线程高级</li>
<li>分布式架构注册中心Zookeeper</li>
<li>虚拟化应用容器Docker</li>
<li>全文检索引擎ElasticSearch</li>
<li>消息队列RabbitMQ</li>
<li>前端VUE/ES6</li>
<li>案例</li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>JAVASE | JAVA基础部分</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/hungry/JAVASE_01JAVA%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/hungry/JAVASE_01JAVA%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">JAVASE | JAVA基础部分</source>
      <category>求知</category>
      <pubDate>Sat, 18 Sep 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>这里的学习笔记都来自尚硅谷：<a href="https://www.bilibili.com/video/BV1Kb411W75N" target="_blank" rel="noopener noreferrer">尚硅谷Java零基础入门教程</a></p>
<h1 id="java基础部分"> JAVA基础部分</h1>
<p>day1</p>
<p>JAVA基础知识图解</p>
<p><img src="./images/01JAVA语言概述/image-20210919124052543.png" alt="image-202109124052543" /></p>
<h1 id="前期需要掌握的"> 前期需要掌握的</h1>
<h2 id="常用的dos命令"> 常用的DOS命令</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>dir</td>
<td>列出当前目录下的文件以及文件夹</td>
</tr>
<tr>
<td>md</td>
<td>创建目录</td>
</tr>
<tr>
<td>rd</td>
<td>删除目录（文件夹）</td>
</tr>
<tr>
<td>cd</td>
<td>进入指定目录</td>
</tr>
<tr>
<td>cd..</td>
<td>退回到上一级目录</td>
</tr>
<tr>
<td>cd\</td>
<td>退回到根目录</td>
</tr>
<tr>
<td>del</td>
<td>删除文件</td>
</tr>
<tr>
<td>exit</td>
<td>退回dos命令行</td>
</tr>
</tbody>
</table>
<ul>
<li>补充：<code>echo javase&gt;1.doc</code></li>
<li><code>d:</code>切换到d盘</li>
</ul>
<h2 id="java技术体系平台"> java技术体系平台</h2>
<ul>
<li>java se标准版
<ul>
<li>支持面向桌面级应用，例如windows下的应用等</li>
</ul>
</li>
<li>java ee企业版
<ul>
<li>企业级开发，例如web应用后台等</li>
</ul>
</li>
<li>java Me、java card
<ul>
<li>支持运行在移动终端（手机、PDA）</li>
</ul>
</li>
</ul>
<h2 id="java在各领域的应用"> java在各领域的应用</h2>
<p>一开始的java规划是上面的规划，但随着时间的推移，java se变成了学习java的基础部分，去掉了桌面应用的api部分，变成了过渡java ee的基础部分，例如下面这几个方面</p>
<ul>
<li><strong>企业级应用</strong></li>
<li><strong>android平台应用</strong></li>
<li><strong>大数据平台开发</strong></li>
<li>移动领域应用</li>
</ul>
<h2 id="java语言的诞生"> java语言的诞生</h2>
<ul>
<li>java之父在开发项目的时候，发现c缺少垃圾回收系统、可移植的安全性、分布式程序设计和多线程功能等功能而诞生了java</li>
<li>java从c和c++中继承了许多成分，甚至可以将java看成是类c语言发展和衍生的产物。</li>
<li>java是一个纯粹的面向对象的程序设计语言</li>
</ul>
<h2 id="java语言的特点"> java语言的特点</h2>
<ul>
<li>
<p>面向对象</p>
<ul>
<li>两个基本概念：类、对象</li>
<li>三大特性：封装、继承、多态</li>
</ul>
</li>
<li>
<p>健壮性</p>
<ul>
<li>吸收了C/C++语言的优点，但去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机</li>
</ul>
</li>
<li>
<p>跨平台性</p>
<ul>
<li>跨平台性：通过 Java语言编写的应用程序在不同的系统平台上都可以运行。“ Write once, Run Anywhere</li>
<li>原理：只要在需要运行java应用程序的操作系统上，先安装一个Java陸拟机（ JVM Java Virtual Machine)即可。由JVM来负责Java程序在该系统中的运行</li>
</ul>
</li>
</ul>
<h3 id="java语言运行机制机运行过程"> java语言运行机制机运行过程</h3>
<ul>
<li>用户-&gt;字节码文件-&gt;JVM-&gt;操作系统-&gt;硬件</li>
<li>核心机制：垃圾回收
<ul>
<li>但java程序还会出现内存泄漏和内存溢出的问题</li>
</ul>
</li>
</ul>
<h2 id="java语言的环境搭建"> java语言的环境搭建</h2>
<h3 id="上面是jdk、jre"> 上面是JDK、JRE</h3>
<ul>
<li>jdk（java development kit，java开发工具包）</li>
<li>jre（java runtime environment，java运行环境）</li>
</ul>
<h3 id="jdk、jre、jvm关系"> JDK、JRE、JVM关系</h3>
<ul>
<li>
<p>jdk=jre+开发工具集（例如javac编译工具）</p>
</li>
<li>
<p>jre=jvm+java se标准类库</p>
<p><img src="./images/01JAVA语言概述/image-20210921105516069.png" alt="image-202109105516069" /></p>
<ul>
<li>
<p>完整详细图</p>
<p><img src="./images/01JAVA语言概述/image-20210921105801957.png" alt="image-202109105801957" /></p>
<p><img src="./images/01JAVA语言概述/image-20210921105851669.png" alt="image-202109105851669" /></p>
</li>
</ul>
</li>
</ul>
<h3 id="关于jdk的安装"> 关于jdk的安装</h3>
<p>安装的时候切记要使用全英的路径，强烈建议选择其他路径，并将将版本号记录号下来，jdk是支持多版本的，所以你可以将多个jdk安装在你的电脑上，只需要将其安装在不同的文件路径即可</p>
<h3 id="关于jdk的目录"> 关于jdk的目录</h3>
<ul>
<li>bin，开发工具的目录
<ul>
<li>javac，编译</li>
<li>java，解释运行</li>
<li>javadoc，生成网页形式的文档</li>
</ul>
</li>
<li>db，java实现的数据库</li>
<li>include，调用c语言实现的头文件</li>
<li>jre，java的运行环境</li>
<li>lib，存在相关的jar包的库文件</li>
<li>src.zip常见的类库</li>
</ul>
<h3 id="环境变量"> 环境变量</h3>
<ul>
<li>将<code>./bin</code>目录复制到系统环境的path中</li>
</ul>
<h2 id="helloworld"> HelloWorld</h2>
<ul>
<li>步骤
<ol>
<li>将java代码编写到<code>.java</code>的文件中</li>
<li>通过javac.exe对该.java文件进行编译
<ul>
<li>这里生成的<code>.class</code>文件名是.java文件中class类的类名</li>
</ul>
</li>
<li>通过java.exe对生成的.class文件进行运行</li>
</ol>
</li>
</ul>
<p><img src="./images/01JAVA语言概述/image-20210921202557620.png" alt="image-202109202557620" /></p>
<ul>
<li>注意！java对大小写敏感，为了避免不必要的报错，请留意</li>
</ul>
<div><pre><code><span>class</span> <span>HelloBit</span><span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"hello world! bit"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>将上述代码<code>helloworld.java</code>编译并执行</p>
<div><pre><code><span>></span> javac helloworld.java
<span># 这里会生成HelloBit.class文件，是因为helloworld.java的类名是这个</span>
<span>></span> java HelloBit
hello world<span>!</span> bit
<span># 这里记得.class的后缀名不用写上</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="注释"> 注释</h2>
<ul>
<li>java规范了三种注释方式
<ul>
<li>单行注释</li>
<li>多行注释</li>
<li>文档注释（java特有的
<ul>
<li>注释的内容可以被JDK提供的工具javadoc所解析，生成一套以网页文件形式体现的该程序的说明文件</li>
<li>javadoc解析的类只限public，javadoc也只解析<code>/** */</code>的内容
<ul>
<li><code>javadoc -d 生成输出的文件夹 -author -version javaj文件名.java</code></li>
<li>生成完毕之后打开文件夹内的index.html即可查看</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<div><pre><code><span>// 单行注释</span>

<span>/*
   我是多行注释
*/</span>

<span>/**
	文档解析
	@author bit - 作者
	@version v1.0 - 版本号
	这是一个注释案例
*/</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="api"> API</h2>
<p>API（Application Programming Interface, 应用程序编程接口）是Java提供的基本编程接口</p>
<p>注意api和文档不是一回事，混在一起的时候一般是api文档，其意思是关于api接口的文档</p>
<h1 id="目前为止的总结"> 目前为止的总结</h1>
<p>对第一个java程序的总结</p>
<ol>
<li>
<p>java程序编写-编译-运行的过程</p>
<ul>
<li>编写：我们将编写的java代码保存在以<code>.java</code>结尾的源文件中
<ul>
<li>编译：使用<code>javac.exe</code>命令编译我们的java源文件：<code>javac 源文件名.java</code>（这里会生成字节码文件）</li>
<li>运行：使用<code>java.exe</code>命令解释运行我们的字节码文件：<code>java 类名</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>在一个java源文件中可以生命多个class，但是，只能最多有一个类声明为public的，而且要求为public的类的类名必须与源文件名相同</p>
</li>
<li>
<p>程序的入口是main()方法，格式是固定的</p>
<div><pre><code><span>public</span> <span>class</span> <span>Helloworld</span><span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p>输出语句</p>
<div><pre><code><span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span> <span>// 先输出数据，然后换行</span>
<span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>)</span><span>;</span> <span>// 只输出数据</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>每一行执行语句都以<code>;</code>结束</p>
</li>
<li>
<p>编译的过程：编译以后，会生成一个或多个字节码文件，字节码文件的文件名与java源文件中的类名一致</p>
</li>
</ol>
<h1 id="考察"> 考察</h1>
<ol>
<li>
<p>JDK, JRE, JVM三者之间的关系，以及JDK、JRE的主要结构有哪些？</p>
<ul>
<li>JDK = JRE + Java的开发工具（javac.exe，java.exe，javadoc.exe）</li>
</ul>
</li>
<li>
<p>关于java的环境配置</p>
<div><pre><code>JAVA_HOME <span>=</span> bin的上一层目录
path <span>=</span> %JAVA_HOME%<span>\</span>bin
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>windows日常命令</p>
<div><pre><code><span>cd</span> md rd del cd<span>..</span> cd/
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>编写一日简单输出程序</p>
<ul>
<li>创建java文件：Hello.java</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>Hello</span><span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"hello"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>"the "</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"world"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
<li>
<p>编译和运行上述代码的指令</p>
<ul>
<li>编译：javac Hello.java（对应文件名</li>
<li>运行：java Hello（对应类名</li>
</ul>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>JAVASE | 02JAVA运算符与循环结构</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/hungry/JAVASE_02JAVA%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/hungry/JAVASE_02JAVA%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">JAVASE | 02JAVA运算符与循环结构</source>
      <category>求知</category>
      <pubDate>Tue, 26 Oct 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="java标识符"> java标识符</h1>
<p>day2</p>
<ol>
<li>标识符
<ul>
<li>凡是自己可以起名字的地方都叫标识符
<ul>
<li>比如：类名、变量名、方法名、接口名、包名</li>
</ul>
</li>
</ul>
</li>
<li>标识符的命名规则（如果不遵守，则编译不通过）
<ul>
<li>由26个英文字母大小写，<code>0-9</code>，<code>_</code>或<code>$</code>组成</li>
<li>数字不可以开头</li>
<li>不可以使用关键字和保留字，但能包含关键字和保留字</li>
<li>java中严格区分大小写，长度无限制</li>
<li>标识符不能包含空格</li>
</ul>
</li>
<li>java中的名称命名规范（建议遵守）
<ul>
<li>包名：多单词组成时所有字母都小写：<code>xxxyyyzzz</code></li>
<li>类名、接口名：多单词组成时，所有单词的首字母大写：<code>XxxYyyZzz</code></li>
<li>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个首字母大写：<code>xxxYyyZzz</code></li>
<li>常量名：所有字母都大写，多单词时每个单词用下划线链接：<code>XXX_YYY_ZZZ</code></li>
</ul>
</li>
<li>其他
<ul>
<li>在起名字时，为了提高阅读性，要尽量有意义，“见名知意”</li>
<li>java采用unicode字符集，所以标识符可以使用汉字，但非常不建议这样做</li>
</ul>
</li>
</ol>
<h1 id="变量的使用"> 变量的使用</h1>
<ol>
<li>java定义变量的格式：<code>据类型 变量名 = 变量值;</code></li>
<li>说明
<ol>
<li>变量必须先声明，后使用</li>
<li>变量都定义在其作用域内。在作用域内，他是有效的。换句话说，除了作用域，就失效了</li>
<li>同一作用域内，不可以声明两个同名的变量</li>
</ol>
</li>
</ol>
<h1 id="java定义的数据类型"> Java定义的数据类型</h1>
<ul>
<li>
<p>变量按照数据类型来分：</p>
<ul>
<li>基本数据类型
<ul>
<li>整型：byte \ short \ int \ long</li>
<li>浮点型：float \ double</li>
<li>字符型：char</li>
<li>布尔型：boolean</li>
</ul>
</li>
<li>引用数据类型：
<ul>
<li>类（class）</li>
<li>接口（interface）</li>
<li>数组（array）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>变量在类中声明的位置：</p>
<ul>
<li>成员变量</li>
<li>局部变量</li>
</ul>
</li>
</ul>
<h2 id="详细的"> 详细的：</h2>
<ol>
<li>整型：byte(1字节=8bit) \ short(2字节) \ int(4字节) \ long(8字节)
<ul>
<li>byte范围：-128 ~ 127
<ul>
<li>若超过byte的范围，编译不通过</li>
</ul>
</li>
<li>声明long型变量，必须以<code>l</code>或<code>L</code>结尾</li>
<li>通常定义整型变量时，使用int型</li>
<li>整型的常量，一般是int</li>
</ul>
</li>
<li>浮点型：单精度float(4字节) \ 双精度double(8字节)
<ul>
<li>浮点型，表示带小数点的数值</li>
<li>float表示数值的范围比long还大（因为他可以扩展大小）</li>
<li>定义float类型变量时，变量要以<code>f</code>或<code>F</code>结尾</li>
<li>通常，定义浮点型变量，使用double型</li>
<li>浮点型常量，默认为double</li>
</ul>
</li>
<li>字符型：char(1字符[即2字节])
<ul>
<li>
<p>定义char型变量，通常使用一对<code>''</code>，内部只能写一个字母</p>
<ul>
<li>
<p>也可以不带<code>''</code></p>
<div><pre><code><span>char</span> c2 <span>=</span> <span>97</span><span>;</span><span>//开发中非常少见</span>
<span>//注意5和'5'不一样</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
</ul>
</li>
<li>
<p>表示方式：</p>
<ol>
<li>声明一个字符</li>
<li>转义字符</li>
</ol>
</li>
<li>
<p>直接使用 Unicode 值来表示字符型变量</p>
</li>
</ul>
</li>
<li>布尔型：boolean
<ul>
<li>只能取两个值之一：true、false</li>
<li>常常在条件判断、循环结构中使用</li>
<li>默认初始化的值是flase</li>
</ul>
</li>
</ol>
<h1 id="基本数据类型之间的运算规则"> 基本数据类型之间的运算规则</h1>
<h2 id="自动类型转换"> 自动类型转换</h2>
<p>前提：这里讨论只是7种基本数据类型变量间的运算。不包含boolean类型</p>
<ul>
<li>当容量小的数据类型的变量语容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型
<ul>
<li>说明：此时容量的大小指的是表示数的范围大和小，例如float的容量要比long的容量大，则使用float来进行数的计算</li>
</ul>
</li>
<li>byte、char、short --&gt; int --&gt; float --&gt; double
<ul>
<li>特別的：当byte、char、short三种类型的变量做运算时，结果为int型，所以要使用大容量的类型进行接收</li>
</ul>
</li>
</ul>
<h2 id="强制类型转换"> 强制类型转换</h2>
<ul>
<li>强制类型转换：自动类型提升运算的逆运算
<ol>
<li>需要使用强制转换符: <code>(类型)变量名</code></li>
<li>注意点：强制类型转换，可能导致精度损失</li>
</ol>
</li>
</ul>
<div><pre><code><span>// 精度损失的情况</span>
<span>// 截断操作；强制转换int型，可以看到小数点直接没了，这种情况叫做损失精度</span>
<span>int</span> i1 <span>=</span> <span>(</span><span>int</span><span>)</span>d1<span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i1<span>)</span><span>;</span>
<span>// 没有精度损失的情况</span>
<span>// 由于long型的l1前面都是0，所以short在截断操作的时候并没有将有效数据123给砍掉</span>
<span>long</span> l1 <span>=</span> <span>123</span><span>;</span>
<span>short</span> s2 <span>=</span> <span>(</span><span>short</span><span>)</span>l1<span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s2<span>)</span><span>;</span>
<span>// 精度损失的情况</span>
<span>// 这里涉及到二进制的反码补码问题，详细说明看：		https://blog.csdn.net/zy986718042/article/details/71699079</span>
<span>int</span> i2 <span>=</span> <span>128</span><span>;</span>
<span>byte</span> b <span>=</span> <span>(</span><span>byte</span><span>)</span>i2<span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>b<span>)</span><span>;</span><span>// -128</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id="类型不同变量类型的使用"> 类型不同变量类型的使用</h2>
<ol>
<li>编码情况
<ul>
<li>如果右边的常量为<code>long</code>则需要添加l或<code>L</code>，否则一般情况会将其视为<code>int</code>型</li>
<li>如果右边的常量为<code>float</code>则需要添加f或<code>F</code>,否则一般情况会将其视为<code>double</code>型</li>
</ul>
</li>
<li>编码情况
<ul>
<li>
<p>当变量与常量进行计算的时候，会将<code>1</code>这类视为<code>int型常量</code>，则byte, char, short与int型常量进行计算的时候会自动提升为int型</p>
</li>
<li>
<p>当变量与常量进行计算的时候，会将<code>12.3</code>这类视为<code>double型常量</code>，则其他类型与double型进行计算的时候会自动提升为double型</p>
<div><pre><code><span>// 1. 编码情况</span>
<span>// 默认情况右边的值末尾应该有l或L，但这里右边的值看做int型，自动类型提升赋值给了long型</span>
<span>long</span> l <span>=</span> <span>123213</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>l<span>)</span><span>;</span>

<span>// 编译失败：右边的值没有加l或L，所以java将其看做int</span>
<span>// 但这里的数超出了int的范围，所以发出报错</span>
<span>// long l1 = 2112313123123123;</span>
<span>// 这里加了L使得右边的数为long型则可以进行赋值操作</span>
<span>long</span> l1 <span>=</span> <span>2112313123123123L</span><span>;</span>

<span>// 编译失败：右边的值没有加f或F，所以java将其看做double型</span>
<span>// double型赋值给float型，自动类型提升所以会发生报错</span>
<span>// float f1 = 13.4;</span>

<span>// ------------------------</span>

<span>// 2. 编码情况</span>
<span>// 整型常量，默认类型为int型</span>
<span>// 编译失败：1为常量(整型)</span>
<span>byte</span> b <span>=</span><span>12</span><span>;</span>
<span>// byte b2 = b + 1;</span>

<span>// 浮点型常量，默认为double型</span>
<span>// 编译失败：12.3为常量(double型)</span>
<span>// float f2 = b + 12.3;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div></li>
</ul>
</li>
</ol>
<h3 id="字符串类型-string"> 字符串类型：String</h3>
<ul>
<li>
<p>String类型变量的使用</p>
<ol>
<li>String属于引用数据类型，翻译为：字符串</li>
<li>声明String类型变量时，使用一对<code>&quot;&quot;</code></li>
<li>String可以和8种基本数据变量做运算，且运算只能时连接运算：<code>+</code></li>
<li>运算的结果仍然是String类型</li>
</ol>
</li>
<li>
<p>关于<code>+</code>运算符</p>
<ul>
<li>
<p>当<code>char byte short int float double</code>在使用<code>+</code>的时候，它就代表加法计算运算符</p>
<div><pre><code><span>char</span> c <span>=</span> <span>'a'</span><span>;</span>
<span>int</span> num <span>=</span> <span>10</span><span>;</span>
<span>String</span> str <span>=</span> <span>"hello"</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>c <span>+</span> num <span>+</span> str<span>)</span><span>;</span><span>//107hello</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>c <span>+</span> str <span>+</span> num<span>)</span><span>;</span><span>//ahello10</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>c <span>+</span> <span>(</span>num <span>+</span> str<span>)</span><span>)</span><span>;</span><span>//a10hello</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>(</span>c <span>+</span> num<span>)</span> <span>+</span> str<span>)</span><span>;</span><span>//107hello</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str <span>+</span> num <span>+</span> c<span>)</span><span>;</span><span>//hello10a</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></li>
<li>
<p>当出现数字与<code>String</code>计算的时候，就是连接运算符，只做拼接运算</p>
<div><pre><code><span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"*   *"</span><span>)</span><span>;</span><span>//*   *</span>
<span>// 不成功是因为char型和char型(int+int)会自动转换为int型，所以这里+是加法计算</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>'*'</span> <span>+</span> <span>'\t'</span> <span>+</span> <span>'*'</span><span>)</span><span>;</span><span>//93</span>
<span>// 中间是String，所以做了连接运算,int+String+int</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>'*'</span> <span>+</span> <span>"\t"</span> <span>+</span> <span>'*'</span><span>)</span><span>;</span><span>//*   *</span>
<span>// 不成功是因为'*'+'\t'先计算，还是使用了+加法计算符</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>'*'</span> <span>+</span> <span>'\t'</span> <span>+</span> <span>"*"</span><span>)</span><span>;</span><span>//51*</span>
<span>// 在最后的计算中是String+(int+String)，所以做了链接运算</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>'*'</span> <span>+</span> <span>(</span><span>'\t'</span> <span>+</span> <span>"*"</span><span>)</span><span>)</span><span>;</span><span>//*   *</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></li>
</ul>
</li>
</ul>
<h2 id="练习1"> 练习1</h2>
<div><pre><code><span>// 这里的4是int常量，注意不能直接赋值给String！！！</span>
<span>String</span> str1 <span>=</span> <span>4</span><span>;</span><span>//判断对错：false *难点！</span>
<span>String</span> str2 <span>=</span> <span>3.5f</span> <span>+</span> <span>""</span><span>;</span><span>//判断对错：true</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>3</span><span>+</span><span>4</span><span>+</span><span>"Hello!"</span><span>)</span><span>;</span><span>//输出：7Hello!</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Hello!"</span><span>+</span><span>3</span><span>+</span><span>4</span><span>)</span><span>;</span><span>//输出：Hello!34</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>'a'</span><span>+</span><span>1</span><span>+</span><span>"Hello!"</span><span>)</span><span>;</span><span>//输出：98Hello!</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Hello"</span><span>+</span><span>'a'</span><span>+</span><span>1</span><span>)</span><span>;</span><span>//输出：Hello!a1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="练习2"> 练习2</h2>
<div><pre><code>
<span>short</span> s <span>=</span> <span>5</span><span>;</span>
<span>// 判断：false 因为s-2是int，但s是short，所以会报错</span>
s <span>=</span> s<span>-</span><span>2</span><span>;</span>

<span>byte</span> b <span>=</span> <span>3</span><span>;</span>
<span>// 判断：false 因为b+4是int，但b是byte，所以会报错</span>
b <span>=</span> b <span>+</span> <span>4</span><span>;</span>
<span>// 判断：true (int)7强制为(byte)7</span>
b <span>=</span> <span>(</span><span>byte</span><span>)</span><span>(</span>b<span>+</span><span>4</span><span>)</span><span>;</span>

<span>char</span> c <span>=</span> <span>'a'</span><span>;</span>
<span>int</span> i <span>=</span> <span>5</span><span>;</span>
<span>float</span> d <span>=</span> <span>.314F</span><span>;</span>
<span>// 判断: true char+int=int,int+float=double;所以结果为(double)102.314...</span>
<span>double</span> result <span>=</span> c<span>+</span>i<span>+</span>d<span>;</span>

<span>byte</span> b <span>=</span> <span>5</span><span>;</span>
<span>short</span> s <span>=</span> <span>3</span><span>;</span>
<span>// 判断：false byte+short=int,所以t会报错</span>
<span>short</span> t <span>=</span> s <span>+</span> b<span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h1 id="关于进制"> 关于进制</h1>
<ul>
<li>所有数字在计算机底层都以二进制形式存在</li>
<li>对于整数，有四种表示方法：
<ul>
<li>二进制(binary)：0,1 满2进1，以<code>0b</code>或<code>0B</code>开头</li>
<li>十进制(decimal)：0-9 满10进1</li>
<li>八进制(octal)：0-7 满8进1，<strong>以数字0开头表示</strong></li>
<li>十六进制(hex)：0-9及A-F，满16进1，<strong>以<code>0x</code>或<code>0X</code>开头表示</strong>，此处的A-F不区分大小写，如<code>0x21AF + 1 = 0X21B0</code></li>
</ul>
</li>
</ul>
<div><pre><code><span>int</span> num1 <span>=</span> <span>0b110</span><span>;</span>
<span>int</span> num2 <span>=</span> <span>110</span><span>;</span>
<span>// 注意这里不能写0128，因为八进制的八为10不存在8</span>
<span>int</span> num3 <span>=</span> <span>0127</span><span>;</span>
<span>int</span> num4 <span>=</span> <span>0x110A</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"num1 = "</span> <span>+</span> num1<span>)</span><span>;</span><span>//6</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"num1 = "</span> <span>+</span> num2<span>)</span><span>;</span><span>//110</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"num1 = "</span> <span>+</span> num3<span>)</span><span>;</span><span>//87</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"num1 = "</span> <span>+</span> num4<span>)</span><span>;</span><span>//4362</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="二进制"> 二进制</h2>
<ul>
<li>
<p>二进制的整数有如下三种形式：</p>
<ul>
<li>原码：直接将一个数值换成二进制数，最高位是符号位</li>
<li>负数的反码：是对原码按位取反，只是最高位（符号位）确定为1</li>
<li>负数的补码：其反码加1</li>
</ul>
</li>
<li>
<p>计算机底层都以二进制<strong>补码</strong>的形式来存储数据</p>
<ul>
<li><strong>正数的原码、反码、补码都相同</strong></li>
<li><strong>负数的补码是其反码+1</strong></li>
</ul>
</li>
<li>
<p>从原码到补码</p>
<ul>
<li>原码</li>
<li>反码（除符号位外，取反）</li>
<li>补码（+1）</li>
</ul>
</li>
<li>
<p>在二进制的符号位中，<strong>0为正数，1为负数</strong></p>
<ul>
<li>在计算机的底层中以补码存储
<ul>
<li>-127:1000001</li>
<li>-128:1000000</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="考察"> 考察</h1>
<ol>
<li>标识符的命名规则有那些？（不遵循，编译不通过
<ul>
<li>由26个英文字母大小写，<code>0-9</code>，<code>_</code>或<code>$</code>组成</li>
<li>数字不可以开头</li>
<li>不可以使用关键字和保留字，但能包含关键字和保留字</li>
<li>java中严格区分大小写，长度无限制</li>
<li>标识符不能包含空格</li>
</ul>
</li>
<li>标识符的命名规范有哪些？（不遵循，编译允许都可以通过
<ul>
<li>包名：xxxyyyzzz</li>
<li>类名、接口名：XxxYyyZzz</li>
<li>变量名、方法名：xxxYyyZzz</li>
<li>常量名：XXX_YYY_ZZZ</li>
</ul>
</li>
<li>Java变量技照数据类型怎么划分？并指出Java的基本数据类型有哪8种，并指出各自占用的内存空间大小
<ul>
<li>byte short int long</li>
<li>char（一个字符=两个字节）</li>
<li>float double</li>
<li>boolean</li>
<li>引用数据类型：类、接口、数组</li>
</ul>
</li>
<li>说明基本数据类型变量之间自动类型提升的运算规则
<ul>
<li>byte short char -&gt; int -&gt; long -&gt; float -&gt; double</li>
</ul>
</li>
<li>说明基本数据类型变量之间强制类型转换的使用规则和强转可能出现的问题
<ul>
<li>容量大 -&gt; 容量小</li>
<li>使用强转符<code>()</code></li>
<li>强转可能会出现<strong>精度损失</strong>的问题</li>
</ul>
</li>
</ol>
<h1 id="运算符"> 运算符</h1>
<p>day3</p>
<ul>
<li>算术运算符</li>
<li>赋值运算符</li>
<li>比较运算符（关系运算符）</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>三元运算符</li>
</ul>
<h2 id="算术运算符"> 算术运算符</h2>
<p><img src="./images/02变量与运算符/image-20210929190416608.png" alt="image-20210929190416608" /></p>
<h3 id="除号"> 除号</h3>
<ul>
<li><code>/</code>除号</li>
</ul>
<div><pre><code><span>/*
运算符之一：算术运算符
    - `+ - + - * / (前)++ (后)++ (前)-- (后)-- +`
*/</span>
<span>int</span> num1 <span>=</span> <span>12</span><span>;</span>
<span>int</span> num2 <span>=</span> <span>5</span><span>;</span>
<span>// 由于两个运算的变量都是int型，所以运算的结果是int型，小数点会自动去除</span>
<span>int</span> result1 <span>=</span> num1 <span>/</span> num2<span>;</span><span>//2</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>result1<span>)</span><span>;</span>
<span>int</span> result2 <span>=</span> num1 <span>/</span> num2 <span>*</span> num2<span>;</span><span>//10</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>result2<span>)</span><span>;</span>

<span>double</span> result3 <span>=</span> num1 <span>/</span> num2<span>;</span><span>//2.0</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>result3<span>)</span><span>;</span>

<span>// 先对int进行计算，在+0.0</span>
<span>double</span> result4 <span>=</span> num1 <span>/</span> num2<span>+</span><span>0.0</span><span>;</span><span>//2.0</span>
<span>// 只要参与计算的其中一个为double，则值2.4</span>
<span>double</span> result5 <span>=</span> num1 <span>/</span> <span>(</span>num2 <span>+</span> <span>0.0</span><span>)</span><span>;</span><span>//2.4</span>
<span>double</span> result6 <span>=</span> <span>(</span><span>double</span><span>)</span>num1 <span>/</span> num2<span>;</span><span>//2.4</span>
<span>double</span> result7 <span>=</span> <span>(</span><span>double</span><span>)</span><span>(</span>num1 <span>/</span> num2<span>)</span><span>;</span><span>//2/0</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>result5<span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>result6<span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>result7<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id="取余运算"> 取余运算</h3>
<ul>
<li><code>%</code>：取余运算</li>
</ul>
<div><pre><code><span>// 结果的符号与被摸数的符号相同</span>
<span>// 后面会经常使用%来判断是否能被除尽的情况</span>
<span>int</span> m1 <span>=</span> <span>12</span><span>;</span>
<span>int</span> n1 <span>=</span> <span>5</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"m1 % n1 = "</span> <span>+</span> m1 <span>%</span> n1<span>)</span><span>;</span><span>//2</span>

<span>int</span> m2 <span>=</span> <span>-</span><span>12</span><span>;</span>
<span>int</span> n2 <span>=</span> <span>5</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"m2 % n2 = "</span> <span>+</span> m2 <span>%</span> n2<span>)</span><span>;</span><span>//-2</span>

<span>int</span> m3 <span>=</span> <span>12</span><span>;</span>
<span>int</span> n3 <span>=</span> <span>-</span><span>5</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"m3 % n3 = "</span> <span>+</span> m3 <span>%</span> n3<span>)</span><span>;</span><span>//2</span>

<span>int</span> m4 <span>=</span> <span>-</span><span>12</span><span>;</span>
<span>int</span> n4 <span>=</span> <span>-</span><span>5</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"m4 % n4 = "</span> <span>+</span> m4 <span>%</span> n4<span>)</span><span>;</span><span>//-2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id="自增与自减"> 自增与自减</h3>
<ul>
<li><code>(前)++</code> :先自增1，再运算</li>
<li><code>(后)++</code> :先运算，后自增1</li>
<li><code>(前)--</code> :先自减1，再运算</li>
<li><code>(后)--</code>:先运算，后自减1</li>
</ul>
<div><pre><code><span>// 注意点：</span>
<span>short</span> s1 <span>=</span> <span>10</span><span>;</span>
<span>// s1 = s1 + 1;//编译失败，因为s1是short型，不能存入int型</span>
s1 <span>=</span> <span>(</span><span>short</span><span>)</span><span>(</span>s1<span>+</span><span>1</span><span>)</span><span>;</span><span>//正确，类型强转</span>
<span>// 自增自减不会改变本身变量的数据类型</span>
s1<span>++</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s1<span>)</span><span>;</span>

<span>// 问题：因为01111 1111+1会变成1111 1111，即-128</span>
<span>byte</span> bb1 <span>=</span> <span>127</span><span>;</span>
bb1<span>++</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>bb1<span>)</span><span>;</span><span>//-128</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="练习1-2"> 练习1</h3>
<p><img src="./images/02变量与运算符/image-20210929195507518.png" alt="image-20210929195507518" /></p>
<h3 id="练习2-2"> 练习2</h3>
<div><pre><code><span>/*
练习2
随意给出一个三位数的整数，打印显示他的个位数，十位数，百位数的值
格式如下：
数字xxx的情况如下：
个位数：
十位数：
百位数：

例如：
数字153的情况如下：
个位数：3
十位数：5
百位数：1
*/</span> 
<span>class</span> <span>AriExer2</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span><span>{</span>
        <span>int</span> num <span>=</span> <span>187</span><span>;</span>
        <span>int</span> bai <span>=</span> num <span>/</span> <span>100</span><span>;</span>
        <span>int</span> shi <span>=</span> num <span>%</span> <span>100</span> <span>/</span> <span>10</span><span>;</span><span>//int shi = num /10 % 10</span>
        <span>int</span> ge <span>=</span> num <span>%</span> <span>10</span><span>;</span>

        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"百位为："</span><span>+</span> bai<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"十位为："</span><span>+</span> shi<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"个位为："</span><span>+</span> ge<span>)</span><span>;</span>
    <span>}</span>
    
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h2 id="赋值运算符"> 赋值运算符</h2>
<ul>
<li>符号：<code>=</code>
<ul>
<li>当<code>=</code>两侧数据类型不一致时，可以使用自动类型转换或使用强制类型转换原则进行处理</li>
<li>支持连续赋值</li>
</ul>
</li>
<li><code>= += *= /= %=</code></li>
</ul>
<div><pre><code><span>/*
运算符之二：赋值运算符
- `= += *= /= %=`
*/</span>
<span>// 赋值符号：=</span>
<span>int</span> i1 <span>=</span> <span>10</span><span>;</span>
<span>int</span> j1 <span>=</span> <span>10</span><span>;</span>

<span>int</span> i2<span>,</span> j2<span>;</span>
<span>// 连续赋值</span>
i2 <span>=</span> j2 <span>=</span> <span>10</span><span>;</span>
<span>int</span> i3 <span>=</span> <span>10</span><span>,</span> j3 <span>=</span> <span>20</span><span>;</span>

<span>// ------------------------</span>
<span>int</span> num1 <span>=</span> <span>10</span><span>;</span>
num1 <span>+=</span><span>2</span><span>;</span><span>//num1 = num1 + 2;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>num1<span>)</span><span>;</span><span>//12</span>

<span>int</span> num2 <span>=</span> <span>12</span><span>;</span>
num2 <span>%=</span> <span>5</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>num2<span>)</span><span>;</span>

<span>// 与自增自减那样，`+= *= /= %=`不会改变本身的数据类型</span>
<span>short</span> s1 <span>=</span> <span>10</span><span>;</span>
s1 <span>+=</span><span>2</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s1<span>)</span><span>;</span>

<span>// 在开发中：如果希望变量实现+2的操作，有几种方法？（前提：int num = 10）</span>
<span>// 推荐方法：num += 2;</span>
<span>// 方法二：num = num + 2;</span>

<span>// 在开发中：如果希望变量实现+1的操作，有几种方法？（前提：int num = 10）</span>
<span>// 推荐方法：num++;</span>
<span>// 方法二：num += 1;</span>
<span>// 方法三：num = num + 2;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><h3 id="练习"> 练习</h3>
<ul>
<li>
<p>思考1</p>
<div><pre><code><span>short</span> s <span>=</span> <span>3</span><span>;</span>
s <span>=</span> s<span>+</span><span>2</span><span>;</span>
s <span>+=</span> <span>2</span><span>;</span>
<span>// 上述代码中有什么区别</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>
<li>第2行会报错，因为s+2是int型，第3行不会报错</li>
</ul>
</li>
<li>
<p>思考2</p>
<div><pre><code><span>int</span> i <span>=</span> <span>1</span><span>;</span>
i <span>*=</span> <span>0.1</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i<span>)</span><span>;</span>
i<span>++</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li>因为*=不会改变本身的数据类型，所以这里不会报错，第3行是输出0，第五行是输出1</li>
</ul>
</li>
<li>
<p>思考3</p>
<div><pre><code><span>int</span> m <span>=</span> <span>2</span><span>;</span>
<span>int</span> n <span>=</span> <span>3</span><span>;</span>
n <span>*=</span> m<span>++</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"m="</span><span>+</span>m<span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"n="</span><span>+</span>n<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li>
<p>输出：</p>
<div><pre><code>m<span>=</span><span>3</span>
n<span>=</span><span>6</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
</ul>
</li>
<li>
<p>思考4</p>
<div><pre><code><span>int</span> n <span>=</span> <span>10</span><span>;</span>
n <span>+=</span> <span>(</span>n<span>++</span><span>)</span> <span>+</span> <span>(</span><span>++</span>n<span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>n<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>32
<ul>
<li>n = n[10] + (10[n=11] + 12[n=12])</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="比较运算符"> 比较运算符</h2>
<p><img src="./images/02变量与运算符/image-20210929225529958.png" alt="image-20210929225529958" /></p>
<ul>
<li>比较运算符的结果都是boolean型，也就是要么是true，要么是false</li>
<li><strong>比较运算符<code>==</code>不能误写成<code>=</code></strong></li>
<li>结论
<ol>
<li>比较运算符的结果是boolean类型</li>
<li>区分<code>==</code>和<code>=</code></li>
</ol>
</li>
</ul>
<div><pre><code><span>/*
运算符之三：比较运算符
== != > &lt; >= &lt;= instanceof
*/</span>
<span>int</span> i <span>=</span> <span>10</span><span>;</span>
<span>int</span> j <span>=</span> <span>20</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i <span>==</span> j<span>)</span><span>;</span><span>//false</span>
<span>// 赋值并输出</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i <span>=</span> j<span>)</span><span>;</span><span>//20</span>

<span>boolean</span> b1 <span>=</span> <span>true</span><span>;</span>
<span>boolean</span> b2 <span>=</span> <span>false</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>b2 <span>==</span> b1<span>)</span><span>;</span><span>//fa;se</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>b2 <span>=</span> b1<span>)</span><span>;</span><span>//true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="练习-2"> 练习</h3>
<ul>
<li>练习1</li>
</ul>
<div><pre><code><span>boolean</span> b1 <span>=</span> <span>false</span><span>;</span>
<span>// 注意区分==和=的区别</span>
<span>if</span><span>(</span>b1<span>==</span><span>true</span><span>)</span>
  <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"结果为真"</span><span>)</span><span>;</span><span>//=输出这个</span>
<span>else</span>
  <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"结果为假"</span><span>)</span><span>;</span><span>//==输出这个</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="逻辑运算符"> 逻辑运算符</h2>
<p><img src="./images/02变量与运算符/image-20211003223802838.png" alt="image-20211003223802838" /></p>
<ul>
<li>结论：
<ul>
<li>逻辑运算符操作的都是boolean类型的变量</li>
</ul>
</li>
<li>区分：&amp; 与 &amp;&amp;
<ul>
<li>相同点1： &amp; 与 &amp;&amp; 的运算结果相同</li>
<li>相同点2： 当符号左边是true时，二者都会执行符号右边的运算</li>
<li>不同点：当符号左边是false时，&amp;继续执行符号右边的运算。&amp;&amp;不再执行符号右边的运算</li>
<li>开发中推荐使用&amp;&amp;</li>
</ul>
</li>
<li>&amp;&amp;和&amp;结果一样，&amp;&amp;有短路效果，左边为false，右边不执行；&amp;左边无论是什么，右边都会执行。</li>
<li>区分：| 与 ||
<ul>
<li>相同点1： | 与 || 的运算结果相同</li>
<li>相同点2： 当符号左边是false时，二者都会执行符号右边的运算</li>
<li>不同点3：当符号左边是true时，|继续执行符号右边的运算。||不再执行符号右边的运算</li>
<li>开发中推荐使用||</li>
</ul>
</li>
<li>||和|结果一样，||有短路效果，左边为true，右边不执行；|左边无论是什么，右边都会执行。</li>
</ul>
<div><pre><code><span>boolean</span> b1 <span>=</span> <span>true</span><span>;</span>
b1 <span>=</span> <span>false</span><span>;</span>
<span>int</span> num1 <span>=</span> <span>10</span><span>;</span>
<span>if</span><span>(</span>b1 <span>&amp;</span> <span>(</span>num1<span>++</span> <span>></span> <span>0</span><span>)</span><span>)</span><span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"我现在在北京"</span><span>)</span><span>;</span>
<span>}</span><span>else</span><span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"我现在在南京"</span><span>)</span><span>;</span>
<span>}</span>

<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"num1="</span><span>+</span>num1<span>)</span><span>;</span>

<span>boolean</span> b2 <span>=</span> <span>true</span><span>;</span>
b2 <span>=</span> <span>false</span><span>;</span>
<span>int</span> num2 <span>=</span> <span>10</span><span>;</span>
<span>if</span><span>(</span>b2 <span>&amp;&amp;</span> <span>(</span>num2<span>++</span> <span>></span> <span>0</span><span>)</span><span>)</span><span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"我现在在北京"</span><span>)</span><span>;</span>
<span>}</span><span>else</span><span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"我现在在南京"</span><span>)</span><span>;</span>
<span>}</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"num2="</span><span>+</span>num2<span>)</span><span>;</span>

<span>// 区分：| 与 ||</span>
<span>// 相同点1： | 与 || 的运算结果相同</span>
<span>// 相同点2： 当符号左边是false时，二者都会执行符号右边的运算</span>
<span>// 不同点3：当符号左边是true时，|继续执行符号右边的运算。||不再执行符号右边的运算</span>
<span>// 开发中推荐使用||</span>
<span>boolean</span> b3 <span>=</span> <span>false</span><span>;</span>
b3 <span>=</span> <span>true</span><span>;</span>
<span>int</span> num3 <span>=</span> <span>10</span><span>;</span>
<span>if</span><span>(</span>b3 <span>|</span> <span>(</span>num3<span>++</span> <span>></span> <span>0</span><span>)</span><span>)</span><span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"我现在在北京"</span><span>)</span><span>;</span>
<span>}</span><span>else</span><span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"我现在在南京"</span><span>)</span><span>;</span>
<span>}</span>

<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"num3="</span><span>+</span>num3<span>)</span><span>;</span>

<span>boolean</span> b4 <span>=</span> <span>false</span><span>;</span>
b4 <span>=</span> <span>true</span><span>;</span>
<span>int</span> num4 <span>=</span> <span>10</span><span>;</span>
<span>if</span><span>(</span>b4 <span>||</span> <span>(</span>num4<span>++</span> <span>></span> <span>0</span><span>)</span><span>)</span><span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"我现在在北京"</span><span>)</span><span>;</span>
<span>}</span><span>else</span><span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"我现在在南京"</span><span>)</span><span>;</span>
<span>}</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"num4="</span><span>+</span>num4<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><h3 id="练习-3"> 练习</h3>
<ul>
<li>练习1<div><pre><code><span>int</span> x <span>=</span> <span>1</span><span>;</span>
<span>int</span> y <span>=</span> <span>1</span><span>;</span>
<span>//flase &amp; true = false</span>
<span>if</span><span>(</span>x<span>++</span><span>==</span><span>2</span> <span>&amp;</span> <span>++</span>y<span>==</span><span>2</span><span>)</span><span>{</span>
  x<span>=</span><span>7</span><span>;</span>
<span>}</span>
x<span>=</span><span>2</span><span>,</span>y<span>=</span><span>2</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"x="</span><span>+</span>x<span>+</span><span>",y="</span><span>+</span>y<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></li>
<li>练习2<div><pre><code><span>int</span> x<span>=</span><span>1</span><span>,</span> y<span>=</span><span>1</span><span>;</span>
<span>//false</span>
<span>if</span><span>(</span>x<span>++</span><span>==</span><span>2</span> <span>&amp;&amp;</span> <span>++</span>y<span>==</span><span>2</span><span>)</span><span>{</span>
  x<span>=</span><span>7</span><span>;</span>
<span>}</span>
<span>//x=2.y=1;  由于双&amp;&amp;，所以false后面不执行</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"x="</span><span>+</span>x<span>+</span><span>",y="</span><span>+</span>y<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
<li>练习3<div><pre><code><span>int</span> x<span>=</span><span>1</span><span>,</span> y<span>=</span><span>1</span><span>;</span>
<span>//true | false = true</span>
<span>if</span><span>(</span>x<span>++</span><span>==</span><span>1</span> <span>|</span> <span>++</span>y<span>==</span><span>1</span><span>)</span><span>{</span>
  x<span>=</span><span>7</span><span>;</span>
<span>}</span>
<span>//x=7,y=2</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"x="</span><span>+</span>x<span>+</span><span>",y="</span><span>+</span>y<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
<li>练习4<div><pre><code><span>int</span> x<span>=</span><span>1</span><span>,</span>y<span>=</span><span>1</span><span>;</span>
<span>//true</span>
<span>if</span><span>(</span>x<span>++</span><span>==</span><span>1</span> <span>||</span> <span>++</span>y<span>==</span><span>1</span><span>)</span><span>{</span>
  x<span>=</span><span>7</span><span>;</span>
<span>}</span>
<span>//x=7,y=1;  由于双||，所以true后面不执行</span>
<span>System</span><span>.</span>out<span>.</span><span>prinln</span><span>(</span><span>"x="</span><span>+</span>x<span>+</span><span>",y="</span><span>+</span>y<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
<li>练习5<div><pre><code><span>class</span> <span>Test</span><span>{</span>
  <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span><span>{</span>
    <span>boolean</span> x<span>=</span><span>true</span><span>;</span>
    <span>boolean</span> y<span>=</span><span>false</span><span>;</span>
    <span>short</span> z<span>=</span><span>42</span><span>;</span>
    <span>//if(y==ture)</span>
    <span>// z++==42为true，y=true为true</span>
    <span>if</span><span>(</span><span>(</span>z<span>++</span><span>==</span><span>42</span><span>)</span><span>&amp;&amp;</span><span>(</span>y<span>=</span><span>true</span><span>)</span><span>)</span>z<span>++</span><span>;</span>
    <span>// x=false为false，++z==45为true</span>
    <span>if</span><span>(</span><span>(</span>x<span>=</span><span>false</span><span>)</span> <span>||</span> <span>(</span><span>++</span>z<span>==</span><span>45</span><span>)</span><span>)</span>z<span>++</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"z="</span><span>+</span>z<span>)</span><span>;</span>
  <span>}</span><span>//z=46</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div></li>
</ul>
<h2 id="位运算符"> 位运算符</h2>
<p><img src="./images/02变量与运算符/image-20211008173758318.png" alt="image-20211008173758318" />
<img src="./images/02变量与运算符/image-20211008190426441.png" alt="image-20211008190426441" /></p>
<ul>
<li>
<p><code>&lt;&lt; &gt;&gt; &gt;&gt;&gt;&amp; | ^ ~</code></p>
</li>
<li>
<p>结论：</p>
<ol>
<li>位运算符操作的都是整型的数据</li>
<li><code>&lt;&lt;</code>：在一定范围内，每向左移一位，相当于 *2</li>
<li><code>&gt;&gt;</code>：在一定范围内，每向右移一位，相当于 /2</li>
</ol>
</li>
<li>
<p>面试题：最高效方式的计算2*8：2&lt;&lt;3，或8&lt;&lt;1</p>
</li>
<li>
<p><code>&lt;&lt;</code>表示左移移，不分正负数，低位补0</p>
<ul>
<li>3: 0011 | 3&lt;&lt;2: 1100，即3&lt;&lt;2=12
<ul>
<li>或<code>3*2*2=12</code></li>
<li>结论：每移一位，都乘以一次2</li>
</ul>
</li>
</ul>
<div><pre><code> 正数：r = 20 &lt;&lt; 2
 20的二进制补码：0001 0100
 向左移动两位后：0101 0000
 结果：r = 80
 负数：r = -20 &lt;&lt; 2
 -20 的二进制原码 ：1001 0100
 -20 的二进制反码 ：1110 1011
 -20 的二进制补码 ：1110 1100
 左移两位后的补码：1011 0000
 反码：1010 1111
 原码：1101 0000
 结果：r = -80
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div></li>
<li>
<p><code>&gt;&gt;</code>表示右移，如果该数为正，则高位补0，若为负数，则高位补1；</p>
<ul>
<li>注：以下数据类型默认为byte-8位</li>
</ul>
<div><pre><code>  正数：r = 20 &gt;&gt; 2
  20的二进制补码：0001 0100
  向右移动两位后：0000 0101
  结果：r = 5
  负数：r = -20 &gt;&gt; 2
  -20 的二进制原码 ：1001 0100
  -20 的二进制反码 ：1110 1011
  -20 的二进制补码 ：1110 1100
  右移两位后的补码：1111 1011
  反码：1111 1010
  原码：1000 0101
  结果：r = -5
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div></li>
<li>
<p><code>&gt;&gt;&gt;</code>表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0</p>
<div><pre><code>  正数：　r = 20 &gt;&gt;&gt; 2
  的结果与 r = 20 &gt;&gt; 2 相同；
  负数：　r = -20 &gt;&gt;&gt; 2
  注：以下数据类型默认为int 32位
  -20:源码：10000000 00000000 00000000 00010100
  反码：11111111  11111111   11111111   11101011
  补码：11111111  11111111   11111111   11101100
  右移：00111111  11111111   11111111   11111011
  结果：r = 1073741819
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></li>
<li>
<p><code>&amp;|^</code></p>
<ul>
<li>
<p>代码</p>
<div><pre><code><span>int</span> m <span>=</span> <span>12</span><span>;</span>
<span>int</span> n <span>=</span> <span>5</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"m &amp; n: "</span> <span>+</span> <span>(</span>m <span>&amp;</span> n<span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"m | n: "</span> <span>+</span> <span>(</span>m <span>|</span> n<span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"m ^ n: "</span> <span>+</span> <span>(</span>m <span>^</span> n<span>)</span><span>)</span><span>;</span>
<span>/*
m &amp; n: 4
m | n: 13
m ^ n: 9
*/</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div></li>
<li>
<p>二进制的运算
<img src="./images/02变量与运算符/image-20211008193232055.png" alt="image-20211008193232055" /></p>
</li>
<li>
<p><code>m = k^n = (m^n)^n</code></p>
</li>
</ul>
</li>
</ul>
<div><pre><code><span>int</span> i <span>=</span> <span>21</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"i &lt;&lt; 2: "</span> <span>+</span> <span>(</span>i <span>&lt;&lt;</span> <span>2</span><span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"i &lt;&lt; 3: "</span> <span>+</span> <span>(</span>i <span>&lt;&lt;</span> <span>3</span><span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"i &lt;&lt; 27: "</span> <span>+</span> <span>(</span>i <span>&lt;&lt;</span> <span>27</span><span>)</span><span>)</span><span>;</span>
i <span>=</span> <span>-</span><span>21</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"i &lt;&lt; 27: "</span> <span>+</span> <span>(</span>i <span>&lt;&lt;</span> <span>27</span><span>)</span><span>)</span><span>;</span>

<span>int</span> m <span>=</span> <span>12</span><span>;</span>
<span>int</span> n <span>=</span> <span>5</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"m &amp; n: "</span> <span>+</span> <span>(</span>m <span>&amp;</span> n<span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"m | n: "</span> <span>+</span> <span>(</span>m <span>|</span> n<span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"m ^ n: "</span> <span>+</span> <span>(</span>m <span>^</span> n<span>)</span><span>)</span><span>;</span>
<span>// 练习：交换两个变量的值</span>
<span>int</span> num1 <span>=</span> <span>10</span><span>;</span>
<span>int</span> num2 <span>=</span> <span>20</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"num1 = "</span> <span>+</span> num1 <span>+</span> <span>",num2 = "</span> <span>+</span> num2<span>)</span><span>;</span>

<span>// 方法一：定义临时变量的方法（推荐的方法）</span>
<span>int</span> temp <span>=</span> num1<span>;</span>
num1 <span>=</span> num2<span>;</span>
num2 <span>=</span> temp<span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"num1 = "</span> <span>+</span> num1 <span>+</span> <span>",num2 = "</span> <span>+</span> num2<span>)</span><span>;</span>

<span>// 方法二：好处：不用定义零食变量</span>
<span>// 弊端：</span>
<span>//   1. 相加操作可能会超出存储范围</span>
<span>//   2. 有局限性，只能适用于数值类型</span>
num1 <span>=</span> num1 <span>+</span> num2<span>;</span>
num2 <span>=</span> num1 <span>-</span> num2<span>;</span>
num1 <span>=</span> num1 <span>-</span> num2<span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"num1 = "</span> <span>+</span> num1 <span>+</span> <span>",num2 = "</span> <span>+</span> num2<span>)</span><span>;</span>

<span>// 方法三：使用位运算符</span>
<span>// 有局限性，只能适用于数值类型</span>
num1 <span>=</span> <span>(</span>num1 <span>^</span> num2<span>)</span><span>;</span>
num2 <span>=</span> num1 <span>^</span> num2<span>;</span>
num1 <span>=</span> num1 <span>^</span> num2<span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"num1 = "</span> <span>+</span> num1 <span>+</span> <span>",num2 = "</span> <span>+</span> num2<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><h2 id="三元运算符"> 三元运算符</h2>
<ol>
<li>结构：(条件表达式)?表达式1: 表达式2</li>
<li>说明
<ol>
<li>条件表达式的结果为boolean类型</li>
<li>根据条件表达式真或假，决定执行表达式1，还是表达式2
<ul>
<li>如果表达式为true，则执行表达式1</li>
<li>如果表达式为false，则执行表达式2</li>
</ul>
</li>
<li>表达式1和表达式2要求使用的类型是一致的</li>
<li>三元运算符可以嵌套使用
<ul>
<li>嵌套使用的前提：编写的效率很高，算法改良</li>
</ul>
</li>
</ol>
</li>
<li>凡是可以使用三元运算符的地方，都可以改写成if-else
<ul>
<li>三元运算符与if-else的练习与区别
<ol>
<li>三元运算符可以简化if-else语句</li>
<li>三元运算符要求必须返回一个结果</li>
<li>if后的代码可有多个语句</li>
</ol>
</li>
<li>反之，不成立，因为if可以嵌套很多个elseif，是可以做复杂的流程语句的，三元运算符只建议用在简单的条件运算符</li>
</ul>
</li>
<li>如果程序既可以使用三元运算符，又可以if-else结构，那么优先选择三元运算符。
<ul>
<li>原因：简洁、执行效率高</li>
</ul>
</li>
</ol>
<div><pre><code><span>// 获取两个整数的较大值</span>
<span>int</span> m <span>=</span> <span>12</span><span>;</span>
<span>int</span> n <span>=</span> <span>5</span><span>;</span>
<span>int</span> max <span>=</span> <span>(</span>m <span>></span> n<span>)</span> <span>?</span> m <span>:</span> n<span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>max<span>)</span><span>;</span>

<span>// 编译错误：int型和字符串型</span>
<span>// (m > n) ? 2 :"大";</span>

<span>//-----------------------</span>
<span>// 嵌套写法虽然简单，但不建议写，因为可读性很差</span>
<span>String</span> maxStr <span>=</span> <span>(</span>m <span>></span> n<span>)</span><span>?</span> <span>"m大"</span> <span>:</span> <span>(</span><span>(</span>m <span>==</span> n<span>)</span><span>?</span> <span>"m和n相等"</span> <span>:</span> <span>"n大"</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>maxStr<span>)</span><span>;</span>

<span>//-----------------------</span>
<span>// 获取三个数的最大值</span>
<span>int</span> n1 <span>=</span> <span>12</span><span>;</span>
<span>int</span> n2 <span>=</span> <span>30</span><span>;</span>
<span>int</span> n3 <span>=</span> <span>-</span><span>43</span><span>;</span>

<span>int</span> max1 <span>=</span> <span>(</span>n1 <span>></span> n2<span>)</span><span>?</span> n1 <span>:</span> n2<span>;</span>
<span>int</span> max2 <span>=</span> <span>(</span>max1 <span>></span> n3<span>)</span><span>?</span> max <span>:</span> n3<span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"三个数中的最大值为："</span> <span>+</span> max2<span>)</span><span>;</span>

<span>// 改写成if-else</span>
<span>if</span><span>(</span>m <span>></span> n<span>)</span><span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>m<span>)</span><span>;</span>
<span>}</span><span>else</span><span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>n<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><h2 id="运算符的优先级"> 运算符的优先级</h2>
<ul>
<li>运算符有不同的优先级，所谓优先级就是表达式运算中的运算优先顺序如下图越往上优先级越高</li>
<li>只有弹幕运算符、三元运算符、赋值运算符是从右向左运算的
<img src="./images/02变量与运算符/image-20211010141918272.png" alt="image-20211010141918272" /></li>
</ul>
<h1 id="考察-2"> 考察</h1>
<ol>
<li><code>&amp;</code>和<code>&amp;&amp;</code>的异同</li>
</ol>
<ul>
<li>相同点1： &amp; 与 &amp;&amp; 的运算结果相同</li>
<li>相同点2： 当符号左边是true时，二者都会执行符号右边的运算</li>
<li>不同点：当符号左边是false时，&amp;继续执行符号右边的运算。&amp;&amp;不再执行符号右边的运算</li>
<li>开发中推荐使用&amp;&amp;</li>
<li>&amp;&amp;和&amp;结果一样，&amp;&amp;有短路效果，左边为false，右边不执行；&amp;左边无论是什么，右边都会执行。</li>
</ul>
<ol start="2">
<li>
<p>程序输出</p>
<div><pre><code><span>class</span> <span>OperatorTest</span><span>{</span> 
  <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
      <span>boolean</span> x <span>=</span> <span>true</span><span>;</span>
      <span>boolean</span> y <span>=</span> <span>false</span><span>;</span>
      <span>short</span> z <span>=</span> <span>40</span><span>;</span>
      <span>if</span> <span>(</span><span>(</span>z<span>++</span> <span>==</span> <span>40</span><span>)</span> <span>&amp;&amp;</span> <span>(</span>y <span>=</span> <span>true</span><span>)</span><span>)</span><span>{</span>
          z<span>++</span><span>;</span>
      <span>}</span>
      <span>if</span> <span>(</span><span>(</span>x <span>=</span> <span>false</span><span>)</span> <span>||</span> <span>(</span><span>++</span>z <span>==</span> <span>43</span><span>)</span><span>)</span><span>{</span>
          z<span>++</span><span>;</span>
      <span>}</span>
      <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"z= "</span><span>+</span>z<span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><ul>
<li>结果为：z= 44
<ul>
<li>第一个if中，z++==40和y=true都是true，true&amp;&amp;true所以执行第一个if语句</li>
<li>第二个if中，x=false是false，++z==43是true，false||true=true所以执行第二个if语句</li>
</ul>
</li>
</ul>
</li>
<li>
<p>定义三个int型变量并赋值，使用三元运算符或者if-else活的这三个数中较大数的实现</p>
<div><pre><code><span>int</span> num1 <span>=</span> <span>10</span><span>;</span>
<span>int</span> num2 <span>=</span> <span>21</span><span>;</span>
<span>int</span> num3 <span>=</span> <span>-</span><span>21</span><span>;</span>
<span>int</span> max<span>;</span>
<span>if</span><span>(</span>num1 <span>>=</span> num2 <span>&amp;&amp;</span> num1 <span>>=</span> num3<span>)</span><span>{</span>
max <span>=</span> num1<span>;</span>
<span>}</span><span>else</span> <span>if</span><span>(</span>num2 <span>>=</span> num1 <span>&amp;&amp;</span> num2 <span>>=</span> num3<span>)</span><span>{</span>
max <span>=</span> num2<span>;</span>
<span>}</span><span>else</span><span>{</span>
max <span>=</span> num3<span>;</span>
<span>}</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"三个数的最大值为："</span> <span>+</span> max<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div></li>
<li>
<p>编写程序，声明2个double型变量并赋值，判断第一个数大于10.0，且第2个数小于20.0，打印两数之和。否则，打印两数的乘积</p>
<div><pre><code><span>double</span> d1 <span>=</span> <span>12.3</span><span>;</span>
<span>double</span> d2 <span>=</span> <span>32.1</span><span>;</span>
<span>if</span><span>(</span><span>(</span>x <span>></span> <span>10.0</span><span>)</span> <span>&amp;&amp;</span> <span>(</span>y<span>&lt;</span><span>20.0</span><span>)</span><span>)</span><span>{</span>
  <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"两数之和："</span> <span>+</span> <span>(</span>x<span>+</span>y<span>)</span><span>)</span><span>;</span>
<span>}</span><span>else</span><span>{</span>
  <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"两数乘积："</span> <span>+</span> <span>(</span>x<span>*</span>y<span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
<li>
<p>交换两个变量值得代码的实现</p>
<div><pre><code><span>String</span> s1 <span>=</span> <span>"北京"</span><span>;</span>
<span>String</span> s2 <span>=</span> <span>"南京"</span><span>;</span>

<span>String</span> temp <span>=</span> s1<span>;</span>
s1 <span>=</span> s2<span>;</span>
s2 <span>=</span> temp
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
</ol>
<h1 id="程序流程控制"> 程序流程控制</h1>
<ul>
<li>流程控制语句是用来控制程序中各语句执行顺序的语句，可以把语句组合成能完成一定功能的小逻辑模块</li>
<li>其流程控制方式采用结构化程序设计中规定的三种基本流程结构
<ul>
<li>顺序结构
<ul>
<li>程序从上到下逐行的执行，中间没有任何判断和跳转</li>
</ul>
</li>
<li>分支结构
<ul>
<li>根据条件，选择性的执行某段代码</li>
<li>有if...else和switch-case两种分支语句</li>
</ul>
</li>
<li>循环结构
<ul>
<li>根据循环条件，重复性的执行某段代码</li>
<li>有while、do...while、for三种循环语句</li>
<li>注：JDK1.5提供了foreach循环，方便的便利集合、数组元素</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="if-else结构-分支语句1"> if-else结构 - 分支语句1</h2>
<ul>
<li>if语句三种格式
<ul>
<li>
<p>条件执行</p>
<div><pre><code><span>if</span><span>(</span>条件表想达式<span>)</span><span>{</span>
    执行代码块<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p>二选一</p>
<div><pre><code><span>if</span><span>(</span>条件表达式<span>)</span><span>{</span>
    执行代码块<span>1</span><span>;</span>
<span>}</span><span>else</span><span>{</span>
    执行代码块<span>2</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p>n选一</p>
<div><pre><code><span>if</span><span>(</span>条件表达式<span>1</span><span>)</span><span>{</span>
    执行代码块<span>1</span><span>;</span>
<span>}</span><span>else</span> <span>if</span><span>(</span>条件表达式<span>2</span><span>)</span><span>{</span>
    执行代码块<span>2</span><span>;</span>
<span>}</span>
<span>//······</span>
<span>else</span><span>{</span>
    执行代码块n<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></li>
</ul>
</li>
</ul>
<div><pre><code><span>// example1</span>
<span>int</span> hearBeats <span>=</span><span>79</span><span>;</span>
<span>if</span><span>(</span>hearBeats <span>&lt;</span> <span>60</span> <span>||</span> hearBeats <span>></span> <span>100</span><span>)</span><span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"需要做进一步检查"</span><span>)</span><span>;</span>
<span>}</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"检查结束"</span><span>)</span><span>;</span>

<span>// example2</span>
<span>int</span> age <span>=</span> <span>23</span><span>;</span>
<span>if</span><span>(</span>age <span>&lt;</span> <span>18</span><span>)</span><span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"未成年"</span><span>)</span><span>;</span>
<span>}</span><span>else</span><span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"已成年"</span><span>)</span><span>;</span>
<span>}</span>

<span>// example3</span>
<span>if</span><span>(</span>age <span>&lt;</span> <span>0</span><span>)</span><span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"输入数据错误"</span><span>)</span><span>;</span>
<span>}</span><span>else</span> <span>if</span><span>(</span>age <span>&lt;</span> <span>18</span><span>)</span><span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"青少年时期"</span><span>)</span><span>;</span>
<span>}</span><span>else</span> <span>if</span><span>(</span>age <span>&lt;</span> <span>35</span><span>)</span><span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"青壮年时期"</span><span>)</span><span>;</span>
<span>}</span><span>else</span> <span>if</span><span>(</span>age <span>&lt;</span> <span>60</span><span>)</span><span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"中年时期"</span><span>)</span><span>;</span>
<span>}</span><span>else</span> <span>if</span><span>(</span>age<span>&lt;</span><span>120</span><span>)</span><span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"老年时期"</span><span>)</span><span>;</span>
<span>}</span><span>else</span><span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"成仙咯！"</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h2 id="scanner-输入"> Scanner 输入</h2>
<ul>
<li>
<p>为了更好的为后面铺垫，这里从开始使用输入开始记</p>
</li>
<li>
<p>如何从键盘获取不同类型的变量：需要使用Scanner类</p>
</li>
<li>
<p>实现步骤</p>
<ol>
<li>导包：import java.util.Scanner;</li>
<li>Scanner的实例化：Scanner scan = new Scanner(System.in);</li>
<li>调用Scanner类的相关方法（next()/nextXxx()），来获取指定类型的变量</li>
</ol>
<ul>
<li>注意：需要根据相应的方法，来输入指定类型的值。如果输入的数据类型与要求的类型不匹配时，会报出异常：InputMisMatchException导致程序终止</li>
</ul>
</li>
</ul>
<div><pre><code><span>//1.导包</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Scanner</span><span>;</span>
<span>class</span> <span>ScannerTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>//2.Scanner的实例化</span>
        <span>Scanner</span> scan <span>=</span> <span>new</span> <span>Scanner</span><span>(</span><span>System</span><span>.</span>in<span>)</span><span>;</span>
        <span>//3. 调用Scanner类的相关方法</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"请输入姓名："</span><span>)</span><span>;</span>
        <span>String</span> name <span>=</span> scan<span>.</span><span>next</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>name<span>)</span><span>;</span>

        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"请输入年龄："</span><span>)</span><span>;</span>
        <span>int</span> age <span>=</span> scan<span>.</span><span>nextInt</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>age<span>)</span><span>;</span>

        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"请输入体重："</span><span>)</span><span>;</span>
        <span>double</span> weight <span>=</span> scan<span>.</span><span>nextDouble</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>weight<span>)</span><span>;</span>

        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"是否单身？（true/false）"</span><span>)</span><span>;</span>
        <span>boolean</span> islonely <span>=</span> scan<span>.</span><span>nextBoolean</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>islonely<span>)</span><span>;</span>

        <span>// 对于char型的获取，Scanner没有提供相关的方法，只能获取一个字符串</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"请输入你的性别：（男/女）"</span><span>)</span><span>;</span>
        <span>String</span> gender <span>=</span> scan<span>.</span><span>next</span><span>(</span><span>)</span><span>;</span>
        <span>char</span> genderChar <span>=</span> gender<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span><span>;</span><span>//获取索引为0位置上的字符</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>genderChar<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><h3 id="获取char单个字符"> 获取char单个字符</h3>
<ul>
<li>对于char型的获取，Scanner没有提供相关的方法，只能获取一个字符串</li>
<li>但你可以通过<code>string.charAt(pos)</code>来获取pos位置的字符</li>
</ul>
<div><pre><code><span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"请输入你的性别：（男/女）"</span><span>)</span><span>;</span>
<span>String</span> gender <span>=</span> scan<span>.</span><span>next</span><span>(</span><span>)</span><span>;</span>
<span>char</span> genderChar <span>=</span> gender<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span><span>;</span><span>//获取索引为0位置上的字符</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>genderChar<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="小练习"> 小练习</h2>
<h3 id="题目1"> 题目1</h3>
<div><pre><code>小米参加java考试，他和父亲大米达成承诺：
如果：成绩为100分，奖励一台BMW
成绩为(80, 99]时，奖励一台iphone xs max
成绩为[60, 80]时，奖励一个ipad
其他时，什么奖励也没有
请从键盘输入小米的期末成绩，并加以判断
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>
<li>
<p>分析说明</p>
<ol>
<li>else结构是可选的</li>
<li>正对于条件表达式：</li>
</ol>
<ul>
<li>如果多个条件表达式之间是&quot;互斥&quot;关系（或没有交集的关系），那个判断和执行语句声明在上面还是下面，无所谓</li>
<li>如果多个条件表达式之间有交集的关系，需要根据实际情况，<strong>考虑清楚应该将哪个结构声明在上面</strong></li>
<li>如果多个条件表达式之间有包含的关系，通常情况下，需要将范围小的声明在范围大的范围上面。否则，范围小的将不会被执行</li>
</ul>
</li>
</ul>
<div><pre><code><span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Scanner</span><span>;</span>
<span>class</span> <span>IfTest1</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Scanner</span> scan <span>=</span> <span>new</span> <span>Scanner</span><span>(</span><span>System</span><span>.</span>in<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"请输入小米的期末成绩：(0-100)"</span><span>)</span><span>;</span>
        <span>int</span> score <span>=</span> scan<span>.</span><span>nextInt</span><span>(</span><span>)</span><span>;</span>
        <span>// 在这里你也可以将&amp;&amp;后面的条件去掉，也是一样的作业</span>
        <span>if</span><span>(</span>score <span>==</span> <span>100</span><span>)</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"奖励一辆BMW"</span><span>)</span><span>;</span>
        <span>}</span><span>else</span> <span>if</span><span>(</span>score <span>></span> <span>80</span> <span>&amp;&amp;</span> score <span>&lt;=</span> <span>99</span><span>)</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"奖励一台iphone xs max"</span><span>)</span><span>;</span>
        <span>}</span><span>else</span> <span>if</span><span>(</span>score <span>>=</span> <span>60</span> <span>&amp;&amp;</span> score <span>&lt;=</span> <span>80</span><span>)</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"奖励一个ipad"</span><span>)</span><span>;</span>
        <span>}</span><span>else</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"什么奖励也没有"</span><span>)</span><span>;</span>
        <span>}</span>

    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h3 id="题目2"> 题目2</h3>
<div><pre><code>编写程序：由键盘输入三个整数分别存入变量num1、num2、num3，对他们进行排序（使用 if-else if-else），并且从小到大输出
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>说明
<ol>
<li>if-else结构是可以相互嵌套的</li>
<li>如果if-else结构中的执行语句只有一行时，对于的一对{}可以省略。但不建议省略，因为容易出现观察的错误</li>
</ol>
</li>
</ul>
<div><pre><code><span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Scanner</span><span>;</span>
<span>class</span> <span>IfTest2</span><span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Scanner</span> scanner <span>=</span> <span>new</span> <span>Scanner</span><span>(</span><span>System</span><span>.</span>in<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"请输入第一个整数"</span><span>)</span><span>;</span>
        <span>int</span> num1 <span>=</span> scanner<span>.</span><span>nextInt</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"请输入第二个整数"</span><span>)</span><span>;</span>
        <span>int</span> num2 <span>=</span> scanner<span>.</span><span>nextInt</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"请输入第三个整数"</span><span>)</span><span>;</span>
        <span>int</span> num3 <span>=</span> scanner<span>.</span><span>nextInt</span><span>(</span><span>)</span><span>;</span>

        <span>if</span><span>(</span>num1 <span>>=</span> num2<span>)</span><span>{</span>
            <span>if</span><span>(</span>num3 <span>>=</span> num1<span>)</span><span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>num2 <span>+</span> <span>","</span> <span>+</span> num1 <span>+</span> <span>","</span> <span>+</span> num3<span>)</span><span>;</span>
            <span>}</span><span>else</span> <span>if</span><span>(</span>num3 <span>&lt;=</span> num2<span>)</span><span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>num3 <span>+</span> <span>","</span> <span>+</span> num2 <span>+</span> <span>","</span> <span>+</span> num1<span>)</span><span>;</span>
            <span>}</span><span>else</span><span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>num2 <span>+</span> <span>","</span> <span>+</span> num3 <span>+</span> <span>","</span> <span>+</span> num1<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span><span>else</span><span>{</span>
            <span>if</span><span>(</span>num3 <span>>=</span> num2<span>)</span><span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>num1 <span>+</span> <span>","</span> <span>+</span> num2 <span>+</span> <span>","</span> <span>+</span> num3<span>)</span><span>;</span>
            <span>}</span><span>else</span> <span>if</span><span>(</span>num3 <span>&lt;=</span> num1<span>)</span><span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>num3 <span>+</span> <span>","</span> <span>+</span> num1 <span>+</span> <span>","</span> <span>+</span> num2<span>)</span><span>;</span>
            <span>}</span><span>else</span><span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>num1 <span>+</span> <span>","</span> <span>+</span> num3 <span>+</span> <span>","</span> <span>+</span> num2<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><h3 id="if语句练习1"> if语句练习1</h3>
<div><pre><code><span>//下列代码，若有输出，指出输出结果</span>
<span>int</span> x <span>=</span> <span>4</span><span>;</span>
<span>int</span> y <span>=</span> <span>1</span><span>;</span>
<span>if</span> <span>(</span>x<span>></span><span>2</span><span>)</span><span>{</span>
    <span>if</span> <span>(</span> y<span>></span><span>2</span><span>)</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>x <span>+</span> y<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"atguigu"</span><span>)</span><span>;</span>
<span>}</span><span>else</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"x is "</span> <span>+</span> x<span>)</span><span>;</span>
<span>// 这里是输出atguigu，因为进入了第一个if，如何里面的if不符合不执行就继续执行下面的语句，下面的else是对应第一个if的</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code><span>//上面的变形</span>
<span>int</span> x <span>=</span> <span>4</span><span>;</span>
<span>int</span> y <span>=</span> <span>1</span><span>;</span>
<span>if</span> <span>(</span>x<span>></span><span>2</span><span>)</span>
    <span>if</span> <span>(</span> y<span>></span><span>2</span><span>)</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>x <span>+</span> y<span>)</span><span>;</span>
<span>// System.out.println("atguigu");</span>
<span>else</span> <span>// 就近原则，默认匹配上门的if</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"x is "</span> <span>+</span> x<span>)</span><span>;</span>
<span>// x is 4</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="if练习语句2"> if练习语句2</h3>
<p>狗狗年龄计算器，狗前两年的寿命相当于人一年，狗10.5岁，之后每一年就是增加4岁，那5岁的狗就是10.5+10.5+4+4+4=33岁，请写出狗狗计算器</p>
<h3 id="if练习语句3"> if练习语句3</h3>
<ul>
<li>
<p>这里主要是要学会获取一个随机数，具体使用函数<code>Math.random()</code></p>
<ul>
<li><code>Math.random()</code>获取的是<code>0.0-1.0</code>的double型数字，即[0.0, 1.0]</li>
</ul>
</li>
<li>
<p>获取a-b之间随机值的公式：</p>
<div><pre><code><span>(</span><span>int</span><span>)</span><span>(</span><span>Math</span><span>.</span><span>random</span><span>(</span><span>)</span> <span>*</span> <span>(</span>b <span>-</span> a <span>+</span> <span>1</span><span>)</span> <span>+</span> a<span>)</span>
</code></pre>
<div><span>1</span><br></div></div></li>
</ul>
<h3 id="if练习语句4"> if练习语句4</h3>
<ul>
<li>给出三个条件，高180cm以上，富一千万以上，帅true
<ul>
<li>满足三个条件则：<code>一定要嫁给他</code></li>
<li>三个条件中有真的情况则：<code>嫁吧，比上不足，比下有余</code></li>
<li>如果三个条件都不满足则：<code>不嫁</code></li>
</ul>
</li>
<li>这里第三个条件，输入字符串的值判断语句
<ul>
<li><code>String.equals(&quot;判断的字符串&quot;);</code></li>
</ul>
</li>
</ul>
<div><pre><code><span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Scanner</span><span>;</span>
<span>class</span> <span>IfExer2</span><span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Scanner</span> scan <span>=</span> <span>new</span> <span>Scanner</span><span>(</span><span>System</span><span>.</span>in<span>)</span><span>;</span>

        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"请输入升高：(cm)"</span><span>)</span><span>;</span>
        <span>int</span> height <span>=</span> scan<span>.</span><span>nextInt</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"请输入你的财富：(千万)"</span><span>)</span><span>;</span>
        <span>double</span> wealth <span>=</span> scan<span>.</span><span>nextDouble</span><span>(</span><span>)</span><span>;</span>
        <span>/*方式一，判断布尔值
        System.out.println("请输入是否帅：(true/false)");
        boolean isHandsome = scan.nextBoolean();

        if(height>=180 &amp;&amp; wealth >= 1 &amp;&amp; isHandsome){
            System.out.println("一定要嫁给他");
        }else if(height>=180 || wealth >= 1 || isHandsome){
            System.out.println("嫁吧，比上不足，比下有余");
        }else{
            System.out.println("不嫁");
        }
        */</span>
        <span>// 方式二，判断字符串</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"请输入是否帅:（是/否）"</span><span>)</span><span>;</span>
        <span>String</span> isHandsome <span>=</span> scan<span>.</span><span>next</span><span>(</span><span>)</span><span>;</span>

        <span>if</span><span>(</span>height<span>>=</span><span>180</span> <span>&amp;&amp;</span> wealth <span>>=</span> <span>1</span> <span>&amp;&amp;</span> isHandsome<span>.</span><span>equals</span><span>(</span><span>"是"</span><span>)</span><span>)</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"一定要嫁给他"</span><span>)</span><span>;</span>
        <span>}</span><span>else</span> <span>if</span><span>(</span>height<span>>=</span><span>180</span> <span>||</span> wealth <span>>=</span> <span>1</span> <span>||</span> isHandsome<span>.</span><span>equals</span><span>(</span><span>"是"</span><span>)</span><span>)</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"嫁吧，比上不足，比下有余"</span><span>)</span><span>;</span>
        <span>}</span><span>else</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"不嫁"</span><span>)</span><span>;</span>
        <span>}</span>


    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><h2 id="switch-case结构-分支语句2"> switch-case结构 - 分支语句2</h2>
<h3 id="格式"> 格式</h3>
<div><pre><code><span>Switch</span><span>(</span>表达式<span>)</span><span>{</span>
    <span>case</span> 常量<span>1</span><span>:</span>
        语句<span>1</span><span>;</span>
        <span>//break;//可选的</span>
    <span>case</span> 常量<span>2</span><span>:</span>
    	语句<span>2</span><span>;</span>
    	<span>//break;</span>
    ···
    <span>default</span><span>:</span>
    	语句n<span>;</span>
    	<span>//break;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="说明"> 说明</h3>
<ol>
<li>
<p>根据 switch 表达式中的值，依次匹配各个case中的常量，一旦匹配成功，则进入相应case结构中，调用其执行语句。当调用完执行语句后，则仍然继续向下执行其他case结构中的执行语句，直到遇到break关键字或switch-case结构末尾为止结束</p>
</li>
<li>
<p>break, 可以使用在switch-case结构中，表示一旦执行到此关键字，就跳出switch-case结构</p>
</li>
<li>
<p>switch 结构中的表达式，只能是如下的6中数据类型之一</p>
<ul>
<li>byte, short, char, int, 枚举类型(JDK5.0新增), String类型(JDK7.0新增)</li>
</ul>
</li>
<li>
<p>case 之后只能声明常量，不能声明一个范围</p>
</li>
<li>
<p>break 关键字是可选的</p>
</li>
<li>
<p>default: 相当于if-else中的else</p>
<ul>
<li>default关键字是可选的，而且位置是灵活的，你可以放在任何地方，开头或者中间，如果在开头，case都没匹配上他都会按序执行，从default到case n，但默认放末尾</li>
</ul>
</li>
</ol>
<ul>
<li>凡是可以使用switch-case的结构，都可以转换为if-else，反之，不成立</li>
<li>再写分支结构时，当发现既可以使用switch-case（同时switch中表达式的取值不太多），又可以使用if-else时，优先选择switch-case，因为switch-case执行效率稍高</li>
<li>如果switch-case结构中的多个case的执行语句相同，则可以考虑进行合并</li>
</ul>
<h3 id="例题2"> 例题2</h3>
<ul>
<li>对学生成绩大于60分的，输出&quot;合格&quot;，低于60分的，输出&quot;不合格&quot;
<ul>
<li>
<p>说明：如果switch-case结构中的多个case的执行语句相同，则可以考虑进行合并</p>
<div><pre><code><span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"请输入学生的成绩"</span><span>)</span><span>;</span>
<span>Scanner</span> scan <span>=</span> <span>new</span> <span>Scanner</span><span>(</span><span>System</span><span>.</span>in<span>)</span><span>;</span>
<span>int</span> score <span>=</span> scan<span>.</span><span>nextInt</span><span>(</span><span>)</span><span>;</span>
<span>int</span> scoreout<span>;</span>
<span>//更优的解法</span>
scoreout <span>=</span> score <span>/</span> <span>60</span><span>;</span>
<span>switch</span><span>(</span>scoreout<span>)</span><span>{</span>
    <span>case</span> <span>0</span><span>:</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"不合格"</span><span>)</span><span>;</span>
        <span>break</span><span>;</span>
    <span>case</span> <span>1</span><span>:</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"合格"</span><span>)</span><span>;</span>
        <span>break</span><span>;</span>
<span>}</span>
scoreout <span>=</span> score <span>/</span> <span>10</span><span>;</span>
<span>//次优的解法</span>
<span>switch</span><span>(</span>scoreout<span>)</span><span>{</span>
    <span>case</span> <span>0</span><span>:</span>
    <span>case</span> <span>1</span><span>:</span>
    <span>case</span> <span>2</span><span>:</span>
    <span>case</span> <span>3</span><span>:</span>
    <span>case</span> <span>4</span><span>:</span>
    <span>case</span> <span>5</span><span>:</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"不合格"</span><span>)</span><span>;</span>
        <span>break</span><span>;</span>
    <span>case</span> <span>6</span><span>:</span>
    <span>case</span> <span>7</span><span>:</span>
    <span>case</span> <span>8</span><span>:</span>
    <span>case</span> <span>9</span><span>:</span>
    <span>case</span> <span>10</span><span>:</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"合格"</span><span>)</span><span>;</span>
        <span>break</span><span>;</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div></li>
</ul>
</li>
</ul>
<h3 id="例题4"> 例题4</h3>
<ul>
<li>从键盘上输入2019的&quot;month&quot;和&quot;day&quot;，要求通过程序输出输入的日期为2019的第几天</li>
<li>说明：break在switch-case是可选的</li>
</ul>
<div><pre><code><span>Scanner</span> scan <span>=</span> <span>new</span> <span>Scanner</span><span>(</span><span>System</span><span>.</span>in<span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"请输入2019的month："</span><span>)</span><span>;</span>
<span>int</span> month <span>=</span> scan<span>.</span><span>nextInt</span><span>(</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"请输入2019的day："</span><span>)</span><span>;</span>
<span>int</span> day <span>=</span> scan<span>.</span><span>nextInt</span><span>(</span><span>)</span><span>;</span>

<span>// 定义一个变量来保存总天数</span>
<span>int</span> sumDays <span>=</span> <span>0</span><span>;</span>
<span>// 如果使用if-else来写，就会重复12此，很冗余（多余）</span>
<span>switch</span> <span>(</span>month<span>)</span><span>{</span>
    <span>case</span> <span>12</span><span>:</span>
        sumDays <span>+=</span> <span>30</span><span>;</span>
    <span>case</span> <span>11</span><span>:</span>
        sumDays <span>+=</span> <span>31</span><span>;</span>
    <span>case</span> <span>10</span><span>:</span>
        sumDays <span>+=</span> <span>30</span><span>;</span>
    <span>case</span> <span>9</span><span>:</span>
        sumDays <span>+=</span> <span>31</span><span>;</span>
    <span>case</span> <span>8</span><span>:</span>
        sumDays <span>+=</span> <span>31</span><span>;</span>
    <span>case</span> <span>7</span><span>:</span>
        sumDays <span>+=</span> <span>30</span><span>;</span>
    <span>case</span> <span>6</span><span>:</span>
        sumDays <span>+=</span> <span>31</span><span>;</span>
    <span>case</span> <span>5</span><span>:</span>
        sumDays <span>+=</span> <span>30</span><span>;</span>
    <span>case</span> <span>4</span><span>:</span>
        sumDays <span>+=</span> <span>31</span><span>;</span>
    <span>case</span> <span>3</span><span>:</span>
        sumDays <span>+=</span> <span>28</span><span>;</span>
    <span>case</span> <span>2</span><span>:</span>
        sumDays <span>+=</span> <span>31</span><span>;</span>
    <span>case</span> <span>1</span><span>:</span>
        sumDays <span>+=</span> day<span>;</span>
<span>}</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"2019年"</span> <span>+</span> month <span>+</span> <span>"月"</span> <span>+</span> day <span>+</span> <span>"日是当前年的第"</span> <span>+</span> sumDays <span>+</span> <span>"天"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><h3 id="例题5"> 例题5</h3>
<ul>
<li>
<p>从键盘分别输入年、月、日，判断这一天是当年的第几天</p>
<ul>
<li>
<p>这里核心在于闰年的标准</p>
<div><pre><code>1. 可以被4整除，且不可被100整除
或
2， 可以被400整除
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
</ul>
</li>
</ul>
<div><pre><code><span>case</span> <span>3</span><span>:</span>
<span>// 判断year是否是闰年</span>
<span>// 可以被4整除，且不可被100整除或可以被400整除</span>
<span>if</span><span>(</span><span>(</span>year <span>%</span> <span>4</span><span>==</span><span>0</span> <span>&amp;&amp;</span> year <span>%</span> <span>100</span> <span>!=</span><span>0</span><span>)</span> <span>||</span> year <span>%</span> <span>400</span> <span>==</span> <span>0</span><span>)</span><span>{</span>
    sumDays <span>+=</span> <span>29</span><span>;</span>
<span>}</span><span>else</span><span>{</span>
    sumDays <span>+=</span><span>28</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h1 id="循环结构"> 循环结构</h1>
<ul>
<li>
<p>循环结构</p>
<ul>
<li>在某些条件满足的情况下，反复执行特定代码的功能</li>
</ul>
</li>
<li>
<p>循环语句分类</p>
<ul>
<li>for 循环</li>
<li>while 循环</li>
<li>do-while 循环</li>
</ul>
</li>
<li>
<p>循环语句的四个组成部分</p>
<ul>
<li>初始化部分(init_statement)</li>
<li>想你换条件部分(test_exp)</li>
<li>循环体部分(body_statement)</li>
<li>迭代部分(alter_statement)</li>
</ul>
</li>
</ul>
<h2 id="for循环"> for循环</h2>
<h3 id="for循环结构的使用"> for循环结构的使用</h3>
<ul>
<li>循环结构的四个要素</li>
</ul>
<ol>
<li>初始化条件</li>
<li>循环条件
<ul>
<li>循环条件是boolean类型</li>
</ul>
</li>
<li>循环体</li>
<li>迭代条件</li>
</ol>
<h3 id="for循环的结构"> for循环的结构</h3>
<ul>
<li>其中的1234放入上述的四个要素</li>
</ul>
<div><pre><code><span>for</span><span>(</span><span>1</span><span>;</span><span>2</span><span>;</span><span>4</span><span>)</span><span>{</span>
    <span>3</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>
<p>执行过程：1 - 2 - 3 - 4 - 2 - 3 ··· - 2</p>
</li>
<li>
<p>在for循环内定义的变量，只在for循环内有效，除了for循环就失效了</p>
</li>
</ul>
<h3 id="练习-4"> 练习</h3>
<div><pre><code><span>//练习:</span>
<span>int</span> num <span>=</span> <span>1</span><span>;</span>
<span>for</span><span>(</span><span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>'a'</span><span>)</span><span>;</span>num <span>&lt;=</span> <span>3</span><span>;</span> <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>'c'</span><span>)</span><span>,</span>num<span>++</span><span>)</span><span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>'b'</span><span>)</span><span>;</span>
<span>}</span>
<span>//输出结果：abcbcbc</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code><span>//例题：遍历100以内的偶数, 输出所有偶数的和，输出偶数的个数</span>
<span>int</span> sum <span>=</span> <span>0</span><span>;</span><span>// 记录所有偶数的和</span>
<span>int</span> count <span>=</span> <span>0</span><span>;</span><span>// 记录偶数的个数</span>
<span>for</span><span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span>i <span>&lt;=</span> <span>100</span><span>;</span> i<span>++</span><span>)</span><span>{</span>
    <span>if</span><span>(</span>i <span>%</span> <span>2</span> <span>==</span> <span>0</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>i <span>+</span> <span>" "</span><span>)</span><span>;</span>
        sum <span>+=</span> i<span>;</span>
        count<span>++</span><span>;</span>
    <span>}</span>
<span>}</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"总和为："</span> <span>+</span> sum<span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"个数为："</span> <span>+</span> count<span>)</span><span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id="考察-3"> 考察</h2>
<p>day5</p>
<ol>
<li>
<p>switch后面使用的表达式可以是那些数据结构</p>
<ul>
<li><code>byte short char int 枚举类型 String类型</code></li>
</ul>
</li>
<li>
<p>使用switch语句改下列if语句</p>
<div><pre><code><span>int</span> a <span>=</span> <span>3</span><span>;</span>
<span>int</span> x <span>=</span> <span>100</span><span>;</span>
<span>if</span><span>(</span>a<span>==</span><span>1</span><span>)</span>
    x<span>+=</span><span>5</span><span>;</span>
<span>else</span> <span>if</span><span>(</span>a<span>==</span><span>2</span><span>)</span>
    x<span>+=</span><span>10</span><span>;</span>
<span>else</span> <span>if</span><span>(</span>a<span>==</span><span>3</span><span>)</span>
    x<span>+=</span><span>16</span><span>;</span>
<span>else</span>
    x<span>+=</span><span>34</span>；

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>int</span> a <span>=</span> <span>3</span><span>;</span>
<span>int</span> x <span>=</span> <span>100</span><span>;</span>
<span>switch</span><span>(</span>a<span>)</span><span>{</span>
    <span>case</span> <span>1</span><span>:</span>
        x<span>+=</span><span>5</span><span>;</span>
        <span>break</span><span>;</span>
    <span>case</span> <span>2</span><span>:</span>
        x<span>+=</span><span>10</span><span>;</span>
        <span>break</span><span>;</span>
    <span>case</span> <span>3</span><span>:</span>
        x<span>+=</span><span>16</span><span>;</span>
        <span>break</span><span>;</span>
    <span>default</span><span>:</span>
        x<span>+=</span><span>34</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div></li>
<li>
<p>谈谈你对三元运算符、if-else和switch-case结构使用场景的理解</p>
<ul>
<li>三元与switch-case都可以写成if-else，反之不一定成立</li>
<li>通常使用分支选择结构都是使用if-else，但如果满足特定比如判断条件简单，或者二选一的情况那就可以选择switch-case或三元运算符</li>
</ul>
</li>
<li>
<p>如何从控制台获取 String和int型的变量，并输出？使用代码实现</p>
<div><pre><code><span>// 导包</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Scanner</span><span>;</span>
<span>// 实例化；变量类型 变量名 = 变量值</span>
<span>Scanner</span> scan <span>=</span> <span>new</span> <span>scan</span><span>(</span><span>System</span><span>.</span>in<span>)</span><span>;</span>
<span>// 获取</span>
<span>String</span> info <span>=</span> scan<span>.</span><span>next</span><span>(</span><span>)</span><span>;</span>
<span>// char是没有的，需要额外用其他方法实现</span>
<span>char</span> info_char <span>=</span> info<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span><span>;</span><span>//获取索引为0位置上的字符</span>
<span>int</span> id <span>=</span> scan<span>.</span><span>nextIn</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></li>
<li>
<p>使用for循环遍历100以内的奇数，并计算所有的奇数的和并输出。</p>
<div><pre><code><span>int</span> sum <span>=</span> <span>0</span>
<span>for</span><span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span>i <span>&lt;=</span> <span>100</span><span>;</span> i<span>++</span><span>)</span><span>{</span>
    <span>if</span><span>(</span>i <span>%</span> <span>2</span> <span>!=</span> <span>0</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i<span>)</span><span>;</span>
        sum <span>+=</span> i<span>;</span>
    <span>}</span>
<span>}</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"奇数的和："</span> <span>+</span> sum<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></li>
</ol>
<h2 id="循环的四要素"> 循环的四要素</h2>
<ol>
<li>
<p>初始化条件</p>
</li>
<li>
<p><strong>循环条件</strong></p>
<ul>
<li><strong>循环条件是boolean类型</strong></li>
</ul>
</li>
<li>
<p>循环体</p>
</li>
<li>
<p>迭代条件</p>
</li>
</ol>
<h2 id="while-循环"> while 循环</h2>
<h3 id="while循环的使用"> while循环的使用</h3>
<ul>
<li>循环结构的四个要素
<ol>
<li>初始化条件</li>
<li>循环条件
<ul>
<li>循环条件是boolean类型</li>
</ul>
</li>
<li>循环体</li>
<li>迭代条件</li>
</ol>
</li>
</ul>
<h3 id="while循环的结构"> while循环的结构</h3>
<div><pre><code><span>1</span>
<span>while</span><span>(</span><span>2</span><span>)</span><span>{</span>
<span>3</span><span>;</span>
<span>4</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li>执行过程： 1 - 2 - 3 - 4 - 2 - 3 - 4 - ··· - 2</li>
</ul>
<h3 id="说明-2"> 说明</h3>
<ol>
<li>写while循环千万不要丢了迭代条件。一旦丢了，就可能导致死循环</li>
<li>写程序要避免出现死循环(算法具有有限性)</li>
<li><strong>for循环和while循环可以相互转换的</strong>
<ul>
<li>区别：for循环和while循环的初始化条件部分的作用范围不同</li>
</ul>
</li>
</ol>
<h2 id="do-while-循环"> do-while 循环</h2>
<h3 id="do-while的使用"> do-while的使用</h3>
<ul>
<li>循环结构的四个要素
<ol>
<li>初始化条件</li>
<li>循环条件
<ul>
<li>循环条件是boolean类型</li>
</ul>
</li>
<li>循环体</li>
<li>迭代条件</li>
</ol>
</li>
</ul>
<h3 id="do-while循环结构"> do-while循环结构：</h3>
<div><pre><code><span>1</span>
<span>do</span><span>{</span>
  <span>3</span><span>;</span>
  <span>4</span><span>;</span>
<span>}</span><span>while</span><span>(</span><span>2</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li>执行过程：1 - 3 - 4 - 2 - 3 - 4 - ··· - 2</li>
</ul>
<h3 id="说明-3"> 说明</h3>
<ol>
<li>do-while循环至少会执行一次循环体</li>
<li>开发中，使用for和while更多一些，较少使用do-while</li>
</ol>
<h2 id="练习-5"> 练习</h2>
<ul>
<li>从键盘读入个数不确定的整数，并判断读入的正数和负数的个数，输入为0时结束程序</li>
</ul>
<div><pre><code>说明：
<span>1.</span> 不在循环条件部分限制次数的结构：<span>for</span><span>(</span><span>;</span><span>;</span><span>)</span>或<span>while</span><span>(</span><span>true</span><span>)</span>
<span>2.</span> 结束循环的几种方式
  <span>1.</span> 循环条件部分返回<span>false</span>
  <span>2.</span> 循环体中，执行<span>break</span>
 <span>*</span><span>/</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Scanner</span><span>;</span>
<span>class</span> <span>ForWhileTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Scanner</span> scan <span>=</span> <span>new</span> <span>Scanner</span><span>(</span><span>System</span><span>.</span>in<span>)</span><span>;</span>
        <span>int</span> positiveNumber <span>=</span> <span>0</span><span>;</span><span>//记录正数的个数</span>
        <span>int</span> negativeNumber <span>=</span> <span>0</span><span>;</span><span>//记录负数的个数</span>
        <span>//如果用for循环写，则按下面写即可</span>
        <span>//for(;;)</span>
        <span>while</span><span>(</span><span>true</span><span>)</span><span>{</span>
            <span>int</span> number <span>=</span> scan<span>.</span><span>nextInt</span><span>(</span><span>)</span><span>;</span>

            <span>// 判断number的正负情况</span>
            <span>if</span><span>(</span>number <span>></span> <span>0</span><span>)</span><span>{</span>
                positiveNumber<span>++</span><span>;</span>
            <span>}</span><span>else</span> <span>if</span><span>(</span>number <span>&lt;</span> <span>0</span><span>)</span><span>{</span>
                negativeNumber<span>++</span><span>;</span>
            <span>}</span><span>else</span><span>{</span>
                <span>//一旦执行break，跳出循环</span>
                <span>break</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"输入的正数个数为："</span> <span>+</span> positiveNumber<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"输入的负个数为："</span> <span>+</span> negativeNumber<span>)</span><span>;</span>
        <span>/* 自己写的
        int loop = 1;
        int sum1 = 0;
        int sum2 = 0;
        while(loop != 0){
            System.out.print("请输入整数：");
            loop = scan.nextInt();
            if (loop > 0){
                sum1++;
            }else if (loop &lt; 0){
                sum2++;
            }else{
                System.out.println("输入有误");
            }
        }
        System.out.println("正数：" + sum1);
        System.out.println("负数：" + sum2);
         */</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div><h2 id="嵌套循环"> 嵌套循环</h2>
<ul>
<li>其内容其实就和嵌套分支一样，嵌套循环就是循环里面套循环</li>
<li>建议的嵌套层数是不超过三层，一旦超过三层则建议是否能有更好的解决方法</li>
</ul>
<h3 id="嵌套循环的使用"> 嵌套循环的使用</h3>
<ol>
<li>嵌套循环
<ul>
<li>将一个循环结构A声明在另一个循环结构B的循环体中，就构成了嵌套循环</li>
</ul>
</li>
<li>两种嵌套循环结构
<ul>
<li>外层循环：循环结构B</li>
<li>内层循环：循环结构A</li>
</ul>
</li>
<li>说明
<ul>
<li>内层循环结构遍历一遍，只相当于外层循环体执行了一次</li>
<li>假设外层循环需要执行m此，内层循环需要执行n此，此时内层循环一共执行了m*n次</li>
</ul>
</li>
<li>技巧
<ul>
<li>外层循环控制行数，内层循环控制列数</li>
</ul>
</li>
</ol>
<h2 id="关于质数的算法优化"> 关于质数的算法优化</h2>
<ul>
<li>
<p>100以内的所有质数的输出</p>
</li>
<li>
<p>质数：素数，只能被1和他本身整除的自然数。
从2开始，到这个数-1结束为止，都不能被这个数本身整除</p>
</li>
<li>
<p>算法是编程的内功核心，一个好的算法可以事半功倍，最大效益化的压榨机器的性能</p>
</li>
<li>
<p>普通的写法，没有任何的优化</p>
<div><pre><code><span>class</span> <span>PrimeNumberTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>boolean</span> isFlag <span>=</span> <span>true</span><span>;</span><span>//表示i是否被j除尽，一旦除尽，修改其值</span>
        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>2</span><span>;</span>i <span>&lt;=</span> <span>100</span><span>;</span>i<span>++</span><span>)</span><span>{</span><span>//遍历100以内的自然数</span>
            <span>for</span><span>(</span><span>int</span> j <span>=</span> <span>2</span><span>;</span>j <span>&lt;</span> i<span>;</span>j<span>++</span><span>)</span><span>{</span><span>//j: 被i除</span>
                <span>if</span><span>(</span>i <span>%</span> j <span>==</span> <span>0</span><span>)</span><span>{</span><span>//i被j除尽则置false</span>
                    isFlag <span>=</span> <span>false</span><span>;</span>
                <span>}</span>
            <span>}</span>
            <span>if</span><span>(</span>isFlag <span>==</span> <span>true</span><span>)</span><span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i<span>)</span><span>;</span>
            <span>}</span>
            <span>//重置isFlag</span>
            isFlag <span>=</span> <span>true</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div></li>
<li>
<p>添加了优化</p>
<div><pre><code><span>class</span> <span>PrimeNumberTest1</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>boolean</span> isFlag <span>=</span> <span>true</span><span>;</span><span>//表示i是否被j除尽，一旦除尽，修改其值</span>

        <span>// 获取当前时间的毫秒数</span>
        <span>long</span> start <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> count <span>=</span> <span>0</span><span>;</span><span>//记录质数的个数</span>

        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>2</span><span>;</span>i <span>&lt;=</span> <span>100000</span><span>;</span>i<span>++</span><span>)</span><span>{</span><span>//遍历100以内的自然数</span>
            <span>// Math.sqrt()开方</span>
            <span>// 优化二：对本身是质数的自然数是有效的</span>
            <span>// for(int j = 2;j &lt; i;j++){</span>
            <span>for</span><span>(</span><span>int</span> j <span>=</span> <span>2</span><span>;</span>j <span>&lt;</span> <span>Math</span><span>.</span><span>sqrt</span><span>(</span>i<span>)</span><span>;</span>j<span>++</span><span>)</span><span>{</span><span>//j: 被i除</span>
                <span>if</span><span>(</span>i <span>%</span> j <span>==</span> <span>0</span><span>)</span><span>{</span><span>//i被j除尽则置false</span>
                    isFlag <span>=</span> <span>false</span><span>;</span>
                    <span>break</span><span>;</span><span>//优化一：只对本身非质数的自然数是有效的</span>
                <span>}</span>
            <span>}</span>
            <span>if</span><span>(</span>isFlag <span>==</span> <span>true</span><span>)</span><span>{</span>
                <span>// System.out.println(i);</span>
                count<span>++</span><span>;</span>
            <span>}</span>
            <span>//重置isFlag</span>
            isFlag <span>=</span> <span>true</span><span>;</span>
        <span>}</span>
        <span>// 获取当前时间的毫秒数</span>
        <span>long</span> end <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"质数的个数为："</span> <span>+</span> count<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"所花费的时间为："</span> <span>+</span> <span>(</span>end <span>-</span> start<span>)</span><span>)</span><span>;</span>
        <span>//未优化：17710</span>
        <span>// 优化一：1546</span>
        <span>// 优化二: 13</span>

    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div></li>
</ul>
<h3 id="题外-获取当前的时间毫秒数"> 题外 - 获取当前的时间毫秒数</h3>
<p>与其他语言一样，java也有获取自1970年1月1日UTC以来的机器时间，</p>
<div><pre><code><span>long</span> start <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>start<span>)</span><span>;</span><span>//1634815711071</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="题外-求根号"> 题外 - 求根号</h3>
<div><pre><code><span>Math</span><span>.</span><span>sqrt</span><span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="特殊流程控制语句"> 特殊流程控制语句</h2>
<h3 id="break、continue"> break、continue</h3>
<ul>
<li>
<p>break和continue关键字的使用</p>
</li>
<li>
<p>两者区别</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>使用范围</th>
<th>循环中使用的作用（不同点）</th>
<th>相同点</th>
</tr>
</thead>
<tbody>
<tr>
<td>break</td>
<td>switch-case, 循环结构中</td>
<td>结束当前循环</td>
<td>关键字后面不能声明执行语句</td>
</tr>
<tr>
<td>continue</td>
<td>循环结构中</td>
<td>结束单次循环</td>
<td>关键字后面不能声明执行语句</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>java中可以让循环添加标签，在使用break和continue的时候可以对特定的循环进行操作</p>
<ul>
<li><code>break [lable];</code> 结束指定标签<strong>标识的一层循环</strong></li>
<li><code>continue [lable];</code> 结束指定<strong>标识的一层循环的当此循环</strong></li>
</ul>
</li>
</ul>
<div><pre><code><span>for</span><span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span>i <span>&lt;=</span> <span>10</span><span>;</span>i<span>++</span><span>)</span><span>{</span>
    <span>if</span><span>(</span>i <span>%</span> <span>4</span> <span>==</span> <span>0</span><span>)</span><span>{</span>
        <span>break</span><span>;</span><span>//123</span>
        <span>// continue;//1235678910</span>
        <span>// break和continue的后面不能接执行语句</span>
        <span>// System.out.println("输出");</span>
    <span>}</span>
    <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>i<span>)</span><span>;</span>
<span>}</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"\n"</span><span>)</span><span>;</span>
<span>// -------------------------</span>
<span>//java中可以让循环添加标签</span>
label<span>:</span><span>for</span><span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span>i <span>&lt;=</span> <span>4</span><span>;</span>i<span>++</span><span>)</span><span>{</span>
    <span>for</span><span>(</span><span>int</span> j <span>=</span> <span>1</span><span>;</span>j <span>&lt;=</span> <span>10</span><span>;</span>j<span>++</span><span>)</span><span>{</span>
        <span>if</span><span>(</span>j <span>%</span> <span>4</span> <span>==</span> <span>0</span><span>)</span><span>{</span>
            <span>// break;//默认跳出包括此关键字最近的一层循环</span>
            <span>// continue;</span>

            <span>// break lable;//结束指定标签标识的一层循环</span>
            <span>continue</span> label<span>;</span><span>//结束指定标识的一层循环的当此循环</span>
        <span>}</span>
        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>j<span>)</span><span>;</span>
    <span>}</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h3 id="return"> return</h3>
<ul>
<li><code>return</code>：并非专门用于结束循环的，他的功能是结束一个方法，当一个方法执行到一个return语句时，这个方法将被结束</li>
<li>与break和continue不同的是，return直接结束整个方法，不管这个return处于多少层循环之内</li>
</ul>
<h1 id="考察-4"> 考察</h1>
<ol>
<li>
<p>循环结构是如何最后退出循环的，有哪些不同的情况请说明</p>
<ol>
<li>循环条件返回false</li>
<li>在循环体内，一旦执行到break，跳出循环</li>
</ol>
<ul>
<li>continue是跳过此次循环，所以不算
return是跳过方法的，所以不算专门来结束循环的</li>
</ul>
</li>
<li>
<p>指出如下程序输出的结构</p>
<div><pre><code>label<span>:</span><span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i<span>&lt;=</span> <span>4</span><span>;</span>i<span>++</span><span>)</span><span>{</span>
    <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>1</span><span>;</span>j <span>&lt;=</span> <span>10</span><span>;</span>j<span>++</span><span>)</span><span>{</span>
        <span>if</span> <span>(</span>j <span>%</span> <span>4</span> <span>==</span> <span>0</span><span>)</span><span>{</span>
            <span>continue</span> label<span>;</span>
        <span>}</span>
        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>j<span>)</span><span>;</span>
    <span>}</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ul>
<li>output：123123123123</li>
</ul>
</li>
<li>
<p>一个数如果恰好等于它的因子之和，这个数就称为”完数“。例如 6=1+2+3. 编程找出1000以内的所有完数。（因子：除去这个数本身的其他约数）</p>
<div><pre><code><span>for</span><span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span>i <span>&lt;=</span> <span>1000</span><span>;</span>i<span>++</span><span>)</span><span>{</span>
    <span>int</span> factor <span>=</span> <span>0</span><span>;</span>
    <span>for</span><span>(</span><span>int</span> j <span>=</span> <span>1</span><span>;</span>j <span>&lt;=</span> i<span>/</span><span>2</span><span>;</span>j<span>++</span><span>)</span><span>{</span>
        <span>if</span><span>(</span>i <span>%</span> j <span>==</span> <span>0</span><span>)</span><span>{</span>
            factor <span>+=</span> j<span>;</span>
        <span>}</span>
    <span>}</span>
    <span>if</span><span>(</span>i <span>==</span> factor<span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div></li>
<li>
<p>说明break和continue使用上的相同点和不同点</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>使用范围</th>
<th>循环中使用的作用（不同点）</th>
<th>相同点</th>
</tr>
</thead>
<tbody>
<tr>
<td>break</td>
<td>switch-case, 循环结构中</td>
<td>结束当前循环</td>
<td>关键字后面不能声明执行语句</td>
</tr>
<tr>
<td>continue</td>
<td>循环结构中</td>
<td>结束单次循环</td>
<td>关键字后面不能声明执行语句</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>从控制台输出：</p>
<div><pre><code><span>/*
******
*****
****
***
**
*
*/</span>
<span>for</span><span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> <span>6</span><span>;</span>i<span>++</span><span>)</span><span>{</span>
    <span>for</span><span>(</span><span>int</span> j <span>=</span> <span>1</span><span>;</span> j <span>&lt;=</span> <span>7</span> <span>-</span> i<span>;</span>j<span>++</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>"*"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div></li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>密码学基础理论</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/hungry/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/hungry/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">密码学基础理论</source>
      <category>求知</category>
      <pubDate>Sun, 19 Dec 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="复习涉及知识点"> 复习涉及知识点</h1>
<p>为了不挂科而诞生的这篇笔记，加油！</p>
<h2 id="弃九法"> <strong>弃九法</strong></h2>
<ul>
<li>设式子：<code>A*B=C</code>
<ol>
<li>先将A,B,C分别弃掉9
<ul>
<li>里面两两相加=9则去掉，9或0直接去掉</li>
</ul>
</li>
<li>然后将A,B,C分别(mod9)得到a,b,c</li>
<li>判断<code>(a*b)(mod9)</code> == <code>c</code>，相等则正确</li>
</ol>
</li>
</ul>
<h2 id="完全剩余系"> <strong>完全剩余系</strong></h2>
<ul>
<li><strong>题</strong>：在Z_4中，属于[2]的整数是？</li>
<li><strong>答</strong>：在模4的剩余类中，属于集合[2]的数是：2、6、-30...
- 模4的剩余类：<code>{[0],[1],[2],[3]}</code></li>
<li>定义：从模n中取一个数作为集合，称为模n的一个<strong>完全剩余系</strong>；</li>
<li><code>{0,1,2,···，n-1}</code>称为模n的最小非负完全剩余系</li>
</ul>
<h2 id="互素"> <strong>互素</strong></h2>
<ul>
<li>互质是公约数只有1的两个整数
<ul>
<li>(a,b)=1；a与b的最大公约数为1</li>
</ul>
</li>
</ul>
<h2 id="互质"> <strong>互质</strong></h2>
<ul>
<li>互质_是公约数只有1的两个整数</li>
</ul>
<h2 id="简化剩余系"> <strong>简化剩余系</strong></h2>
<ul>
<li>定义：模m的完全剩余系中与m互素的数组成的集合，称为模m的一个简化剩余系</li>
<li><strong>题</strong>：模12的简化剩余系是？</li>
<li><strong>答</strong>：<code>1,5,7,11</code>
<ul>
<li>其中([1,5,7,11], 12)都=1</li>
</ul>
</li>
</ul>
<h2 id="aes"> AES</h2>
<ul>
<li>
<p><code>{1C}⊕{02}</code>=1E</p>
<ul>
<li>先将两者化为二进制，然后将两者异或，得到的二进制转换为十六进制即可</li>
</ul>
<div><pre><code>0001 1100  //1C
0000 0010  //02
----------------⊕异或
0001 1110  //1E
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
<li>
<p><code>{1C}•{02}</code>=38</p>
<ul>
<li>先将两者转换为二进制，化为<code>x^n+x^n...</code>的情况，再将两者相乘，得到的<code>x^n+x^n...</code>转换为二进制再转换为十六进制即可</li>
</ul>
<div><pre><code>0001 1100 -&gt; x^4+x^3+x^2
0000 0010 -&gt; x^1

(x^4+x^3+x^2)*(x^1)=x^5+x^4+x^3=0011 1000

0011 1000 //38

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
<li>
<p><strong>题</strong>：AES字节代换S盒</p>
</li>
<li></li>
</ul>
<h2 id="逆元"> 逆元</h2>
<ul>
<li><strong>题</strong>：Z_{10}中所有的逆元的元为__1、3、7、9__，对应的逆元为__1、7、3、9__</li>
<li><strong>答</strong>：
<ul>
<li>10逆元的元为10的质数
<ul>
<li>求出10的互质数即可：1、3、7、9</li>
</ul>
</li>
<li>逆元则列出为逆元的元的<code>*x=1(mod10)</code>四个式子：1、7、3、9<div><pre><code>1*x≡1(mod10)
3*x≡1(mod10)
7*x≡1(mod10)
9*x≡1(mod10)
----------
1*1≡1(mod10)
3*7≡21(mod10)≡1(mod10)
7*3≡21(mod10)≡1(mod10)
9*9≡81(mod10)≡1(mod10)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></li>
</ul>
</li>
</ul>
<h2 id="奇偶校验码"> 奇偶校验码</h2>
<ul>
<li>出自选择题，一般看4个选项中的3个选项是奇还是偶校验，则另外一个则为错误的</li>
<li>一般看1的个数，1的个数为偶数则为偶校验，为奇数则为奇校验</li>
</ul>
<h2 id="经典密码"> 经典密码</h2>
<p><img src="./images/密码学基础理论/1.png" alt="img" /></p>
<h3 id="凯撒密码-caesar"> 凯撒密码(Caesar</h3>
<ul>
<li><strong>题</strong>：设密码为e，明文为floewr，则密文为</li>
<li><strong>答</strong>：设密码为a，则将每个明文的字母对应的数字加a对应的数字模26</li>
</ul>
<div><pre><code>e=4
flower
--------
(f+4)(mod26)=(5+4)(mod26)=9(mod26)=9=j
(l+4)(mod26)=(11+4)(mod26)=15(mod26)=15=p
......
--------
jpsaiv
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="仿射密码"> 仿射密码</h3>
<ul>
<li><strong>题</strong>：用仿射密码加密, 明文是chicken, 密钥为(h, n), 密文为</li>
<li><strong>答</strong>：若密钥为(a,b)，则逐个将密文(ax+b)(mod26)</li>
</ul>
<div><pre><code>a=h=7
b=n=13
chicken
--------
(7*c+13)(mod26)=(7*2+13)(mod26)=27(mod26)=1=b
(7*h+13)(mod26)=(7*7+13)(mod26)=62(mod26)=10=k
......
--------
bkrbfpa
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="维吉尼亚密码-vigenere"> 维吉尼亚密码(vigenere</h3>
<ul>
<li><strong>题</strong>：设明文为 chicken, 密码为egw，采用维吉尼亚密码系统，加密后密文为= <strong>gnegqar</strong></li>
<li><strong>答</strong>：逐个将明文和密码每个对应的数字相加再模26，当密码取完再从头开始取</li>
</ul>
<div><pre><code>chicken
egwegwe
---------
c+e=2+4=6(mod26)=g
h+g=7+6=13(mod26)=n
.........
---------
gnegqar
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="费尔南密码-vernam"> 费尔南密码(Vernam</h3>
<ul>
<li><strong>题</strong>：用费尔南密码加密，明文是m= m1m2∙∙∙m16=1000101011010011, 密钥k = k1k2∙∙∙k10 =1010011101, 密文为</li>
<li><strong>答</strong>：将明文和密文异或即可，当密文取完再从头开始取</li>
</ul>
<div><pre><code>1000101011010011
1010011101101001
----------------
0010110110111010
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="普莱费尔密码-playfair"> 普莱费尔密码(playfair</h3>
<ul>
<li>
<p><strong>题</strong>：用playfair密码加密,明文hencookhot, 密钥为henfox,加密矩阵的第一行为____;加密矩阵的第二行为____;加密前分组为____（分组间用一个空格隔开）;密文为___</p>
</li>
<li>
<p><strong>答</strong>：这里做法不一定标准，仅供参考！具体以书为准</p>
<ul>
<li>
<p>先将明文分组：he nc ox ok ho tx</p>
<ul>
<li>分组有其规则，具体看下面</li>
</ul>
</li>
<li>
<p>然后画密钥矩阵</p>
<table>
<thead>
<tr>
<th>e</th>
<th>n</th>
<th>f</th>
<th>o</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>b</td>
<td>c</td>
<td>d</td>
</tr>
<tr>
<td>i/j</td>
<td>k</td>
<td>l</td>
<td>m</td>
</tr>
<tr>
<td>q</td>
<td>r</td>
<td>s</td>
<td>t</td>
</tr>
<tr>
<td>v</td>
<td>w</td>
<td>y</td>
<td>z</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>加密矩阵的第一行为<code>henfo</code></p>
</li>
<li>
<p>加密矩阵的第二行为<code>xabcd</code></p>
</li>
<li>
<p>加密前分组为（分组间用一个空格隔开）<code>he nc ox ok ho tx</code></p>
</li>
<li>
<p>密文为<code>enfbhdnmehpd</code></p>
</li>
<li>
<p>分组规则</p>
<ol>
<li>如果两个有字母相同的，则第二个用x代替</li>
<li>如果两个字母在同一行，用它右边的字母来代替，最右边字母用左边第一个字母代替，例如明文he，则密文为en。因为he同一行，所以用右边的字母代替</li>
<li>如果两个字母在同一列，用他下面的字母来代替，最底下的字母用该列第一个字母代替</li>
<li>其他的字母都用它同一行，另一个字母的同一列相交的字母代替；先行再列，例如明文nc，则密文为fb。将nc画十字，相交的为f和b，先n再c所以fb</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="希尔密码-hill"> 希尔密码(Hill)</h3>
<ul>
<li><strong>题</strong>：用Hill密码加密明文hate, 密钥为<img src="./images/密码学基础理论/2.png" alt="img" />，求密文</li>
<li><strong>答</strong>：这里涉及到矩阵的运算，按照矩阵的运算进行计算后模26即可，密文在前，明文在后。注意顺序不要搞混了！</li>
<li>先将hate转换为数字
<ul>
<li>h=7</li>
<li>a=0</li>
<li>t=19</li>
<li>e=4</li>
</ul>
</li>
</ul>
<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:2.40003em;vertical-align:-0.95003em;"></span><span><span style="top:0em;"><span>(</span></span><span><span><span><span><span><span style="height:1.45em;"><span style="top:-3.61em;"><span style="height:3em;"></span><span><span>11</span><span> </span><span>8</span></span></span><span style="top:-2.4099999999999997em;"><span style="height:3em;"></span><span><span>3</span><span> </span><span> </span><span>7</span></span></span></span><span>​</span></span><span><span style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span style="top:0em;"><span>)</span></span></span><span style="margin-right:0.2222222222222222em;"></span><span>⋅</span><span style="margin-right:0.2222222222222222em;"></span></span><span><span style="height:2.40003em;vertical-align:-0.95003em;"></span><span><span style="top:0em;"><span>(</span></span><span><span><span><span><span><span style="height:1.45em;"><span style="top:-3.61em;"><span style="height:3em;"></span><span><span>h</span><span> </span><span>t</span></span></span><span style="top:-2.4099999999999997em;"><span style="height:3em;"></span><span><span>a</span><span> </span><span>e</span></span></span></span><span>​</span></span><span><span style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span style="top:0em;"><span>)</span></span></span><span style="margin-right:0.2777777777777778em;"></span><span>=</span><span style="margin-right:0.2777777777777778em;"></span></span><span><span style="height:2.40003em;vertical-align:-0.95003em;"></span><span><span style="top:0em;"><span>(</span></span><span><span><span><span><span><span style="height:1.45em;"><span style="top:-3.61em;"><span style="height:3em;"></span><span><span>11</span><span> </span><span>8</span></span></span><span style="top:-2.4099999999999997em;"><span style="height:3em;"></span><span><span>3</span><span> </span><span> </span><span>7</span></span></span></span><span>​</span></span><span><span style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span style="top:0em;"><span>)</span></span></span><span style="margin-right:0.2222222222222222em;"></span><span>⋅</span><span style="margin-right:0.2222222222222222em;"></span></span><span><span style="height:2.40003em;vertical-align:-0.95003em;"></span><span><span style="top:0em;"><span>(</span></span><span><span><span><span><span><span style="height:1.45em;"><span style="top:-3.61em;"><span style="height:3em;"></span><span><span>7</span><span> </span><span>19</span></span></span><span style="top:-2.4099999999999997em;"><span style="height:3em;"></span><span><span>0</span><span> </span><span>4</span></span></span></span><span>​</span></span><span><span style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span style="top:0em;"><span>)</span></span></span><span style="margin-right:0.2777777777777778em;"></span><span>=</span><span style="margin-right:0.2777777777777778em;"></span></span><span><span style="height:2.40003em;vertical-align:-0.95003em;"></span><span><span style="top:0em;"><span>(</span></span><span><span><span><span><span><span style="height:1.45em;"><span style="top:-3.61em;"><span style="height:3em;"></span><span><span>77</span><span> </span><span>241</span></span></span><span style="top:-2.4099999999999997em;"><span style="height:3em;"></span><span><span>21</span><span> </span><span>85</span></span></span></span><span>​</span></span><span><span style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span style="top:0em;"><span>)</span></span></span></span></span></span></span></p>
<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.36687em;vertical-align:0em;"></span><span>=</span><span style="margin-right:0.2777777777777778em;"></span></span><span><span style="height:2.40003em;vertical-align:-0.95003em;"></span><span><span style="top:0em;"><span>(</span></span><span><span><span><span><span><span style="height:1.45em;"><span style="top:-3.61em;"><span style="height:3em;"></span><span><span>25</span><span> </span><span>7</span></span></span><span style="top:-2.4099999999999997em;"><span style="height:3em;"></span><span><span>21</span><span> </span><span>7</span></span></span></span><span>​</span></span><span><span style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span style="top:0em;"><span>)</span></span></span><span style="margin-right:0.2777777777777778em;"></span><span>=</span><span style="margin-right:0.2777777777777778em;"></span></span><span><span style="height:2.40003em;vertical-align:-0.95003em;"></span><span><span style="top:0em;"><span>(</span></span><span><span><span><span><span><span style="height:1.45em;"><span style="top:-3.61em;"><span style="height:3em;"></span><span><span style="margin-right:0.04398em;">z</span><span> </span><span>h</span></span></span><span style="top:-2.4099999999999997em;"><span style="height:3em;"></span><span><span style="margin-right:0.03588em;">v</span><span> </span><span>h</span></span></span></span><span>​</span></span><span><span style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span style="top:0em;"><span>)</span></span></span><span style="margin-right:0.2777777777777778em;"></span><span>=</span><span style="margin-right:0.2777777777777778em;"></span></span><span><span style="height:0.69444em;vertical-align:0em;"></span><span style="margin-right:0.04398em;">z</span><span style="margin-right:0.03588em;">v</span><span>hh</span></span></span></span></span></p>
<div><pre><code>11*7+8*0=77
77%26=25

11*19+8*4=241
241%26=7

3*7+7*0=21

3*19+7*4=85
85%26=7
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="置换密码"> 置换密码</h3>
<ul>
<li><strong>题</strong>：计算置换：</li>
</ul>
<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:2.40003em;vertical-align:-0.95003em;"></span><span><span style="top:0em;"><span>(</span></span><span><span><span><span><span><span style="height:1.45em;"><span style="top:-3.61em;"><span style="height:3em;"></span><span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span>4</span><span> </span><span>5</span></span></span><span style="top:-2.4099999999999997em;"><span style="height:3em;"></span><span><span>4</span><span> </span><span>1</span><span> </span><span>5</span><span> </span><span>2</span><span> </span><span>3</span></span></span></span><span>​</span></span><span><span style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span style="top:0em;"><span>)</span></span></span><span style="margin-right:0.2222222222222222em;"></span><span>⋅</span><span style="margin-right:0.2222222222222222em;"></span></span><span><span style="height:2.40003em;vertical-align:-0.95003em;"></span><span><span style="top:0em;"><span>(</span></span><span><span><span><span><span><span style="height:1.45em;"><span style="top:-3.61em;"><span style="height:3em;"></span><span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span>4</span><span> </span><span>5</span></span></span><span style="top:-2.4099999999999997em;"><span style="height:3em;"></span><span><span>1</span><span> </span><span>3</span><span> </span><span>2</span><span> </span><span>5</span><span> </span><span>4</span></span></span></span><span>​</span></span><span><span style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span style="top:0em;"><span>)</span></span></span><span style="margin-right:0.2777777777777778em;"></span><span>=</span></span></span></span></span></p>
<ul>
<li><strong>答</strong>：此题将上下对应的顺序置换即可。</li>
<li>1-&gt;4-&gt;5，2-&gt;1-&gt;1，3-&gt;5-&gt;4，4-&gt;2-&gt;3，5-&gt;3-&gt;2。所以答案为<code>5 1 4 3 2</code></li>
</ul>
<h2 id="对称密码系统与非对称密码系统"> 对称密码系统与非对称密码系统</h2>
<ul>
<li><strong>流密码</strong>是一种对称key密码</li>
<li><strong>ElGamal</strong>是一种非对称key密码</li>
</ul>
<h2 id="输出码表"> 输出码表</h2>
<ul>
<li>错码：使用<code>2x+1</code>公式计算即可</li>
<li>错误码：使用<code>2x-1</code>公式计算即可</li>
</ul>
<h2 id="四级线性反馈移位寄存器"> 四级线性反馈移位寄存器</h2>
<ul>
<li><strong>题</strong>：有一个四级线性反馈移位寄存器 f(x1,x2,x3,x4) =x1+x4, 其中初始值 (a1,a2,a3,a4)=(0011), 则输出的第7位为__7__, 则输出的前10位为__0011110101__</li>
<li><strong>答</strong>：大致过程：
<ul>
<li>将初始值写出，然后异或第一和第四位</li>
<li>将异或的结果写右边，并将整体往移一位</li>
<li>对比移位之后的四个数字</li>
</ul>
<div><pre><code>0011
↑  ↑  0⊕1=1
00111
 ↑  ↑ 0⊕1=1
.....
0011110101
      ↑
12345678910
则输出的第7位为：7, 则输出的前10位为：0011110101
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></li>
</ul>
<h2 id="计算题"> 计算题</h2>
<ul>
<li>
<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>[</span><span>3</span><span style="margin-right:0.2222222222222222em;"></span><span>+</span><span style="margin-right:0.2222222222222222em;"></span></span><span><span style="height:1.206095em;vertical-align:-0.25em;"></span><span><span><span><span style="height:0.956095em;"><span style="top:-3em;"><span style="height:3em;"></span><span style="padding-left:0.833em;"><span>2</span></span></span><span style="top:-2.916095em;"><span style="height:3em;"></span><span style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span>​</span></span><span><span style="height:0.08390500000000001em;"><span></span></span></span></span></span><span>]</span><span style="margin-right:0.2777777777777778em;"></span><span>=</span><span style="margin-right:0.2777777777777778em;"></span></span><span><span style="height:0.64444em;vertical-align:0em;"></span><span>4</span></span></span></span></span></p>
<ul>
<li>因为√2≈1.41***，所以3+1.4≈4.4向下取整=4</li>
</ul>
</li>
<li>
<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>[</span><span>−</span><span>(</span><span>3</span><span style="margin-right:0.2222222222222222em;"></span><span>+</span><span style="margin-right:0.2222222222222222em;"></span></span><span><span style="height:1.206095em;vertical-align:-0.25em;"></span><span><span><span><span style="height:0.956095em;"><span style="top:-3em;"><span style="height:3em;"></span><span style="padding-left:0.833em;"><span>2</span></span></span><span style="top:-2.916095em;"><span style="height:3em;"></span><span style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span>​</span></span><span><span style="height:0.08390500000000001em;"><span></span></span></span></span></span><span>)]</span><span style="margin-right:0.2777777777777778em;"></span><span>=</span><span style="margin-right:0.2777777777777778em;"></span></span><span><span style="height:0.72777em;vertical-align:-0.08333em;"></span><span>−</span><span>5</span></span></span></span></span></p>
<ul>
<li>因为√2≈1.41***，所以-(3+1.4)≈-4.4向下取整=-5</li>
</ul>
</li>
</ul>
<h2 id="理论题"> 理论题</h2>
<ul>
<li>设有一群人共享秘密，要求“任何两个人不知道秘密，但是任何三个人能知道秘密”。可以设置一条秘密 （ 抛物  ）线，然后宣布秘密就在此线与（ y  ） 轴的交点处。</li>
<li>RSA的加解密速度大约只有AES的（1/1000）</li>
<li>
<h3 id="不论输入是多少位-哈希函数的输出总是固定的位数-这是-压缩-特性"> 不论输入是多少位，哈希函数的输出总是固定的位数，这是（压缩 ）特性</h3>
</li>
</ul>
<h1 id="待"> 待</h1>
<h2 id="rsa"> RSA</h2>
<ul>
<li>RSA的加解密速度大约只有AES的1/1000</li>
</ul>
<h2 id="辗转相除法"> 辗转相除法</h2>
<h2 id="拉宾公钥"> 拉宾公钥</h2>
<h2 id="elgamal公钥算法"> ElGamal公钥算法</h2>
<h2 id="孙子定理"> 孙子定理</h2>
<h2 id="哈希函数"> 哈希函数</h2>
]]></content:encoded>
    </item>
    <item>
      <title>About Me</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/intro/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/intro/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">About Me</source>
      <content:encoded><![CDATA[<h1 id="about-me"> About Me</h1>
<p>我是谁不重要，重要的是你是谁。</p>
]]></content:encoded>
    </item>
    <item>
      <title>JAVASE | 03JAVA数组</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/hungry/JAVASE_03JAVA%E6%95%B0%E7%BB%84/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/hungry/JAVASE_03JAVA%E6%95%B0%E7%BB%84/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">JAVASE | 03JAVA数组</source>
      <category>求知</category>
      <pubDate>Mon, 01 Nov 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="数组"> 数组</h1>
<p>day6</p>
<h2 id="数组概述"> 数组概述</h2>
<ol>
<li>
<p>数组Array，是多个相同类型数据按一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理</p>
</li>
<li>
<p>数组相关的概念：</p>
<ul>
<li>
<p>数组名</p>
</li>
<li>
<p>元素</p>
</li>
<li>
<p>角标、下标、索引</p>
</li>
<li>
<p>数组的长度</p>
</li>
</ul>
</li>
<li>
<p>数组的特点：</p>
<ol>
<li>
<p>数组是有序排列的</p>
</li>
<li>
<p>数组属于引用数据类型的变量，数组的元素，既可以是基本数据类型，也可以是引用数据类型</p>
</li>
<li>
<p>创建数组对象会在内存中开辟一整块<strong>连续的空间</strong>，而数组中引用的是这块连续空间的首地址</p>
</li>
<li>
<p>数组的<strong>长度一旦确定，就不能修改</strong></p>
</li>
</ol>
</li>
<li>
<p>数组的分类</p>
<ol>
<li>
<p>按照维度：一维数组、二维数组、三维数组</p>
</li>
<li>
<p>按照元素的数据类型分：基本数据类型元素的数组、引用数据类型元素的数组（即对象数组）</p>
</li>
</ol>
</li>
</ol>
<ul>
<li>在这里涉及到地址值的数值，与c语言中的指针不太一样的地方是java中的地址不是内存中的地址，而是jvm虚拟算出来的哈希值，相当于屏蔽了底层真实的地址</li>
</ul>
<h2 id="一维数组的使用"> 一维数组的使用</h2>
<ol>
<li>
<p>一维数组的声明和初始化</p>
<ol>
<li>
<p>静态初始化: 数组的初始化和数组的元素的赋值操作同时进行</p>
</li>
<li>
<p>动态初始化：数组的初始化和数组的元素的赋值操作分开进行</p>
</li>
</ol>
<ul>
<li>
<p>总结：数组一旦初始化完成，其长度就确定了</p>
<div><pre><code>
<span>int</span> num<span>;</span><span>//声明</span>
num <span>=</span> <span>10</span><span>;</span><span>//初始化</span>
<span>int</span> id <span>=</span> <span>1001</span><span>;</span><span>//声明+初始化</span>

<span>int</span><span>[</span><span>]</span> ids<span>;</span><span>//声明</span>
<span>//1.1 静态初始化: 数组的初始化和数组的元素的赋值操作同时进行</span>
ids <span>=</span> <span>new</span> <span>int</span><span>[</span><span>]</span><span>{</span><span>1001</span><span>,</span><span>1002</span><span>,</span><span>1003</span><span>,</span><span>1004</span><span>}</span><span>;</span>
<span>//1.2 动态初始化：数组的初始化和数组的元素的赋值操作分开进行</span>
<span>String</span><span>[</span><span>]</span> names <span>=</span> <span>new</span> <span>String</span><span>[</span><span>5</span><span>]</span><span>;</span>
<span>//总结：数组一旦初始化完成，其长度就确定了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></li>
</ul>
</li>
<li>
<p>如何调用数组的指定位置的元素</p>
<ul>
<li>
<p>通过角标的方式调用</p>
</li>
<li>
<p>数组的角标（索引）从0开始，到数组的长度-1结束</p>
<div><pre><code>names<span>[</span><span>0</span><span>]</span> <span>=</span> <span>"Qiang"</span><span>;</span>
names<span>[</span><span>1</span><span>]</span> <span>=</span> <span>"Ming"</span><span>;</span>
names<span>[</span><span>2</span><span>]</span> <span>=</span> <span>"Hong"</span><span>;</span>
names<span>[</span><span>3</span><span>]</span> <span>=</span> <span>"Long"</span><span>;</span>
names<span>[</span><span>4</span><span>]</span> <span>=</span> <span>"Wang"</span><span>;</span><span>//charAt(0);需要找字符串也是从0开始</span>
<span>//		names[5] = "Out"//注意这里会有超出数组的范围的错误</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
</ul>
</li>
<li>
<p>如何获取数组的长度</p>
<ul>
<li>
<p>array.length</p>
<div><pre><code><span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>names<span>.</span>length<span>)</span><span>;</span><span>//5</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>ids<span>.</span>length<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
</ul>
</li>
<li>
<p>如何遍历数组</p>
<div><pre><code><span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span>i <span>&lt;</span> names<span>.</span>length<span>;</span>i<span>++</span><span>)</span> <span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>names<span>[</span>i<span>]</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p>数组元素的默认初始化值</p>
<ul>
<li>
<p>数组元素是整型：0</p>
</li>
<li>
<p>数组元素是浮点型：0.0</p>
</li>
<li>
<p>数组元素是char型：0或'\u0000'(不是'0')</p>
</li>
<li>
<p>数组元素是boolean型：false (0)</p>
</li>
<li>
<p>数组元素是引用数据类型(String)：null</p>
<div><pre><code><span>//5. 数组元素的默认初始化值</span>
<span>int</span><span>[</span><span>]</span> arr <span>=</span> <span>new</span> <span>int</span><span>[</span><span>4</span><span>]</span><span>;</span>
<span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span>i <span>&lt;</span> arr<span>.</span>length<span>;</span>i<span>++</span><span>)</span> <span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr<span>[</span>i<span>]</span><span>)</span><span>;</span>
<span>}</span>

<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"------------"</span><span>)</span><span>;</span>

<span>short</span><span>[</span><span>]</span> arr1 <span>=</span> <span>new</span> <span>short</span><span>[</span><span>4</span><span>]</span><span>;</span>
<span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span>i <span>&lt;</span> arr1<span>.</span>length<span>;</span>i<span>++</span><span>)</span> <span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr1<span>[</span>i<span>]</span><span>)</span><span>;</span>
<span>}</span>

<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"------------"</span><span>)</span><span>;</span>

<span>float</span><span>[</span><span>]</span> arr2 <span>=</span> <span>new</span> <span>float</span><span>[</span><span>5</span><span>]</span><span>;</span>
<span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span>i <span>&lt;</span> arr2<span>.</span>length<span>;</span>i<span>++</span><span>)</span> <span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr2<span>[</span>i<span>]</span><span>)</span><span>;</span>
<span>}</span>

<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"------------"</span><span>)</span><span>;</span>

<span>char</span><span>[</span><span>]</span> arr3 <span>=</span> <span>new</span> <span>char</span><span>[</span><span>5</span><span>]</span><span>;</span>
<span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span>i <span>&lt;</span> arr3<span>.</span>length<span>;</span>i<span>++</span><span>)</span> <span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"--"</span> <span>+</span> arr3<span>[</span>i<span>]</span> <span>+</span> <span>"--"</span><span>)</span><span>;</span>
<span>}</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>0</span><span>==</span>arr3<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>'0'</span><span>==</span>arr3<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>

<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"------------"</span><span>)</span><span>;</span>
<span>//不能使用静态初始化</span>
<span>boolean</span><span>[</span><span>]</span> arr4 <span>=</span> <span>new</span> <span>boolean</span><span>[</span><span>5</span><span>]</span><span>;</span>
<span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span>i <span>&lt;</span> arr4<span>.</span>length<span>;</span>i<span>++</span><span>)</span> <span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr4<span>[</span>i<span>]</span><span>)</span><span>;</span>
<span>}</span>


<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"------------"</span><span>)</span><span>;</span>
<span>//不能使用静态初始化</span>
<span>String</span><span>[</span><span>]</span> arr5 <span>=</span> <span>new</span> <span>String</span><span>[</span><span>5</span><span>]</span><span>;</span>
<span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span>i <span>&lt;</span> arr5<span>.</span>length<span>;</span>i<span>++</span><span>)</span> <span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr5<span>[</span>i<span>]</span><span>)</span><span>;</span>
<span>}</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr5<span>[</span><span>0</span><span>]</span> <span>==</span> <span>null</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr5<span>[</span><span>0</span><span>]</span> <span>==</span> <span>"null"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div></li>
</ul>
</li>
<li>
<p>数组的内存解析</p>
<ul>
<li>
<p>栈(stack)：局部变量</p>
</li>
<li>
<p>堆(heap)：new出来的结构：对象、数组</p>
</li>
<li>
<p>内存简化结构</p>
<p><img src="./images/03数组/image-20211026155814594.png" alt="image-20211026155814594" /></p>
<p><img src="./images/03数组/image-20211026164035596.png" alt="image-20211026164035596" /></p>
<p>当arr1不再指向0x12ab时，这里0x12ab这个数组会在不定的时间内给jvm的垃圾回收机制清除。从广义的角度来看数据的结构是这样存放，但具体的内存结构会有所不同</p>
<p>左边为栈，右边为堆，当程序允许完毕，就会出栈，出栈后，右边堆的元素就会给jvm的内存回收机制清楚</p>
</li>
</ul>
</li>
</ol>
<h3 id="一维数组练习"> 一维数组练习</h3>
<ul>
<li>
<p>练习1，判断输出</p>
<div><pre><code><span>public</span> <span>class</span> <span>ArrayDemo1</span> <span>{</span>
	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
		<span>int</span><span>[</span><span>]</span> arr <span>=</span> <span>new</span> <span>int</span><span>[</span><span>]</span> <span>{</span> <span>8</span><span>,</span> <span>2</span><span>,</span> <span>1</span><span>,</span> <span>0</span><span>,</span> <span>3</span> <span>}</span><span>;</span>
		<span>int</span><span>[</span><span>]</span> index <span>=</span> <span>new</span> <span>int</span><span>[</span><span>]</span> <span>{</span> <span>2</span><span>,</span> <span>0</span><span>,</span> <span>3</span><span>,</span> <span>2</span><span>,</span> <span>4</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>,</span> <span>3</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>3</span> <span>}</span><span>;</span>
		<span>String</span> tel <span>=</span> <span>""</span><span>;</span>
		<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> index<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
			tel <span>+=</span> arr<span>[</span>index<span>[</span>i<span>]</span><span>]</span><span>;</span>
		<span>}</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"联系方式："</span> <span>+</span> tel<span>)</span><span>;</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></li>
<li>
<p>练习2</p>
<ul>
<li>从键盘读入学生成绩，找出最高分，并输出学生成绩等级，成绩&gt;=最高分-10, A，成绩&gt;=最高分-20, B，成绩&gt;=最高分-30, C，其余,D</li>
</ul>
<div><pre><code><span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Scanner</span><span>;</span>

<span>public</span> <span>class</span> <span>ArrayDemo2</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 1. 使用Scanner，读取学生个数</span>
        <span>Scanner</span> scanner <span>=</span> <span>new</span> <span>Scanner</span><span>(</span><span>System</span><span>.</span>in<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>"请输入学生人数："</span><span>)</span><span>;</span>

        <span>// 2. 创建数组，存储学生成绩，动态初始化</span>
        <span>int</span> num <span>=</span> scanner<span>.</span><span>nextInt</span><span>(</span><span>)</span><span>;</span>
        <span>int</span><span>[</span><span>]</span> scores <span>=</span> <span>new</span> <span>int</span><span>[</span>num<span>]</span><span>;</span>

        <span>// 3. 给数组中的元素赋值</span>
        <span>int</span> max <span>=</span> <span>0</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"请输入"</span> <span>+</span> num <span>+</span> <span>"个学生成绩"</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> scores<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            scores<span>[</span>i<span>]</span> <span>=</span> scanner<span>.</span><span>nextInt</span><span>(</span><span>)</span><span>;</span>
            <span>// 4. 获取数组中元素的最大值：最高分</span>
            <span>if</span> <span>(</span>scores<span>[</span>i<span>]</span> <span>></span> max<span>)</span>
                max <span>=</span> scores<span>[</span>i<span>]</span><span>;</span>

        <span>}</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"最高分是："</span> <span>+</span> max<span>)</span><span>;</span>

        <span>// 5. 根据每个学生成绩与最高分的差值，得到每个学生的等级，并输出等级和成绩</span>
        <span>char</span> level<span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> scores<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>scores<span>[</span>i<span>]</span> <span>>=</span> max <span>-</span> <span>10</span><span>)</span> <span>{</span>
                level <span>=</span> <span>'A'</span><span>;</span>
            <span>}</span> <span>else</span> <span>if</span> <span>(</span>scores<span>[</span>i<span>]</span> <span>>=</span> max <span>-</span> <span>20</span><span>)</span> <span>{</span>
                level <span>=</span> <span>'B'</span><span>;</span>
            <span>}</span> <span>else</span> <span>if</span> <span>(</span>scores<span>[</span>i<span>]</span> <span>>=</span> max <span>-</span> <span>30</span><span>)</span> <span>{</span>
                level <span>=</span> <span>'C'</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                level <span>=</span> <span>'D'</span><span>;</span>
            <span>}</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"student "</span> <span>+</span> i <span>+</span> <span>" score is "</span> <span>+</span> scores<span>[</span>i<span>]</span> <span>+</span> <span>",grade is "</span> <span>+</span> level<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div></li>
</ul>
<h2 id="二维数组的使用"> 二维数组的使用</h2>
<ul>
<li>
<p>java语言里提供支持多维数组的语法</p>
</li>
<li>
<p>二维数组相当于是一个表格，他有行与列</p>
</li>
</ul>
<ol>
<li>
<p>理解</p>
<ul>
<li>对于二维数组的理解，我们可以看成是一维数组array1又作为另一个一维数组array2的元素二存在。</li>
</ul>
<p><strong>其实从数组底层的运行机制来看，其实没有多维数组</strong></p>
</li>
<li>
<p>二维数组的使用</p>
<ol>
<li>
<p>二维数组的声明和初始化</p>
<div><pre><code><span>//一维数组的静态初始化</span>
<span>int</span><span>[</span><span>]</span> arr <span>=</span> <span>new</span> <span>int</span><span>[</span><span>]</span> <span>{</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>}</span><span>;</span>
<span>//二维数组的静态初始化</span>
<span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> arr1 <span>=</span> <span>new</span> <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span><span>{</span><span>{</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>}</span><span>,</span><span>{</span><span>4</span><span>,</span><span>5</span><span>}</span><span>,</span><span>{</span><span>6</span><span>,</span><span>7</span><span>,</span><span>8</span><span>}</span><span>}</span><span>;</span>
<span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> arr4 <span>=</span> <span>new</span> <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span><span>{</span><span>{</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>}</span><span>,</span><span>{</span><span>4</span><span>,</span><span>5</span><span>,</span><span>9</span><span>,</span><span>10</span><span>}</span><span>,</span><span>{</span><span>6</span><span>,</span><span>7</span><span>,</span><span>8</span><span>}</span><span>}</span><span>;</span>

<span>//也是正确的写法</span>
<span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> arr11 <span>=</span> <span>{</span><span>{</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>}</span><span>,</span><span>{</span><span>4</span><span>,</span><span>5</span><span>}</span><span>,</span><span>{</span><span>6</span><span>,</span><span>7</span><span>,</span><span>8</span><span>}</span><span>}</span><span>;</span>
<span>//二维数组的动态初始化1</span>
<span>String</span><span>[</span><span>]</span><span>[</span><span>]</span> arr2 <span>=</span> <span>new</span> <span>String</span><span>[</span><span>3</span><span>]</span><span>[</span><span>2</span><span>]</span><span>;</span><span>//3行2列</span>
<span>//二维数组的动态初始化2</span>
<span>String</span><span>[</span><span>]</span><span>[</span><span>]</span> arr3 <span>=</span> <span>new</span> <span>String</span><span>[</span><span>3</span><span>]</span><span>[</span><span>]</span><span>;</span><span>//3行n列</span>
<span>String</span><span>[</span><span>]</span> arr31<span>[</span><span>]</span> <span>=</span> <span>new</span> <span>String</span><span>[</span><span>3</span><span>]</span><span>[</span><span>]</span><span>;</span><span>//3行n列</span>
<span>String</span> arr32<span>[</span><span>]</span><span>[</span><span>]</span> <span>=</span> <span>new</span> <span>String</span><span>[</span><span>3</span><span>]</span><span>[</span><span>]</span><span>;</span><span>//3行n列</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div></li>
<li>
<p>如何调用数组的指定位置的元素</p>
<div><pre><code><span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr1<span>[</span><span>0</span><span>]</span><span>[</span><span>1</span><span>]</span><span>)</span><span>;</span><span>//2</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr2<span>[</span><span>1</span><span>]</span><span>[</span><span>1</span><span>]</span><span>)</span><span>;</span><span>//null，第二行的第二个元素</span>
<span>//System.out.println(arr3[1][1]);//直接输出是空指针异常报错，因为arr3指向的数组[1]内没有指向的数组</span>
arr3<span>[</span><span>1</span><span>]</span> <span>=</span> <span>new</span> <span>String</span><span>[</span><span>4</span><span>]</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr3<span>[</span><span>1</span><span>]</span><span>[</span><span>0</span><span>]</span><span>)</span><span>;</span><span>//null</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p>如何获取数组的长度</p>
<div><pre><code><span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr4<span>.</span>length<span>)</span><span>;</span><span>//3,因为内存指向的是三个长度的数组</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr4<span>[</span><span>0</span><span>]</span><span>.</span>length<span>)</span><span>;</span><span>//3</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr4<span>[</span><span>1</span><span>]</span><span>.</span>length<span>)</span><span>;</span><span>//4,这里指向的是arr4[1]指向的数组长度</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
<li>
<p>如何遍历二维数组</p>
<div><pre><code><span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span>i <span>&lt;</span> arr4<span>.</span>length<span>;</span>i<span>++</span><span>)</span> <span>{</span>
    <span>for</span><span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span>j <span>&lt;</span> arr4<span>[</span>i<span>]</span><span>.</span>length<span>;</span>j<span>++</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>arr4<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>+</span> <span>" "</span><span>)</span><span>;</span>
    <span>}</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
<li>
<p>数组元素的默认初始化值</p>
<ul>
<li>
<p>规定：二维数组分为外层数组的元素，内层数组的元素</p>
</li>
<li>
<p><code>int[][] arr = new int[4][3];</code></p>
<ul>
<li>
<p>外层元素：<code>arr[0],arr[1]</code>等</p>
</li>
<li>
<p>内层元素：<code>arr[0][0],arr[1][2]</code>等</p>
</li>
</ul>
</li>
<li>
<p><code>[I@75a1cd57</code></p>
<ul>
<li>
<p><code>[</code>一维的数组</p>
</li>
<li>
<p><code>I</code>int型的</p>
</li>
<li>
<p><code>@75a1cd57</code>地址在@后面的数</p>
</li>
</ul>
</li>
<li>
<p><code>[[I@515f550a</code></p>
<ul>
<li>
<p><code>[[</code>二维数组</p>
</li>
<li>
<p><code>I</code>int型</p>
</li>
<li>
<p><code>@515f550a</code>地址在@后面的数</p>
</li>
</ul>
</li>
</ul>
<div><pre><code><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> arr <span>=</span> <span>new</span> <span>int</span><span>[</span><span>4</span><span>]</span><span>[</span><span>3</span><span>]</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span><span>//地址值 [I@75a1cd57 `[`一维的 `I`int型的 `@75a1cd57`在@后面的地址</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr<span>[</span><span>0</span><span>]</span><span>[</span><span>0</span><span>]</span><span>)</span><span>;</span><span>//0</span>
<span>// System.out.println(arr);//[[I@515f550a</span>

<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"-------------"</span><span>)</span><span>;</span>

<span>float</span><span>[</span><span>]</span><span>[</span><span>]</span> arr1 <span>=</span> <span>new</span> <span>float</span><span>[</span><span>4</span><span>]</span><span>[</span><span>3</span><span>]</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr1<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span><span>//地址值 [F@515f550a</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr1<span>[</span><span>0</span><span>]</span><span>[</span><span>0</span><span>]</span><span>)</span><span>;</span><span>//0.0</span>

<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"-------------"</span><span>)</span><span>;</span>

<span>String</span><span>[</span><span>]</span><span>[</span><span>]</span> arr2 <span>=</span> <span>new</span> <span>String</span><span>[</span><span>4</span><span>]</span><span>[</span><span>3</span><span>]</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr2<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span><span>//地址值 [Ljava.lang.String;@123a439b</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr2<span>[</span><span>0</span><span>]</span><span>[</span><span>0</span><span>]</span><span>)</span><span>;</span><span>//null</span>

<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"-------------"</span><span>)</span><span>;</span>

<span>double</span><span>[</span><span>]</span><span>[</span><span>]</span> arr3 <span>=</span> <span>new</span> <span>double</span><span>[</span><span>4</span><span>]</span><span>[</span><span>]</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr3<span>[</span><span>1</span><span>]</span><span>)</span><span>;</span><span>//null</span>
<span>// System.out.println(arr3[1][0]);//报错-空指针异常</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div></li>
<li>
<p>二维数组的内存解析</p>
<div><pre><code><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> arr1 <span>=</span> <span>new</span> <span>int</span><span>[</span><span>4</span><span>]</span><span>[</span><span>]</span><span>;</span>
arr1<span>[</span><span>1</span><span>]</span> <span>=</span> <span>new</span> <span>int</span><span>[</span><span>]</span><span>{</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>}</span><span>;</span>
arr1<span>[</span><span>2</span><span>]</span> <span>=</span> <span>new</span> <span>int</span><span>[</span><span>4</span><span>]</span><span>;</span>
arr1<span>[</span><span>2</span><span>]</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>30</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><img src="./images/03数组/image-20211026211042714.png" alt="image-20211026211042714" /></p>
</li>
</ol>
</li>
</ol>
<h2 id="数组的练习"> 数组的练习</h2>
<h3 id="数组的复制"> 数组的复制</h3>
<ul>
<li>
<p>在下面代码中，其实就<code>array2=array1</code>这个操作就相当于将array1的地址复制到array2，这里只new了一次，所以在内存中就只有一个数组，所以对array2修改其实就是对array1修改</p>
</li>
<li>
<p>array1和array2地址值相同，都指向了堆空间的唯一的一个数组实体</p>
</li>
</ul>
<p><img src="./images/03数组/image-20211029213909316.png" alt="image-20211029213909316" /></p>
<div><pre><code><span>/*
创建两个int数组，存入8个素数
输出array，将array2=array1，修改array2中的偶数的值让其等于索引值，并打印array1
 */</span>
<span>class</span> cvArrayExr <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>int</span><span>[</span><span>]</span> array1<span>,</span> array2<span>;</span>
        array1 <span>=</span> <span>new</span> <span>int</span><span>[</span><span>]</span><span>{</span><span>2</span><span>,</span><span>3</span><span>,</span><span>5</span><span>,</span><span>7</span><span>,</span><span>11</span><span>,</span><span>13</span><span>,</span><span>17</span><span>,</span><span>19</span><span>}</span><span>;</span>
        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span>i <span>&lt;</span> array1<span>.</span>length<span>;</span>i<span>++</span><span>)</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>array1<span>[</span>i<span>]</span> <span>+</span> <span>"\t"</span><span>)</span><span>;</span>
        <span>}</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span>
        <span>//这个操作不能称作数组的复制，他只是将array1的值复制给array2</span>
        <span>//这里自始自终就只有一个数组，因为上面就new了一次</span>
        array2 <span>=</span> array1<span>;</span>

        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span>i <span>&lt;</span> array2<span>.</span>length<span>;</span>i<span>++</span><span>)</span><span>{</span>
            <span>if</span><span>(</span>i <span>%</span> <span>2</span> <span>==</span> <span>0</span><span>)</span><span>{</span>
                array2<span>[</span>i<span>]</span> <span>=</span> i<span>;</span>
            <span>}</span>
        <span>}</span>
        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span>i <span>&lt;</span> array1<span>.</span>length<span>;</span>i<span>++</span><span>)</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>array1<span>[</span>i<span>]</span> <span>+</span> <span>"\t"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h3 id="真正意义上的复制"> 真正意义上的复制</h3>
<ul>
<li>这里是new了两个数组，真正意义上的复制</li>
</ul>
<p><img src="./images/03数组/image-20211029213105574.png" alt="image-20211029213105574" /></p>
<div><pre><code><span>/*
数组的复制
 */</span>
<span>class</span> cvArrayExr1 <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>int</span><span>[</span><span>]</span> array1<span>,</span> array2<span>;</span>
        array1 <span>=</span> <span>new</span> <span>int</span><span>[</span><span>]</span><span>{</span><span>2</span><span>,</span><span>3</span><span>,</span><span>5</span><span>,</span><span>7</span><span>,</span><span>11</span><span>,</span><span>13</span><span>,</span><span>17</span><span>,</span><span>19</span><span>}</span><span>;</span>
        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span>i <span>&lt;</span> array1<span>.</span>length<span>;</span>i<span>++</span><span>)</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>array1<span>[</span>i<span>]</span> <span>+</span> <span>"\t"</span><span>)</span><span>;</span>
        <span>}</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span>
        <span>//这个操作不能称作数组的复制，他只是将array1的值复制给array2</span>
        <span>//这里自始自终就只有一个数组，因为上面就new了一次</span>
        <span>//array1和array2地址值相同，都指向了堆空间的唯一的一个数组实体</span>
        array2 <span>=</span> <span>new</span> <span>int</span><span>[</span>array1<span>.</span>length<span>]</span><span>;</span>

        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span>i <span>&lt;</span> array2<span>.</span>length<span>;</span>i<span>++</span><span>)</span><span>{</span>
            <span>if</span><span>(</span>i <span>%</span> <span>2</span> <span>==</span> <span>0</span><span>)</span><span>{</span>
                array2<span>[</span>i<span>]</span> <span>=</span> i<span>;</span>
            <span>}</span>
            <span>else</span><span>{</span>
                array2<span>[</span>i<span>]</span> <span>=</span> array1<span>[</span>i<span>]</span> <span>+</span> <span>1</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span>i <span>&lt;</span> array1<span>.</span>length<span>;</span>i<span>++</span><span>)</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>array1<span>[</span>i<span>]</span> <span>+</span> <span>"\t"</span><span>)</span><span>;</span>
        <span>}</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span>
        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span>i <span>&lt;</span> array2<span>.</span>length<span>;</span>i<span>++</span><span>)</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>array2<span>[</span>i<span>]</span> <span>+</span> <span>"\t"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><h1 id="考察"> 考察</h1>
<ol>
<li>
<p>写出一维数组初始化的两种方式</p>
<div><pre><code><span>int</span><span>[</span><span>]</span> arr <span>=</span> <span>new</span> <span>int</span><span>[</span><span>5</span><span>]</span><span>;</span><span>//动态初始化</span>
<span>String</span><span>[</span><span>]</span> arr1 <span>=</span> <span>new</span> <span>int</span><span>[</span><span>]</span><span>{</span><span>'ming'</span><span>,</span><span>'qiang'</span><span>,</span><span>'mi'</span><span>}</span><span>;</span><span>//静态初始化</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>
<p>数组一旦初始化，其长度就是确定的，且数组长度一旦确定就不可修改</p>
</li>
<li>
<p>获取数组长度：arr.length</p>
</li>
</ul>
</li>
<li>
<p>写出二维数组初始化的两种方式</p>
<div><pre><code><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> arr2 <span>=</span> <span>new</span> <span>int</span><span>[</span><span>4</span><span>]</span><span>[</span><span>3</span><span>]</span><span>;</span><span>//动态初始化1</span>
<span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> arr3 <span>=</span> <span>new</span> <span>int</span><span>[</span><span>4</span><span>]</span><span>[</span><span>3</span><span>]</span><span>;</span><span>//动态初始化2</span>
<span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> arr3 <span>=</span> <span>new</span> <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span><span>{</span><span>{</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>}</span><span>,</span><span>{</span><span>4</span><span>,</span><span>5</span><span>,</span><span>6</span><span>}</span><span>,</span><span>{</span><span>7</span><span>,</span><span>8</span><span>}</span><span>}</span><span>;</span><span>//静态初始化</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p>如何遍历如下的二维数组</p>
<div><pre><code><span>int</span><span>[</span><span>]</span> arr <span>=</span> <span>new</span> <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span><span>{</span><span>{</span><span>123</span><span>}</span><span>,</span><span>{</span><span>4</span><span>,</span><span>5</span><span>}</span><span>,</span><span>{</span><span>6</span><span>,</span><span>7</span><span>,</span><span>9</span><span>}</span><span>}</span>
<span>for</span><span>(</span><span>int</span> i <span>=</span> <span>9</span><span>;</span>i <span>&lt;</span> arr<span>.</span>length<span>;</span>i<span>++</span><span>)</span><span>{</span>
    <span>for</span><span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span>j <span>&lt;</span> arr<span>[</span>i<span>]</span><span>.</span>length<span>;</span>j<span>++</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>arr<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>+</span> <span>"\t"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
<li>
<p>不同类型的一维数组元素的默认初始化值各是多少</p>
<div><pre><code>整形: 0
浮点型: 0.0
char: 0
boolean: false
引用类型: null
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p>一维数组的内存解析</p>
<div><pre><code><span>String</span><span>[</span><span>]</span> strs <span>=</span> <span>new</span> <span>String</span><span>[</span><span>5</span><span>]</span><span>;</span>
strs<span>[</span><span>2</span><span>]</span> <span>=</span> <span>"Tom"</span><span>;</span>
strs <span>=</span> <span>new</span> <span>String</span><span>[</span><span>3</span><span>]</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>引用类型的遍历，要么是null，要么是地址值（存放于常量池里面）</p>
<p><img src="./images/03数组/image-20211026213544987.png" alt="image-20211026213544987" /></p>
</li>
</ol>
<h1 id="关于数组的拓展"> 关于数组的拓展</h1>
<p>day7</p>
<h2 id="数组的排序算法"> 数组的排序算法</h2>
<h3 id="十大内部排序算法"> 十大内部排序算法</h3>
<ul>
<li>
<p>选择排序</p>
<ul>
<li>直接选择排序、<em>堆排序</em></li>
</ul>
</li>
<li>
<p>交换排序</p>
<ul>
<li><strong>冒泡排序、快速排序</strong></li>
</ul>
</li>
<li>
<p>插入排序</p>
<ul>
<li>直接插入排序、折半插入排序、shell排序</li>
</ul>
</li>
<li>
<p><em>归并算法</em></p>
</li>
<li>
<p>桶式算法</p>
</li>
<li>
<p>基数算法</p>
</li>
<li>
<p>满足确定性的算法也称为：确定性算法。选择人们也关注更广泛的概念，例如考虑葛洪非确定性的算法，如并行算法、概率算法等。另外，人们也关注并不要求终止的计算描述，这种描述有时候被称为过程（procedure）</p>
</li>
</ul>
<h3 id="理解"> 理解</h3>
<ol>
<li>
<p>衡量排序算法的优劣</p>
<ul>
<li><strong>时间复杂度</strong>、空间复杂度、稳定性</li>
</ul>
</li>
<li>
<p>排序的分类</p>
<ul>
<li>内部排序与外部排序（需要借助于磁盘）</li>
</ul>
</li>
<li>
<p>不同排序算法的时间复杂度</p>
<p><img src="./images/03数组/image-20211030152232128.png" alt="image-20211030152232128" /></p>
<ul>
<li>
<p>从平均时间而言：</p>
</li>
<li>
<p>快速排序最佳，但再最坏情况下时间性能不如堆排序和归并排序</p>
</li>
<li>
<p>从算法简单性看：</p>
<ul>
<li>
<p>由于直接选择排序、直接插入排序和冒泡排序的算法比较简单，将其认为是简单算法。</p>
</li>
<li>
<p>对于shell排序、堆排序、快速排序和归并排序算法，其算法比较复杂，认为是复杂排序</p>
</li>
</ul>
</li>
<li>
<p>从稳定性看：</p>
<ul>
<li>
<p>直接插入排序、冒泡排序和归并排序是稳定的；</p>
</li>
<li>
<p>而直接选择排序、快速排序、shell排序和堆排序是不稳定排序</p>
</li>
</ul>
</li>
<li>
<p>从待排序的记录数n的大小看：</p>
<ul>
<li>
<p>n较小时，宜采用简单排序；</p>
</li>
<li>
<p>而n较大时宜采用改进排序</p>
</li>
</ul>
</li>
<li>
<p>排序算法的选择</p>
<ul>
<li>
<p>若n较小（n&lt;=50)，可采用直接插入或直接选择排序</p>
<ul>
<li>当记录规模较小时，直接插入排序较好；否则因为直接选择移动的记录数少于直接插入，应选直接选择排序为宜</li>
</ul>
</li>
<li>
<p>若文件初始状态基本有序（指正序），则一ing有直接插入、冒泡或随机的快速排序为宜</p>
</li>
<li>
<p>若n较大，则应才有时间复杂度为O(nlogn)的排序方法：快速排序、堆排序或归并排序</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>冒泡排序</p>
<div><pre><code><span>int</span><span>[</span><span>]</span> arr <span>=</span> <span>new</span> <span>int</span><span>[</span><span>]</span><span>{</span><span>43</span><span>,</span><span>32</span><span>,</span><span>76</span><span>,</span><span>-</span><span>98</span><span>,</span><span>0</span><span>,</span><span>64</span><span>,</span><span>33</span><span>,</span><span>-</span><span>21</span><span>,</span><span>32</span><span>,</span><span>99</span><span>}</span><span>;</span>

<span>//冒泡排序</span>
<span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span>i <span>&lt;</span> arr<span>.</span>length <span>-</span> <span>1</span><span>;</span>i<span>++</span><span>)</span><span>{</span>

    <span>for</span><span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span>j <span>&lt;</span> arr<span>.</span>length <span>-</span> <span>1</span> <span>-</span> i<span>;</span>j<span>++</span><span>)</span><span>{</span>

        <span>if</span><span>(</span>arr<span>[</span>j<span>]</span> <span>></span> arr<span>[</span>j <span>+</span> <span>1</span><span>]</span><span>)</span><span>{</span>
            <span>int</span> temp <span>=</span> arr<span>[</span>j<span>]</span><span>;</span>
            arr<span>[</span>j<span>]</span> <span>=</span> arr<span>[</span>j <span>+</span> <span>1</span><span>]</span><span>;</span>
            arr<span>[</span>j <span>+</span> <span>1</span><span>]</span> <span>=</span> temp<span>;</span>
        <span>}</span>

    <span>}</span>

<span>}</span>		
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div></li>
</ol>
<h2 id="arrays工具类的使用"> Arrays工具类的使用</h2>
<ul>
<li>
<p><code>java.uril.Arrays</code>类即为操作数组的工具类，包含了用来操作数组（比如排序和搜素哦）的各种方法</p>
<ul>
<li>
<p><code>boolean equals(int[] a,int[] b)</code>，判断两个数组是否相等</p>
</li>
<li>
<p><code>String toString(int[] a)</code>，输出数组信息</p>
</li>
<li>
<p><code>void fill(int[] a,int val)</code>，将指定值填充到数组之中</p>
</li>
<li>
<p><code>void sort(int[] a)</code>，对数组进行排序</p>
</li>
<li>
<p><code>int binarySearch(int[] a,int key)</code>，对排序后的数组进行二分法检索指定的值</p>
</li>
</ul>
</li>
</ul>
<h1 id="eclipse的使用"> Eclipse的使用</h1>
<p>此部分为day6的部分</p>
<h2 id="关于eclipse建议的设置"> 关于Eclipse建议的设置</h2>
<ul>
<li>
<p>窗口，其他的根据具体需求使用</p>
<ul>
<li>
<p>navigator</p>
</li>
<li>
<p>package explorer</p>
</li>
<li>
<p>outline</p>
</li>
<li>
<p>console</p>
</li>
</ul>
</li>
<li>
<p>设置（window-&gt;Proferences</p>
<ul>
<li>
<p>编码设置</p>
<ul>
<li>
<p>General-&gt;Wrokspace: 最下面找到Text file encoding 将default改为other(UTF-8)</p>
</li>
<li>
<p>如果不改就会出现乱码问题</p>
</li>
</ul>
</li>
<li>
<p>字体放大</p>
<ul>
<li>
<p>General-&gt;Appearance-&gt;Colors and Fonts: Basic-&gt;Text Fone</p>
</li>
<li>
<p>然后点击右边的Edit将字体大小改为12-16</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>设置新建的文件</p>
<ul>
<li>
<p>window-&gt;perspective-&gt;customize perspective</p>
<ul>
<li>
<p>file-&gt;new</p>
<ul>
<li>
<p>将new的勾选全取消</p>
</li>
<li>
<p>将以下打勾</p>
<ul>
<li>
<p>java project</p>
</li>
<li>
<p>package</p>
</li>
<li>
<p>class</p>
</li>
<li>
<p>interface</p>
</li>
<li>
<p>enum</p>
</li>
<li>
<p>annotation</p>
</li>
<li>
<p>junit test case</p>
</li>
<li>
<p>folder</p>
</li>
<li>
<p>file</p>
</li>
<li>
<p>jsp file</p>
</li>
<li>
<p>dynamic web project</p>
</li>
<li>
<p>servlet</p>
</li>
<li>
<p>filter</p>
</li>
<li>
<p>listener</p>
</li>
<li>
<p>html file</p>
</li>
<li>
<p>xml file</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>如果上述的文件格式你找不到，那你需要在设置里面稍作修改</p>
<ul>
<li>
<p>具体参考：</p>
<ul>
<li>
<p><a href="https://blog.csdn.net/Xiewanru/article/details/85937953" target="_blank" rel="noopener noreferrer">Eclipse新建JSP页面时没有web文件夹和jsp file选项_虑而后能得-CSDN博客</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/tianhengblogs/p/9281891.html" target="_blank" rel="noopener noreferrer">Eclipse新建文件时没有JSP File解决方法 - 玉天恒 - 博客园 (cnblogs.com)</a></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>如果你要将上面描述的保存</p>
<ul>
<li>
<p>window-&gt;perspective-&gt;save perspective as</p>
<ul>
<li>你可以将默认的给替换掉</li>
</ul>
</li>
</ul>
</li>
<li>
<p>如果后续编辑界面乱了，你可以在<code>window-&gt;perspective-&gt;reset perspective</code>中恢复</p>
</li>
</ul>
<h2 id="hello实例"> Hello实例</h2>
<ul>
<li>
<p>新建project，new-&gt;java project</p>
</li>
<li>
<p>添加名字，版本自选，后面默认下一步即可</p>
</li>
<li>
<p>在<code>src</code>中新建包<code>package</code></p>
<ul>
<li>
<p>包里面放源文件，包的概念是将代码变成一个一个的包</p>
</li>
<li>
<p>格式：<code>com.[域名].[功能]</code></p>
</li>
</ul>
</li>
<li>
<p>在包<code>package</code>中创建class</p>
<ul>
<li>增加名字即可</li>
</ul>
</li>
</ul>
<h3 id="关于使用"> 关于使用</h3>
<ul>
<li>
<p>在eclipse中也有快捷键</p>
<ul>
<li>
<p><code>main</code> + <code>alt+/</code>：自动写<code>public static void main(String[] args)</code></p>
</li>
<li>
<p><code>syso</code> + <code>alt+/</code>：自动写<code>System.out.println();</code></p>
</li>
</ul>
</li>
<li>
<p>运行：右键找到run as-&gt;java application</p>
<ul>
<li>如果你没写main，eclipse就会找不到入口</li>
</ul>
</li>
</ul>
<h2 id="常见问题"> 常见问题</h2>
<ul>
<li>
<p>双击eclipse不能正常启动：</p>
<ul>
<li>
<p>启动失败有很多种原因</p>
<ol>
<li>
<p>查看环境变量是否正确，cmd输入javac.exe或java.exe进行检查</p>
</li>
<li>
<p>是否正确的安装了jdk和jre</p>
</li>
<li>
<p>安装的jdk版本（32位或64位），必须与eclipse一致</p>
</li>
<li>
<p>修改eclipse安装目录下的eclipse.ini配置文件</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="考察-2"> 考察</h1>
<ol>
<li>
<p>使用冒泡排序</p>
<div><pre><code><span>int</span><span>[</span><span>]</span> arr <span>=</span> <span>new</span> <span>int</span><span>[</span><span>]</span><span>{</span><span>34</span><span>,</span><span>5</span><span>,</span><span>22</span><span>,</span><span>-</span><span>98</span><span>,</span><span>6</span><span>,</span><span>-</span><span>76</span><span>,</span><span>0</span><span>,</span><span>-</span><span>3</span><span>}</span>
<span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span>i <span>&lt;</span> arr<span>.</span>length<span>-</span><span>1</span><span>;</span>i<span>++</span><span>)</span><span>{</span>
    <span>for</span><span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span>j <span>&lt;</span> arr<span>.</span>length <span>-</span> <span>1</span> <span>-</span> i<span>;</span>j<span>++</span><span>)</span><span>{</span>
        <span>if</span> <span>(</span>arr<span>[</span>j<span>]</span> <span>></span> arr<span>[</span>j <span>+</span> <span>1</span><span>]</span><span>)</span><span>{</span>
            arr<span>[</span>j<span>]</span> <span>+=</span> arr<span>[</span>j <span>+</span> <span>1</span><span>]</span><span>;</span>
            arr<span>[</span>j <span>+</span> <span>1</span><span>]</span> <span>=</span> arr<span>[</span>j<span>]</span> <span>-</span> arr<span>[</span>j <span>+</span> <span>1</span><span>]</span><span>;</span>
            arr<span>[</span>j<span>]</span> <span>=</span> arr<span>[</span>j<span>]</span> <span>-</span> arr<span>[</span>j <span>+</span> <span>1</span><span>]</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ul>
<li>
<p>String按照ascii的大小排序</p>
</li>
<li>
<p>冒泡排序的时间复杂度：O(N^2)</p>
</li>
<li>
<p>快速排序时间复杂度：O(nlogn)</p>
</li>
<li>
<p>堆排序、归并排序</p>
</li>
</ul>
</li>
<li>
<p>如何反转数组</p>
<div><pre><code><span>int</span><span>[</span><span>]</span> arr1 <span>=</span> <span>{</span><span>-</span><span>24</span><span>,</span><span>-</span><span>4</span><span>,</span><span>4</span><span>,</span><span>4</span><span>,</span><span>6</span><span>,</span><span>23</span><span>,</span><span>39</span><span>,</span><span>41</span><span>,</span><span>95</span><span>,</span><span>98</span><span>}</span><span>;</span>
<span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>,</span>j <span>=</span> arr1<span>.</span>length <span>-</span> <span>1</span><span>;</span>i <span>&lt;</span> j<span>;</span>i<span>++</span><span>;</span>j<span>--</span><span>)</span><span>{</span>
    arr<span>[</span>j<span>]</span> <span>+=</span> arr<span>[</span>i<span>]</span><span>;</span>
    arr<span>[</span>i<span>]</span> <span>=</span> arr<span>[</span>j<span>]</span> <span>-</span> arr<span>[</span>i<span>]</span><span>;</span>
    arr<span>[</span>j<span>]</span> <span>=</span> arr<span>[</span>j<span>]</span> <span>-</span> arr<span>[</span>i<span>]</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
<li>
<p>复制数组</p>
<div><pre><code><span>//复制地址</span>
arr2 <span>=</span> arr1<span>;</span>
<span>//复制内容</span>
<span>int</span><span>[</span><span>]</span> arr2 <span>=</span> <span>new</span> <span>int</span><span>[</span>arr1<span>.</span>length<span>]</span><span>;</span>
<span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span>i <span>&lt;</span> arr1<span>.</span>length<span>;</span>i<span>++</span><span>)</span><span>{</span>
    arr2<span>[</span>i<span>]</span> <span>=</span> arr1<span>[</span>i<span>]</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
<li>
<p>线性查找</p>
<div><pre><code><span>int</span> dest <span>=</span> <span>23</span><span>;</span>
<span>//boolean isFlag = true;</span>
<span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span>i <span>&lt;</span> arr2<span>.</span>length<span>;</span>i<span>++</span><span>)</span><span>{</span>
    <span>if</span><span>(</span>dest <span>==</span> arr2<span>[</span>i<span>]</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"地址值为"</span> <span>+</span> i<span>)</span><span>;</span>
        <span>//isFlag = false;</span>
        <span>break</span><span>;</span>
    <span>}</span>
<span>}</span>
<span>//if (isFlag)</span>
<span>//    System.out.println("未找到");</span>
<span>//第二种方法</span>
<span>if</span> <span>(</span>i <span>==</span> arr2<span>.</span>length<span>)</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"未找到"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div></li>
<li>
<p>说出数组的常见异常</p>
<ul>
<li>
<p><code>ArrayIndexOutOfBoundsException</code>: 数组角标越界异常</p>
<ul>
<li>
<p>合理范围：<code>[0, arr.length - 1]</code></p>
</li>
<li>
<p>越界：<code>arr[-1], arr[arr.length]</code></p>
</li>
</ul>
</li>
<li>
<p><code>NullPointerException</code>: 空指针异常</p>
<div><pre><code><span>int</span><span>[</span><span>]</span> arr <span>=</span> <span>null</span><span>;</span>
arr<span>[</span><span>0</span><span>]</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
</ul>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>JAVASE | 04JAVA类与面向对象</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/hungry/JAVASE_04JAVA%E7%B1%BB%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/hungry/JAVASE_04JAVA%E7%B1%BB%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">JAVASE | 04JAVA类与面向对象</source>
      <category>求知</category>
      <pubDate>Mon, 17 Jan 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="java-类与面向对象"> JAVA | 类与面向对象</h1>
<p>day8</p>
<p>对于任何的知识点我们都可以从这三个点去剖析： 3W =&gt; what? why? how?</p>
<h2 id="面向过程与面向对象"> 面向过程与面向对象</h2>
<h3 id="java面向对象学习的三条主线"> Java面向对象学习的三条主线</h3>
<ol>
<li><strong>Java类及类的成员</strong>
<ul>
<li><strong>属性、方法</strong>、<strong>构造器</strong>；<strong>代码块、内部类</strong></li>
</ul>
</li>
<li><strong>面向对象的三大特征</strong>
<ul>
<li><strong>封装性</strong>、<strong>继承性</strong>、<strong>多态性</strong></li>
</ul>
</li>
<li><strong>其他关键字</strong>
<ul>
<li><strong>this</strong>、<strong>super</strong>、<strong>static</strong>、<strong>final、abstract、interface</strong>、<strong>package、import</strong>等</li>
</ul>
</li>
</ol>
<h3 id="面向过程-pop-与面向对象-opp"> 面向过程（POP）与面向对象（OPP）</h3>
<ul>
<li>两者都是一种思想，面向对象是相对于面向过程而言的。面向过程，<strong>强调的是功能行为，以函数为最小单位，考虑怎么做</strong>。面向对象，<strong>将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做</strong></li>
<li>面向对象更加强调运用人类在日常的思维逻辑中采用的思想方法与原则，如抽象、分类、继承、聚合、多态等</li>
<li>面向过程：Procedure Oriented Programming</li>
<li>面向对象：Object Oriented Programming</li>
</ul>
<h3 id="面向对象的三大特征"> 面向对象的三大特征</h3>
<ul>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ul>
<h3 id="面向对象的思想概述"> 面向对象的思想概述</h3>
<ul>
<li>程序员从面向过程的<strong>执行者</strong>转化成了面向对象的指挥者</li>
<li>面向对象分析方法分析问题的思路和步骤
<ul>
<li>根据问题需要，选择问题所正对的现实世界中的实体</li>
<li>从实体中寻找解决问题相关的属性和国内，这些属性和功能就形成了<strong>概念世界中的类</strong></li>
<li>把抽象的实体用计算机语言进行描述，<strong>形成计算机世界中类的定义</strong>。即借助某种程序语言，把类构造成计算机能够识别和处理的数据结构</li>
<li>将<strong>类实例化成计算机世界中的对象</strong>。对象是计算机世界中解决问题的最终工具</li>
</ul>
</li>
</ul>
<h2 id="java语言的基本元素-类和对象"> java语言的基本元素：类和对象</h2>
<ul>
<li>类和对象是面向对象的核心概念
<ul>
<li>类是对一类事物的描述，是抽象的、概念上的定义</li>
<li>对象是实际存在的该类事物的每个个体，因而也称为实例（instance）</li>
</ul>
</li>
<li><strong>万事万物皆对象</strong></li>
</ul>
<ol>
<li>Java面向对象学习的三条主线
<ol>
<li>Java类及类的成员：属性、方法、构造器；代码块、内部类</li>
<li>面向对象的三大特征：封装性、继承性、多态性、[抽象性]</li>
<li>其他关键字：this、super、static、final、abstract、interface、package、import等</li>
</ol>
</li>
<li>&quot;人把大象装进冰箱&quot;的举例
<ol>
<li>
<p>面向过程，强调的是功能行为，以函数为最小单位，考虑怎么做</p>
<ul>
<li>把冰箱门打开</li>
<li>抬起大象，塞进冰箱</li>
<li>把冰箱门关闭</li>
</ul>
</li>
<li>
<p>面向对象强调具备了功能的对象，以类/对象为最小单位，考虑谁来做</p>
<div><pre><code>人<span>{</span>
    打开<span>(</span>冰箱<span>)</span><span>{</span>
        冰箱<span>.</span>打开<span>(</span><span>)</span><span>;</span>
    <span>}</span>
    抬起<span>(</span>大象<span>)</span><span>{</span>
        大象<span>.</span>进入<span>(</span>冰箱<span>)</span><span>;</span>
    <span>}</span>
    冰箱<span>(</span>冰箱<span>)</span><span>{</span>
        冰箱<span>.</span>闭合<span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
冰箱<span>{</span>
    打开<span>(</span><span>)</span><span>{</span><span>}</span>
    闭合<span>(</span><span>)</span><span>{</span><span>}</span>
<span>}</span>
大象<span>{</span>
    进入<span>(</span>冰箱<span>)</span><span>{</span><span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div></li>
</ol>
</li>
<li>面向对象的两个要素
<ul>
<li>类：是对一类事物的描述，是抽象的、概念上的定义</li>
<li>对象：是实际存在的该类事物的每个个体，因而也称为实例（instance）
<ul>
<li>面对对象程序设计的重点是类的设计</li>
<li>设计类，就是设计类的成员</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="设计类-就是设计类的成员"> 设计类，就是设计类的成员</h3>
<ul>
<li>
<p>定义</p>
<ul>
<li>属性 = 成员变量 = field = 域、字段</li>
<li>方法(行为) = 成员方法 = 函数 = method</li>
<li>创建类的对象 = 类的实例化 = 实例化类</li>
</ul>
</li>
<li>
<p>类和对象的使用（面向对象思想落地的实现）</p>
<ol>
<li>创建类，设计类的成员</li>
<li>创建类的对象</li>
<li>通过<code>对象.属性</code>或<code>对象.属性</code>的方式来调用对象的结构</li>
</ol>
</li>
<li>
<p>如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性（非static的）</p>
<ul>
<li>意味着，如果我们修改一个对象的属性a，则不影响</li>
</ul>
</li>
<li>
<p>对象的内存解析</p>
<p><img src="./images/04类与面向对象/image-20211108175311118.png" alt="image-20211108175311118" /></p>
<ul>
<li><strong>堆</strong>，此内存区域的为宜目的就是存放对象实例</li>
<li>通常所说的栈(stack)，是指<strong>虚拟机栈</strong>。虚拟机栈用于存储局部变量等</li>
<li>方法区(Method Area)，用于存储已被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码等数据</li>
</ul>
</li>
<li>
<p>对象的内存解析</p>
<div><pre><code><span>Person</span> p1 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span>
p1<span>.</span>name <span>=</span> <span>"Tom"</span><span>;</span>
p1<span>.</span>isMale <span>=</span> treue<span>;</span>
<span>Person</span> p2 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>p2<span>.</span>name<span>)</span><span>;</span><span>//null</span>
<span>Person</span> p3 <span>=</span> p1<span>;</span>
p3<span>.</span>age <span>=</span> <span>10</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><img src="./images/04类与面向对象/image-20211108181726637.png" alt="image-20211108181726637" /></p>
</li>
</ul>
<h2 id="类中属性的使用"> 类中属性的使用</h2>
<ul>
<li>属性(成员变量) vs 局部变量
<ol>
<li>相同点
<ol>
<li>定义变量的格式：数据类型 变量名 = 变量值</li>
<li>先声明，后使用</li>
<li>变量都有其对于的作用域，超过作用域范围都会失效</li>
</ol>
</li>
<li>不同点
<ol>
<li>在类中声明的位置不同
<ul>
<li>属性：直接定义在类的一对{}内</li>
<li>局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量</li>
</ul>
</li>
<li>关于权限修饰符的不同
<ul>
<li>属性：可以在声明属性时，指明其权限，使用权限修饰符
<ul>
<li>常用的权限修饰符：private、public、缺省(不写即缺省)、protected =&gt;（属于封装性的内容）</li>
<li>目前学习时，声明属性，使用缺省即可</li>
</ul>
</li>
<li>局部变量：不可以使用权限修饰符
5. 关于默认初始化的情况</li>
</ul>
</li>
</ol>
<ul>
<li>属性：类的属性，根据其类型，都有默认初始化值
<ul>
<li>整形(byte、short、int、long)，0</li>
<li>浮点型(float、double)，0.0</li>
<li>字符型(char)，0(或'\u0000')</li>
<li>布尔型(boolean)，false</li>
<li>引用数据类型(类、数组、接口)，null</li>
</ul>
</li>
<li>局部变量：没有默认初始化值
<ul>
<li>意味着，我们在调用局部变量之前，一定要显式赋值</li>
<li>特别的，形参在调用时，赋值即可</li>
</ul>
<ol start="6">
<li>在内存中加载的位置</li>
</ol>
</li>
<li>属性：加载到堆空间中（非static）</li>
<li>局部变量：加载到栈空间</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="类中方法的声明和使用"> 类中方法的声明和使用</h3>
<ul>
<li>
<p>方法：描述类应该具有的功能</p>
<ul>
<li>
<p>比如：</p>
<ul>
<li>Math类：sqrt(), random()...</li>
<li>Scanner类：nextXxx()...</li>
<li>Arrays类：sort(), binarySearch(), toString(), equals()...</li>
</ul>
</li>
<li>
<p>举例：</p>
<div><pre><code><span>public</span> <span>void</span> <span>eat</span><span>(</span><span>)</span><span>{</span><span>}</span>
<span>public</span> <span>void</span> <span>sleep</span><span>(</span><span>int</span> hour<span>)</span><span>{</span><span>}</span>
<span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span><span>{</span><span>}</span>
<span>public</span> <span>String</span> <span>getNation</span><span>(</span><span>String</span> nation<span>)</span><span>{</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
<li>
<p>方法的声明</p>
<div><pre><code>权限修饰符 返回值类型 方法名<span>(</span><span>[</span>形参列表<span>]</span><span>)</span><span>{</span>
    方法体<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>关于static、final、abstract修饰的方法，后面涉及</li>
</ul>
</li>
<li>
<p>说明</p>
<ol>
<li>关于权限修饰符: 默认方法的权限修饰符等详细讲解前，都使用public
<ul>
<li>java规定的4种权限修饰符：private、public、缺省、protected=&gt;（属于封装性的内容）</li>
</ul>
</li>
<li>返回值类型
<ul>
<li>有返回值 vs 无返回值
<ul>
<li>如果方法有返回值，则必须在方法声明时，指定返回值的类型。
<ul>
<li>需要使用return关键字来指定类型的变量或常量（数据）</li>
</ul>
</li>
<li>如果方法没有返回值，则方法声明时，使用void来表示
<ul>
<li>通常没有返回值的方法中，就不需要使用return，如果要使用，只能&quot;return;&quot;表示结束此方法的意思，且后面不可以声明表达式</li>
</ul>
</li>
</ul>
</li>
<li>定义方法时该不该有返回值
<ul>
<li>看题目要求</li>
<li>凭经验，具体问题具体分析</li>
</ul>
</li>
</ul>
</li>
<li>方法名：属于标识符，遵循标识符的规则和规范**【见名知意】**</li>
<li>形参列表：方法可以声明0个，1个或多个对象
<ul>
<li>格式：<code>数据类型1 形参1, 数据类型2 形参2, ...</code></li>
<li>定义方法时，该不该定义形参？
<ul>
<li>看题目要求</li>
<li>凭经验，具体问题具体分析</li>
</ul>
</li>
</ul>
</li>
<li>方法体：方法功能的体现</li>
</ol>
</li>
</ul>
</li>
<li>
<p>return关键字的使用</p>
<ul>
<li>使用返回：使用在方法体中</li>
<li>作用：
<ul>
<li>结束方法</li>
<li>针对于有返回值类型的方法，使用<code>return 数据</code>方法返回所要的数据</li>
<li>注意点：return关键字后面不能声明执行语句</li>
</ul>
</li>
</ul>
</li>
<li>
<p>方法的使用中，可以调用当前类的属性或方法(方法内部可以调用方法</p>
<ul>
<li>特殊的，方法A中又调用了方法A：递归方法</li>
<li>方法中，不可以定义方法（public方法中套public方法）</li>
</ul>
</li>
<li>
<p>方法的分类：按照是否有形参及返回值</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>无返回值</th>
<th>有返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>无形参</td>
<td>void 方法名(){}</td>
<td>返回值的类型 方法名(){}</td>
</tr>
<tr>
<td>有形参</td>
<td>void 发放名(形参列表){}</td>
<td>返回值的类型 方法名(形参列表){}</td>
</tr>
</tbody>
</table>
<h3 id="匿名对象的使用"> 匿名对象的使用</h3>
<ol>
<li>
<p>理解，创建的对象，没有显式的赋给一个变量名，即为匿名对象</p>
</li>
<li>
<p>特征，匿名对象只能调用一次</p>
</li>
<li>
<p>使用</p>
<div><pre><code><span>public</span> <span>class</span> <span>InstanceTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Phone</span> p <span>=</span> <span>new</span> <span>Phone</span><span>(</span><span>)</span><span>;</span>
        <span>// p = null;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>p<span>)</span><span>;</span>
        p<span>.</span><span>sendEmail</span><span>(</span><span>)</span><span>;</span>
        p<span>.</span><span>playGame</span><span>(</span><span>)</span><span>;</span>
        <span>//匿名对象</span>
        <span>// new Phone().sendEmail();</span>
        <span>// new Phone().playGame();</span>

        <span>new</span> <span>Phone</span><span>(</span><span>)</span><span>.</span>price <span>=</span> <span>1999</span><span>;</span>
        <span>new</span> <span>Phone</span><span>(</span><span>)</span><span>.</span><span>showPrice</span><span>(</span><span>)</span><span>;</span><span>//0.0</span>

        <span>//-----------------------</span>
        <span>PhoneMall</span> mall <span>=</span> <span>new</span> <span>PhoneMall</span><span>(</span><span>)</span><span>;</span>
        <span>//mall.show(p);</span>
        <span>//匿名对象的使用，一般s</span>
        mall<span>.</span><span>show</span><span>(</span><span>new</span> <span>Phone</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
<span>class</span> <span>PhoneMall</span><span>{</span>
    <span>public</span> <span>void</span> <span>show</span><span>(</span><span>Phone</span> phone<span>)</span><span>{</span>
        phone<span>.</span><span>sendEmail</span><span>(</span><span>)</span><span>;</span>
        phone<span>.</span><span>playGame</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
<span>class</span> <span>Phone</span><span>{</span>
    <span>double</span> price<span>;</span><span>//价格</span>
    <span>public</span> <span>void</span> <span>sendEmail</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"发送邮件"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>playGame</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"玩游戏"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>showPrice</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"手机价格为："</span> <span>+</span> price<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div></li>
</ol>
<h3 id="考察"> 考察</h3>
<p>面向对象的编程思想（类、对象：三大特征...）万事万物皆对象</p>
<ol>
<li>
<p>面对对象思想编程内容的三条主线分别是什么</p>
<ul>
<li>类及类的成员：属性、方法、构造器、代码块、内部类</li>
<li>面向对象的三大特征：封装、继承、多态</li>
<li>其他关键字：this, super, abstract, interface, static, final, package, import</li>
</ul>
</li>
<li>
<p>谈谈你对面向对象中类和对象的理解，并指出二者的关系</p>
<ul>
<li>类：抽象的、概念上的内容</li>
<li>对象：实实在在存在的一个个体</li>
<li>二者的关系
<ul>
<li>对象是由类派生出来的</li>
</ul>
</li>
</ul>
</li>
<li>
<p>面向对象思想的体现：类和对象的创建和执行操作有哪三步</p>
<ol>
<li>创建类</li>
<li>类的实例化</li>
<li>调用对象的结构：&quot;对象.属性&quot;, &quot;对象.方法&quot;</li>
</ol>
</li>
<li>
<p>内存分配情况</p>
<p><img src="./images/04类与面向对象/image-20211109200655236.png" alt="image-20211109200655236" /></p>
</li>
<li>
<p>类的方法内是否可以定义变量？是否可以调用属性？是否可以定义方法？是否可以调用方法？</p>
<ul>
<li>类的方法内可以定义变量，可以调用属性，不可以定义方法，可以调用方法</li>
</ul>
</li>
</ol>
<p>day09</p>
<h2 id="理解-万事万物皆对象"> 理解“万事万物皆对象”</h2>
<ol>
<li>在java语言范畴中，我们都将概念、结构等封装到类中，通过类的实例化，来调用具体的功能结构
<ul>
<li>Scanner, String等</li>
<li>文件，File</li>
<li>网络资源，URl</li>
</ul>
</li>
<li>涉及到java语言与前端Html、后端的数据库交互时，前后端的结构在java层面交互时，都体现为类、对象</li>
</ol>
<h3 id="再谈方法"> 再谈方法</h3>
<ul>
<li>方法的重载</li>
<li>可变形参的方法</li>
<li>⭐方法参数的值传递机制</li>
<li>递归方法</li>
</ul>
<h4 id="方法的重载-overload"> 方法的重载（overload）</h4>
<ul>
<li>概念
<ul>
<li>
<p><strong>重载的概念</strong></p>
</li>
<li>
<p>在同一个类中，允许存在一个以上的同名方法，只要他们的参数个数或参数类型不同即可</p>
</li>
<li>
<p><strong>重载的特点</strong></p>
</li>
<li>
<p>与返回值类型无关，只看参数列表，且参数列表必须不同（参数个数或参数类型）。调用时，根据方法参数列表的不同来区别</p>
</li>
<li>
<p><strong>重载示例</strong></p>
<div><pre><code><span>//返回两个整数的和</span>
<span>int</span> <span>add</span><span>(</span><span>int</span> x<span>,</span><span>int</span> y<span>)</span><span>{</span><span>return</span> x<span>+</span>y<span>;</span><span>}</span>
<span>//返回三个整数的和</span>
<span>int</span> <span>add</span><span>(</span><span>int</span> x<span>,</span><span>int</span> y<span>,</span><span>int</span> z<span>)</span><span>{</span><span>return</span> x<span>+</span>y<span>+</span>z<span>;</span><span>}</span>
<span>//返回两个小数的和</span>
<span>double</span> <span>add</span><span>(</span><span>double</span> x<span>,</span><span>double</span> y<span>)</span><span>{</span><span>return</span> x<span>+</span>y<span>;</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
</ul>
</li>
</ul>
<ol>
<li>定义：在同一个类中，允许存在一个以上的同名方法，只要他们的参数个数或参数类型不同即可
<ul>
<li>两同一不同
<ul>
<li>同一个类，相同方法名</li>
<li>参数列表不同
<ul>
<li>参数个数</li>
<li>参数类型不同</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>举例：Arrays类中重载的sort() / binarySearch()</li>
<li>判断是否是重载
<ul>
<li>个方法的<strong>权限修饰符、返回值类型、形参变量名、方法体</strong>都没有关系</li>
</ul>
</li>
<li>在通过对象调用方法时，如何确定某一个指定的方法
<ul>
<li><strong>先看 <code>方法名</code> 同时再看 <code>参数列表</code></strong></li>
</ul>
</li>
</ol>
<div><pre><code><span>public</span> <span>class</span> <span>OverLoadTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>OverLoadTest</span> test <span>=</span> <span>new</span> <span>OverLoadTest</span><span>(</span><span>)</span><span>;</span>
        <span>//默认匹配1，如果将1注释掉，就会将int匹配double输出2</span>
        test<span>.</span><span>getsum</span><span>(</span><span>1</span><span>,</span><span>2</span><span>)</span><span>;</span>
        test<span>.</span><span>getsum</span><span>(</span><span>1.1</span><span>,</span><span>2.2</span><span>)</span><span>;</span>
    <span>}</span>
    <span>//如下的两个同名方法构成了重载</span>
    <span>public</span> <span>void</span> <span>getsum</span><span>(</span><span>int</span> i<span>,</span><span>int</span> j<span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>1</span><span>)</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>getsum</span><span>(</span><span>double</span> d1<span>,</span><span>double</span> d2<span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>2</span><span>)</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>getsum</span><span>(</span><span>String</span> s<span>,</span> <span>int</span> i<span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>3</span><span>)</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>getsum</span><span>(</span><span>int</span> i<span>,</span><span>String</span> s<span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>4</span><span>)</span><span>;</span>
    <span>}</span>
    <span>//不允许重复的重载</span>
    <span>// public void getsum(int i,int j){</span>
    <span>//     return 0;</span>
    <span>// }</span>
    <span>//即使参数名不同但类型相同也不行，返回的类型也不影响</span>
    <span>// public int getsum(int m,int n){</span>
    <span>//</span>
    <span>// }</span>
    <span>//权限不同也不行</span>
    <span>// private void getsum(int i,int j){</span>
    <span>//</span>
    <span>// }</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><ul>
<li>使用重载方法，可以为编程带来方便，实际上我们调用System.out.println()方法，其内部也是有许多写好的重载
<img src="./images/04类与面向对象/image-20211113155029579.png" alt="image-20211113155029579" /></li>
<li>练习
<img src="./images/04类与面向对象/image-20211113160736096.png" alt="image-20211113160736096" /></li>
</ul>
<h3 id="可变个数的形参"> 可变个数的形参</h3>
<ul>
<li>
<p>概念</p>
<ul>
<li>
<p>javaSE 5.0中提供了Varargs机制， 允许直接定义能和多个实参相匹配的形参。从而可以用一种更简单的方式，来传递个数可变的实参</p>
</li>
<li>
<p>jdk5.0之前</p>
<div><pre><code><span>public</span> <span>void</span> <span>show</span><span>(</span><span>String</span> <span>.</span><span>.</span><span>.</span> strs<span>)</span><span>{</span><span>}</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>jdk5.0之后</p>
<div><pre><code><span>public</span> <span>void</span> <span>show</span><span>(</span><span>String</span><span>[</span><span>]</span> strs<span>)</span><span>{</span><span>}</span>
</code></pre>
<div><span>1</span><br></div></div></li>
</ul>
</li>
</ul>
<ol>
<li>jdk 5.0新增的内容</li>
<li>具体的使用
<ul>
<li>可变个数形参的格式：<code>数据类型 ... 变量名</code></li>
<li>当调用可变个数形参的方法时，传入的参数个数可以时：0个，1个，2个...</li>
<li>可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载</li>
<li>可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重构，换句话说两者之间不能共存</li>
<li>可变个数形参在方法的形参中，必须声明在末尾</li>
<li>可变个数形参在方法的形参中，最多只能声明一个可变形参</li>
</ul>
</li>
</ol>
<div><pre><code><span>public</span> <span>class</span> <span>MethodArgsTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>MethodArgsTest</span> test <span>=</span> <span>new</span> <span>MethodArgsTest</span><span>(</span><span>)</span><span>;</span>
        test<span>.</span><span>show</span><span>(</span><span>1</span><span>)</span><span>;</span><span>//int i</span>
        <span>// test.show("hello");//String ... strs</span>
        <span>// test.show("hello",  "world");//String ... strs</span>
        <span>// test.show();//String ... strs</span>

        <span>//jdk5.0之后（可兼容下面两种方法）</span>
        test<span>.</span><span>show</span><span>(</span><span>"AA"</span><span>,</span><span>"BB"</span><span>,</span><span>"CC"</span><span>)</span><span>;</span>
        <span>//jdk5.0之前（只可以使用下面这种方法）</span>
        <span>// test.show(new String[]{"AA","BB","CC"});</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>show</span><span>(</span><span>int</span> i<span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"int i"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>// public void show(String s){</span>
    <span>//     System.out.println("String s");</span>
    <span>// }</span>
    <span>//jdk5.0之后：可变个数形参</span>
    <span>public</span> <span>void</span> <span>show</span><span>(</span><span>String</span> <span>.</span><span>.</span><span>.</span> strs<span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"String ... strs"</span><span>)</span><span>;</span>
        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span>i <span>&lt;</span> strs<span>.</span>length<span>;</span>i<span>++</span><span>)</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>strs<span>[</span>i<span>]</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>//jdk5.0之前：可变个数形参</span>
    <span>// public void show(String[] strs){</span>
    <span>//     System.out.println("String[] strs");</span>
    <span>//     for(int i = 0;i &lt; strs.length;i++){</span>
    <span>//         System.out.println(strs[i]);</span>
    <span>//     }</span>
    <span>// }</span>
    <span>//---------------------</span>
    <span>//可变个数形参不能写在前面</span>
    <span>//报错信息：The variable argument type String of the method</span>
    <span>//报错信息：show must be the last parameter</span>
    <span>// public void show(String ...strs,int i){</span>
    <span>//</span>
    <span>// }</span>
    <span>//可变个数形参只能写在末尾</span>
    <span>// public void show(int i, String ...strs){</span>
    <span>//</span>
    <span>// }</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><h3 id="⭐方法参数的值传递机制"> ⭐方法参数的值传递机制</h3>
<ul>
<li>
<p>概念</p>
<ul>
<li>
<p>方法：必须由其所在类或对象调用才有意义。若方法含有参数</p>
</li>
<li>
<p>形参：方法声明时的参数</p>
</li>
<li>
<p>实参：方法调用时实际传给新参的参数值</p>
</li>
<li>
<p>java的实参值如何传入方法呢？</p>
<p>java内方法的参数传递方法只有一种：值传递。即将实际参数值的副本（复制品）传入方法内，而参数本身不受影响</p>
<ul>
<li>形参时基本数据类型，将实参基本数据类型变量的”数据值“传递给形参</li>
<li>形参时引用数据类型，将实参引用数据类型变量的”地址值“传递给形参</li>
</ul>
</li>
</ul>
</li>
<li>
<p>JAVA中方法参数的值传递机制</p>
<ul>
<li>如果变量时<strong>基本数据类型</strong>，此时赋值的是<strong>变量所保存的数据值</strong></li>
<li>如果变量时<strong>引用数据类型</strong>，此时赋值的是<strong>变量所保存的数据的地址值</strong></li>
</ul>
</li>
</ul>
<ol>
<li>形参与实参
<ul>
<li>形参：方法定义时，声明的小括号内的参数</li>
<li>实参：方法调用时，实际传递给形参的数据</li>
</ul>
</li>
<li>值传递机制
<ul>
<li>如果参数是基本数据类型，此时实参赋值给形参的是，实参真实存储的数据值</li>
<li>如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值</li>
</ul>
</li>
</ol>
<h3 id="练习"> 练习</h3>
<h4 id="方法参数值传递机制的例题与图解"> 方法参数值传递机制的例题与图解</h4>
<p><img src="./images/04类与面向对象/image-20211115201312827.png" alt="image-20211115201312827" /></p>
<ul>
<li>方法的参数传递
<img src="./images/04类与面向对象/image-20211115201650535.png" alt="image-20211115201650535" />
<ul>
<li>此题中有个坑，就是他在method中操作的是形参而非实参，所以照他程序输出只会输出两个10，而非题目所要的100 200，所以这里有两个思路
<ul>
<li>在method里面输出a和b指定的值，然后提前将程序结束<code>System.exit(0)</code></li>
<li>在method中重写println函数，这里涉及到后面的知识</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="数组的计算"> 数组的计算</h4>
<p><img src="./images/04类与面向对象/image-20211115202015729.png" alt="image-20211115202015729" /></p>
<ul>
<li>这里也有个坑，如果是按照左边的方式进行计算就会得到错误，因为如果从头开始计算（12），则后面的数使用的除数就会发生变化（1），从而得到错误的答案，这里给出两个解决方案
<ul>
<li>从最后一个数开始计算，直到第一个，第一个数变化了也代表程序结束了，所以不会导致逻辑错误</li>
<li>创建一个新的变量存储一开始的第一个值，然后重复的计算（缺点是需要额外开辟一个空间存储新的变量）</li>
</ul>
</li>
</ul>
<h4 id="关于char型数组的输出"> 关于char型数组的输出</h4>
<ul>
<li>这里有个坑是char型输出的不是地址值，而是字符abc，因为在<code>println</code>的重载函数中针对char的方法体是<strong>遍历这个数组</strong>，而非输出地址值</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>ArrayPrintTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>int</span><span>[</span><span>]</span> arr <span>=</span> <span>new</span> <span>int</span><span>[</span><span>]</span><span>{</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>}</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr<span>)</span><span>;</span><span>//地址值</span>

        <span>char</span><span>[</span><span>]</span> arr1 <span>=</span> <span>new</span> <span>char</span><span>[</span><span>]</span><span>{</span><span>'a'</span><span>,</span><span>'b'</span><span>,</span><span>'c'</span><span>}</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr1<span>)</span><span>;</span><span>//abc</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h4 id="将对象作为参数传递给方法"> 将对象作为参数传递给方法</h4>
<ul>
<li>考察参数的值传递</li>
<li>定义一个Circle类，包含一个double型的radius属性代表圆的半径
一个findArea()方法返回圆的面积</li>
<li>定义一个类 PassObject,在类中定义一个方法 printAreas()，该方法的定义如下： public void printAreas(Circle c, int time)
在 printareas方法中打印输出1到time之间的每个整数半径值，以及对应的面积
例如， times为5,则输出半径1,2,3,4,5,以及对应的圆面积。</li>
<li>在main中调用printAreas()方法，调用完后输出当前半径值</li>
</ul>
<div><pre><code><span>//Circle.java</span>
<span>public</span> <span>class</span> <span>Circle</span> <span>{</span>
    <span>double</span> radius<span>;</span><span>//半径</span>
    <span>//求圆的面积</span>
    <span>public</span> <span>double</span> <span>findArea</span><span>(</span><span>)</span><span>{</span>
        <span>return</span> <span>Math</span><span>.</span>PI <span>*</span> radius <span>*</span> radius<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code><span>//PassObject.java</span>
<span>class</span> <span>PassObject</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>PassObject</span> test <span>=</span> <span>new</span> <span>PassObject</span><span>(</span><span>)</span><span>;</span>
        <span>Circle</span> c <span>=</span> <span>new</span> <span>Circle</span><span>(</span><span>)</span><span>;</span>
        test<span>.</span><span>printAreas</span><span>(</span>c<span>,</span> <span>5</span><span>)</span><span>;</span>
        <span>//快捷写法</span>
        <span>//test.printAreas(new Circle, 5)</span>

        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"now radius is "</span> <span>+</span> c<span>.</span>radius<span>)</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>printAreas</span><span>(</span><span>Circle</span> c<span>,</span> <span>int</span> time<span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Radius\t\tArea"</span><span>)</span><span>;</span>

        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span>i <span>&lt;=</span> time<span>;</span>i<span>++</span><span>)</span><span>{</span>
            <span>//设置圆的半径</span>
            c<span>.</span>radius <span>=</span> i<span>;</span>
            <span>//友好写法</span>
            <span>double</span> area <span>=</span> c<span>.</span><span>findArea</span><span>(</span><span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>c<span>.</span>radius <span>+</span> <span>"\t\t"</span> <span>+</span> area<span>)</span><span>;</span>

            <span>//快捷写法</span>
            <span>//System.out.println(c.radius + "\t\t" + c.findArea());</span>
        <span>}</span>
        c<span>.</span>radius <span>=</span> time <span>+</span> <span>1</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h3 id="递归方法"> 递归方法</h3>
<ul>
<li>
<p>概念</p>
<ul>
<li>
<p>递归方法：<strong>一个方法体内部调用他自身</strong></p>
</li>
<li>
<p>方法递归包含了一种隐式的循环，他会重复执行某段代码，但这种重复指向无需循环控制</p>
</li>
<li>
<p>递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环</p>
</li>
<li>
<p>例题</p>
<div><pre><code><span>//计算1-100之间所有自然数的和</span>
<span>public</span> <span>int</span> <span>sum</span><span>(</span><span>int</span> num<span>)</span><span>{</span>
    <span>if</span><span>(</span>num <span>==</span> <span>1</span><span>)</span><span>{</span>
        <span>return</span> <span>1</span><span>;</span>
    <span>}</span><span>else</span><span>{</span>
        <span>return</span> num <span>+</span> <span>sum</span><span>(</span>num <span>-</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></li>
</ul>
</li>
<li>
<p>递归方法的使用与了解</p>
</li>
</ul>
<div><pre><code><span>/*
## 递归方法的使用（了解）
1. 递归方法：一个方法体内部调用他自身
2. 方法递归包含了一种隐式的循环，他会重复执行某段代码，但这种重复指向无需循环控制
- 递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环
 */</span>
<span>public</span> <span>class</span> <span>RecursionTest</span> <span>{</span>
    <span>// 例1：计算1-100之间所有自然数的和</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>//方式一：for循环计算</span>
        <span>int</span> sum <span>=</span> <span>0</span><span>;</span>
        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span>i <span>&lt;=</span> <span>100</span><span>;</span>i<span>++</span><span>)</span><span>{</span>
            sum <span>+=</span> i<span>;</span>
        <span>}</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>sum<span>)</span><span>;</span>

        <span>//方式二：递归方法</span>
        <span>RecursionTest</span> test <span>=</span> <span>new</span> <span>RecursionTest</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> sum1 <span>=</span> test<span>.</span><span>getsum</span><span>(</span><span>100</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>sum1<span>)</span><span>;</span>

        <span>//例2求乘积, 若此处数字大，会导致结果溢出！</span>
        <span>int</span> sum2 <span>=</span> test<span>.</span><span>getsum1</span><span>(</span><span>5</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>sum2<span>)</span><span>;</span>

        <span>//例3</span>
        <span>int</span> value <span>=</span> test<span>.</span><span>f</span><span>(</span><span>10</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>value<span>)</span><span>;</span>
    <span>}</span>
    <span>//方式二：递归方法</span>
    <span>public</span> <span>int</span> <span>getsum</span><span>(</span><span>int</span> num<span>)</span><span>{</span>
        <span>if</span><span>(</span>num <span>==</span> <span>1</span><span>)</span><span>{</span>
            <span>return</span> <span>1</span><span>;</span>
        <span>}</span><span>else</span><span>{</span>
            <span>return</span> num <span>+</span> <span>getsum</span><span>(</span>num <span>-</span> <span>1</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>// 例2：计算1-100之间所有自然数的乘积:n!</span>
    <span>public</span> <span>int</span> <span>getsum1</span><span>(</span><span>int</span> num<span>)</span><span>{</span>
        <span>if</span><span>(</span>num <span>==</span> <span>1</span><span>)</span><span>{</span>
            <span>return</span> <span>1</span><span>;</span>
        <span>}</span><span>else</span><span>{</span>
            <span>return</span> num <span>*</span> <span>getsum1</span><span>(</span>num <span>-</span> <span>1</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>//例3：已知有一个数列：f(0) = 1,f(1) = 4, f(n+2)=2*f(n+1) + f(n)</span>
    <span>//其中n是大于0的整数，求f(10)的值</span>
    <span>public</span> <span>int</span> <span>f</span><span>(</span><span>int</span> n<span>)</span><span>{</span>
        <span>if</span><span>(</span>n <span>==</span> <span>0</span><span>)</span><span>{</span>
            <span>return</span> <span>1</span><span>;</span>
        <span>}</span><span>else</span> <span>if</span><span>(</span>n <span>==</span> <span>1</span><span>)</span><span>{</span>
            <span>return</span> <span>4</span><span>;</span>
        <span>}</span><span>else</span><span>{</span>
            <span>// 如果直接调用f(n+2)=2*f(n+1) + f(n)，就会栈溢出</span>
            <span>// 因为在f(n+2)中永远会往上升导致要求的数是无穷的</span>
            <span>// 所以这里应该把+2放到右边</span>
            <span>return</span> <span>2</span> <span>*</span> <span>f</span><span>(</span>n <span>-</span> <span>1</span><span>)</span> <span>+</span> <span>f</span><span>(</span>n <span>-</span> <span>2</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>//例4，斐波那契数列，第一个数是1，后面的一个数等于前两个数之和</span>
    <span>//1 1 2 3 5 8 13 21 34 55</span>

    <span>//例5，汉诺塔问题</span>

    <span>//例6，快排</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br></div></div><h3 id="考察-2"> 考察</h3>
<ol>
<li>
<p>什么是方法的重载</p>
<ul>
<li>
<p>定义：在同一个类中，允许存在一个以上的同名方法，只要他们的参数个数或者参数类型不同即可</p>
</li>
<li>
<p><strong>两同一不同</strong></p>
<ul>
<li>
<p>同一个类、相同方法名</p>
</li>
<li>
<p>参数列表不同</p>
</li>
</ul>
</li>
<li>
<p>如何调用确定的方法：<strong>先看 <code>方法名</code> 同时再看 <code>参数列表</code></strong></p>
</li>
</ul>
</li>
<li>
<p>说明Java方法中的参数传递机制的具体体现</p>
<ul>
<li>
<p>基本数据类型：数据值</p>
</li>
<li>
<p>引用数据类型：地址值（包含变量的<strong>数据类型</strong>）</p>
<div><pre><code><span>Person</span> p1 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span>
<span>User</span> u1 <span>=</span> p1<span>;</span><span>//编译错误 类型不一致</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
</ul>
</li>
<li>
<p>成员变量和局部变量在声明的位置是？是否有默认初始化值？是否能有权限修饰符修饰？内存分配的位置上有何不同？</p>
</li>
<li>
<p>谈谈return关键字的使用</p>
<ol>
<li>结束方法</li>
<li>针对于有返回值的方法，return+返回数据</li>
</ol>
</li>
<li>
<p>代码的内存解析</p>
<p><img src="./images/04类与面向对象/image-20211115201312827.png" alt="image-20211115201312827" /></p>
</li>
</ol>
<ul>
<li>
<p>需要熟知</p>
<ul>
<li>内存结构：栈（局部变量）、堆（new出来的结构：对象（成员变量）、数组）</li>
<li>变量：成员变量与局部变量（方法内、方法形参、构造器内、构造器形参、代码块内）</li>
</ul>
</li>
</ul>
<p>day10</p>
<h2 id="面向对象特征之一-封装与隐藏-封装性"> 面向对象特征之一：封装与隐藏（封装性）</h2>
<ul>
<li>
<p>为什么需要封装？封装的作用和含义</p>
<ul>
<li>对于外部人员来说，不需要知道内部的逻辑是如何运行的即可使用，就好比开车不需要知道汽车发动机是如何运行的原理那样</li>
</ul>
</li>
<li>
<p>程序设计追求<strong>高内聚，低耦合</strong></p>
<ul>
<li>高内聚：类的内部数据操作细节自己完成，不允许外部干涉</li>
<li>低耦合：仅对外暴露少量的方法用于使用</li>
</ul>
</li>
<li>
<p>隐藏对象内部的复杂性，之对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，<strong>把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想</strong></p>
</li>
<li>
<p>问题的引入</p>
</li>
</ul>
<ol>
<li>
<p>针对于属性体现封装性</p>
<ul>
<li>
<p>当我们创建一个类的对象以后，我们可以通过<code>对象.属性</code>的方式，对对象的属性进行赋值。这里的赋值操作要受到属性的数据类型和存储范围的制约。但除此之外，没有其他的制约条件。</p>
<ul>
<li>但在实际中问题中，加入额外的限制条件。这个条件就不能在属性声明时体现。只能通过方法进行条件的添加。
<ul>
<li>例如下面Animal类中的<code>setLegs()</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>同时，我们需要避免用户再次使用<code>对象.属性</code>的方式，对对象的属性进行赋值。则需要将属性声明为私有的(private)</p>
</li>
</ul>
<div><pre><code><span>class</span> <span>Animal</span><span>{</span>
    <span>String</span> name<span>;</span>
    <span>int</span> age<span>;</span>
    <span>//如果是默认则可以通过外部直接赋值，所以如果要外部不能直接赋值则需要修改其权限修饰符</span>
    <span>// int legs;//腿的个数</span>
    <span>private</span> <span>int</span> legs<span>;</span>

    <span>public</span> <span>void</span> <span>setLegs</span><span>(</span><span>int</span> l<span>)</span><span>{</span>
        <span>//正整数且是偶数</span>
        <span>if</span><span>(</span>l <span>>=</span> <span>0</span> <span>&amp;&amp;</span> l <span>%</span> <span>2</span> <span>==</span><span>0</span><span>)</span><span>{</span>
            legs <span>=</span> l<span>;</span>
        <span>}</span><span>else</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"输入有误！"</span><span>)</span><span>;</span>
            legs <span>=</span> <span>0</span><span>;</span>
            <span>//抛出异常（后期内容）</span>
        <span>}</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>eat</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"动物进食"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>show</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"name = "</span> <span>+</span> name <span>+</span> <span>",age = "</span> <span>+</span> age <span>+</span> <span>",legs = "</span> <span>+</span> legs<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div></li>
<li>
<p>封装性的体现</p>
<ul>
<li>我们将属性xxx私有化(private)，同时提供公共(public)的方法来获取(getXxx)和设置(setXxx)此属性的值</li>
<li>拓展：封装性的体现
<ol>
<li>如上</li>
<li>不对外暴露的私有方法</li>
<li>单例模式
...</li>
</ol>
</li>
</ul>
</li>
<li>
<p>封装性的体现，需要权限修饰符来配合</p>
<ol>
<li>
<p>java规定的4中权限（从小到大）：<code>private、缺省(default)、protected、public</code></p>
<ul>
<li>java权限修饰符置于类的成员定义前，用来限定对象对该类成员的访问权限</li>
</ul>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>类内部</th>
<th>同一个包</th>
<th>不同包的子类</th>
<th>同一个工程</th>
</tr>
</thead>
<tbody>
<tr>
<td>private</td>
<td>yes</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>（缺省）</td>
<td>yes</td>
<td>yes</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
</tbody>
</table>
<ul>
<li>对于class的权限修饰符只可以用public和default（缺省）</li>
<li>public类可以在任意地方被访问</li>
<li>default类只可以被同一包内部的类访问</li>
</ul>
</li>
<li>
<p>4中权限可以用来修饰类及类的内部结构：属性、方法、构造器、内部类</p>
</li>
<li>
<p>具体的，4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类</p>
<ul>
<li>修饰类只能使用：缺省、public
<ul>
<li>如果要解释的话，因为在外部的类中，如果private了，那就没人可以调用它</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>这里只讲述: private、缺省、public这三种权限的区别，关于protected得后面继承的学习之后再讲述</li>
<li>这里 private、缺省、public 关于权限的使用，可参考<code>OrderTest</code>包中<code>Order</code>与<code>OrderTest</code>，<code>OrderTest1</code>包中<code>OrderTest</code>这三者的使用
<ul>
<li><code>OrderTest</code>包中
<ul>
<li><code>Order</code>：可使用<code>private、缺省、public</code></li>
<li><code>OrderTest</code>：可使用<code>缺省、public</code></li>
</ul>
</li>
<li><code>OrderTest1</code>包中
<ul>
<li><code>OrderTest</code>：可使用<code>public</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="封装性的总结"> 封装性的总结</h3>
<ul>
<li>java提供了4种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性大小
<img src="./images/04类与面向对象/image-20211120135307382.png" alt="image-20211120135307382" /></li>
</ul>
<h3 id="练习-2"> 练习</h3>
<ol>
<li>
<p>创建程序，在其中定义两个类： Person和 PersonTest类。定义如下：用 setAge()设置人的合法年龄(0~130),用 getAge()返回人的年龄。在 PersonTest类中实例化 Person类的对象b,调用 setAge()和getAge()方法，体会Java的封装性。</p>
<p><img src="./images/04类与面向对象/image-20211120140027664.png" alt="image-20211120140027664" /></p>
<div><pre><code><span>//Person.java</span>
<span>package</span> <span>day10<span>.</span>exer</span><span>;</span>
<span>/*
创建程序，在其中定义两个类： Person和 PersonTest类。
定义如下：用 setAge()设置人的合法年龄(0~130),用 getAge()返回人的年龄。
在 PersonTest类中实例化 Person类的对象b,调用 setAge()和getAge()方法，体会Java的封装性。
 */</span>
<span>public</span> <span>class</span> <span>Person</span> <span>{</span>
    <span>private</span> <span>int</span> age<span>;</span>

    <span>public</span> <span>void</span> <span>setAge</span><span>(</span><span>int</span> a<span>)</span><span>{</span>
        <span>if</span><span>(</span>a <span>&lt;</span> <span>0</span> <span>||</span> a <span>></span> <span>130</span><span>)</span><span>{</span>
            <span>//后期的抛出异常写法</span>
            <span>// throw new RuntimeException("传入的数据非法！");</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"传入的数据非法！"</span><span>)</span><span>;</span>
            <span>return</span><span>;</span><span>//return用于结束方法</span>
        <span>}</span>
        age <span>=</span> a<span>;</span>

    <span>}</span>
    <span>public</span> <span>int</span> <span>getAge</span><span>(</span><span>)</span><span>{</span>
        <span>return</span> age<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><div><pre><code><span>//PersonTest.java</span>
<span>package</span> <span>day10<span>.</span>exer</span><span>;</span>
<span>/*
在 PersonTest类中实例化 Person类的对象b,调用 setAge()和getAge()方法，体会Java的封装性。

 */</span>
<span>public</span> <span>class</span> <span>PersonTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Person</span> p1 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span>
        <span>// p1.age = 1;//编译不通过</span>
        p1<span>.</span><span>setAge</span><span>(</span><span>12</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"年龄为："</span> <span>+</span> p1<span>.</span><span>getAge</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div></li>
</ol>
<h2 id="类的成员之三-构造器-或构造方法"> 类的成员之三：构造器（或构造方法）</h2>
<p>如果没有显式的定义类的构造器的话，默认系统会提供一个无参的构造器，其权限是开头声明的权限</p>
<ul>
<li>构造器 或构造方法(constructor)
<ul>
<li>construct: 建设、建造</li>
<li>construction: CCB（建行）</li>
<li>constructor: 建设者</li>
</ul>
</li>
</ul>
<ol>
<li>构造器的作用
<ul>
<li>创建对象</li>
<li>初始化对象的属性（信息）</li>
</ul>
</li>
<li>说明
<ul>
<li>如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器</li>
<li>定义构造器的格式：权限修饰符 类名(形参列表){...}</li>
<li>一个类中定义的多个构造器，彼此构成重载</li>
<li>一旦显式的定义了类的构造器之后，系统就不再提供默认的空参构造器</li>
<li>一个类中，至少会有一个构造器</li>
</ul>
</li>
</ol>
<ul>
<li>方法与构造器的区别：方法是有了对象，通过对象去调用这个方法，而构造器是用来创建对象的</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>PersonTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>//创建类的对象: new + 构造器;</span>
        <span>Person</span> p <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span>
        p<span>.</span><span>eat</span><span>(</span><span>)</span><span>;</span>

        <span>Person</span> p1 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>"Tom"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>p1<span>.</span>name<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>class</span> <span>Person</span><span>{</span>
    <span>//属性</span>
    <span>String</span> name<span>;</span>
    <span>int</span> age<span>;</span>

    <span>//构造器</span>
    <span>public</span> <span>Person</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Person()..."</span><span>)</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>Person</span><span>(</span><span>String</span> n<span>)</span><span>{</span>
        name <span>=</span> n<span>;</span>
    <span>}</span>
    <span>public</span> <span>Person</span><span>(</span><span>String</span> n<span>,</span> <span>int</span> a<span>)</span><span>{</span>
        name <span>=</span> n<span>;</span>
        age <span>=</span> a<span>;</span>
    <span>}</span>

    <span>//方法</span>
    <span>public</span> <span>void</span> <span>eat</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"人吃饭"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>study</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"人可以学习"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><h3 id="练习-3"> 练习</h3>
<ul>
<li>
<p>练习2</p>
<ol>
<li>
<p>在前面定义的Person类中添加构造器，利用构造器设置所有人的age属性初始化值位18</p>
</li>
<li>
<p>修改上题类和构造器，增加name属性，使得每次创建Person对象的同时初始化对象的age属性值和name属性值</p>
</li>
</ol>
<p><img src="./images/04类与面向对象/image-20211120151434432.png" alt="image-20211120151434432" /></p>
</li>
<li>
<p>练习3</p>
<ul>
<li>
<p>编写两个类，TriAngle和TriAngleTest，其中TriAngle类中声明私有的底边长base和高height，同时声明公共方法访问私有变量。此外提供类必要的构造器。另一个类中使用这些公共方法，计算三角形的面积</p>
<div><pre><code><span>//TriAngle.java</span>
<span>package</span> <span>day10<span>.</span>exer1</span><span>;</span>
<span>/*
triangle：三角形
angle: 角
angel: 天使
编写两个类，TriAngle和TriAngleTest，
其中TriAngle类中声明私有的底边长base和高height，同时声明公共方法访问私有变量。
此外提供类必要的构造器。另一个类中使用这些公共方法，计算三角形的面积
 */</span>
<span>public</span> <span>class</span> <span>TriAngle</span> <span>{</span>
    <span>private</span> <span>double</span> base<span>;</span><span>//底边长</span>
    <span>private</span> <span>double</span> height<span>;</span><span>//高</span>

    <span>public</span> <span>TriAngle</span><span>(</span><span>)</span><span>{</span>

    <span>}</span>
    <span>public</span> <span>TriAngle</span><span>(</span><span>double</span> b<span>,</span><span>double</span> h<span>)</span><span>{</span>
        base <span>=</span> b<span>;</span>
        height <span>=</span> h<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setBase</span><span>(</span><span>double</span> b<span>)</span><span>{</span>
        base <span>=</span> b<span>;</span>
    <span>}</span>
    <span>public</span> <span>double</span> <span>getBase</span><span>(</span><span>)</span><span>{</span>
        <span>return</span> base<span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>setHeight</span><span>(</span><span>double</span> h<span>)</span><span>{</span>
        height <span>=</span> h<span>;</span>
    <span>}</span>
    <span>public</span> <span>double</span> <span>getHeight</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> height<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><div><pre><code><span>//TriAngleTest.java</span>
<span>package</span> <span>day10<span>.</span>exer1</span><span>;</span>

<span>public</span> <span>class</span> <span>TriAngleTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>TriAngle</span> t1 <span>=</span> <span>new</span> <span>TriAngle</span><span>(</span><span>)</span><span>;</span>
        t1<span>.</span><span>setBase</span><span>(</span><span>2.0</span><span>)</span><span>;</span>
        t1<span>.</span><span>setHeight</span><span>(</span><span>2.4</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"base : "</span> <span>+</span> t1<span>.</span><span>getBase</span><span>(</span><span>)</span> <span>+</span> <span>", height: "</span> <span>+</span> t1<span>.</span><span>getHeight</span><span>(</span><span>)</span><span>)</span><span>;</span>

        <span>TriAngle</span> t2 <span>=</span> <span>new</span> <span>TriAngle</span><span>(</span><span>5.1</span><span>,</span> <span>5.6</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"base : "</span> <span>+</span> t2<span>.</span><span>getBase</span><span>(</span><span>)</span> <span>+</span> <span>", height: "</span> <span>+</span> t2<span>.</span><span>getHeight</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>t2<span>.</span><span>getBase</span><span>(</span><span>)</span> <span>*</span> t2<span>.</span><span>getHeight</span><span>(</span><span>)</span> <span>/</span> <span>2</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div></li>
</ul>
</li>
</ul>
<h3 id="属性赋值的先后顺序"> 属性赋值的先后顺序</h3>
<ol>
<li>
<p>默认初始化值</p>
</li>
<li>
<p>显式初始化</p>
</li>
<li>
<p>构造器中初始化（赋值</p>
</li>
<li>
<p>通过 <code>对象.方法</code> 或 <code>对象.属性</code> 的方法赋值（可以反复执行</p>
</li>
</ol>
<ul>
<li>以上四种操作的先后顺序：1 -&gt; 2 -&gt; 3 -&gt; 4</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>UserTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>User</span> u <span>=</span> <span>new</span> <span>User</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>u<span>.</span>age<span>)</span><span>;</span>
        <span>//这里输出的是2，即表示构造器赋值覆盖了显式初始化</span>
        <span>User</span> u1 <span>=</span> <span>new</span> <span>User</span><span>(</span><span>2</span><span>)</span><span>;</span>
        <span>//这里输出的是3，即表示`对象.方法`覆盖了构造器赋值</span>
        u1<span>.</span><span>setAge</span><span>(</span><span>3</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>u1<span>.</span>age<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>class</span> <span>User</span><span>{</span>
    <span>String</span> name<span>;</span>
    <span>int</span> age <span>=</span> <span>1</span><span>;</span>

    <span>public</span> <span>User</span><span>(</span><span>)</span><span>{</span>

    <span>}</span>

    <span>public</span> <span>User</span><span>(</span><span>int</span> a<span>)</span><span>{</span>
        age <span>=</span> a<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setAge</span><span>(</span><span>int</span> age<span>)</span> <span>{</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h2 id="扩展知识-javabean"> 扩展知识 - JavaBean</h2>
<ul>
<li>JavaBean是一种java语言写成的可重用组件</li>
<li>所谓JavaBean，是指符合如下标准的java类
<ul>
<li><strong>类是公共的</strong></li>
<li><strong>有一个无参的公共的构造器</strong></li>
<li><strong>有属性，且有对于的get、set方法</strong></li>
</ul>
</li>
<li>用户可以使用 Java Bean:将功能、处理、值、据库访问和其他任何可以用Java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP页面、 Servlet、其他 Java Bean、 applet程序或者应用来使用这些对象。用户可以认为 Java Bean提供了一种随时随地的复制和粘贴的功能，而不用关心任何改变。</li>
</ul>
<h2 id="扩展知识-uml类图"> 扩展知识 - UML类图</h2>
<p><img src="./images/04类与面向对象/image-20211122193339717.png" alt="image-20211122193339717" /></p>
<ul>
<li><code>Account</code>表示类名（第一行框框）</li>
<li><code>#color</code>属性的#代表<code>protected</code></li>
<li><code>-balance:double</code>属性（第二行框框）
<ul>
<li><code>-</code>表示private类型</li>
<li><code>balance</code>表示属性名</li>
<li><code>double</code>表示数据类型</li>
</ul>
</li>
<li><u><code>+Account(init_balance:double)</code></u>构造器（第三行框框）
<ul>
<li><code>+</code>表示public</li>
<li>括号内的时传参，分别为<code>传参名 : 传参类型</code></li>
</ul>
</li>
<li><code>+getBalance():double</code>方法（第三行框框）
<ul>
<li><code>+</code>表示public</li>
<li><code>():</code> 后面的<code>double</code>为返回值类型</li>
</ul>
</li>
<li><code>+vithdraw(eat: double)</code>方法（第三行框框）
<ul>
<li><code>+</code>表示public</li>
<li><code>(eat: double)</code> 表示<code>参数名: 参数类型</code></li>
<li>由于后面是空的所以返回值类型为<code>void</code></li>
</ul>
</li>
<li>方法的写法：<code>方法的类型(+、-) 方法名(参数名: 参数类型): 返回值类型</code></li>
</ul>
<h2 id="关键字-this的使用"> 关键字：this的使用</h2>
<ul>
<li>概念
<ul>
<li>在Java中，this关键字比较难理解，它的作用和其词义很接近。</li>
<li>它在方法内部使用，即这个方法所属对象的引用</li>
<li>它在构造器内部使用，表示该构造器正在初始化的对象。</li>
<li>this表示当前对象，可以调用类的属性、方法和构造器</li>
<li>什么时候使用this关键字呢？
<ul>
<li>当在方法内需要用到调用该方法的对象时，就用this.</li>
<li>具体的：我们可以用this来区分局部变量和属性</li>
<li>比如： this name=name;</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>this可以用来修饰、调用：属性、方法、构造器</li>
<li>this修饰属性和方法：
<ul>
<li>this理解为：当前对象或当前正在创建的对象</li>
<li>在类的<strong>方法</strong>中，我们可以使用<code>this.属性</code> 或 <code>this.方法</code> 的方式调用当前对象属性或方法。
<ul>
<li>但通常情况下我们一般都选择省略<code>this.**</code></li>
<li>特殊情况下，如果方法的形参与类的属性同名时，则必须显式的使用<code>this.**</code>的方式表明此变量是属性，而非形参</li>
</ul>
</li>
<li>在类的<strong>构造器</strong>中，我们可以使用<code>this.属性</code> 或 <code>this.方法</code> 的方式调用正在创建的对象属性或方法。
<ul>
<li>但通常情况下我们一般都选择省略<code>this.**</code></li>
<li>特殊情况下，如果构造器的形参与类的属性同名时，则必须显式的使用<code>this.**</code>的方式表明此变量是属性，而非形参</li>
</ul>
</li>
</ul>
</li>
<li>this调用构造器
<ul>
<li>我们在类的构造器中，可以显式的使用<code>this(形参列表)</code>方式，调用本类中指定的其他构造器</li>
<li>构造器中不能通过<code>this(形参列表)</code>方式调用自己</li>
<li>如果一个类中有n个构造器，则最多有n-1个构造器使用<code>this(形参列表)</code>方式（因为不能环回的调用，不然会死循环）</li>
<li>规定：<code>this(形参列表)</code>必须声明在当前构造器的首行且不能使用多个，否则会报错</li>
<li>构造器内部，最多只能声明一个<code>this(形参列表)</code>用来调用其他的构造器</li>
</ul>
</li>
</ol>
<div><pre><code><span>public</span> <span>class</span> <span>PersonTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Person</span> p1 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span>
        p1<span>.</span><span>setAge</span><span>(</span><span>1</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>p1<span>.</span><span>getAge</span><span>(</span><span>)</span><span>)</span><span>;</span>
        p1<span>.</span><span>eat</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"-----------"</span><span>)</span><span>;</span>
        <span>Person</span> p2 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>"Tom"</span><span>,</span> <span>21</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>p2<span>.</span><span>getAge</span><span>(</span><span>)</span><span>)</span><span>;</span>

    <span>}</span>
<span>}</span>

<span>class</span> <span>Person</span><span>{</span>
    <span>private</span> <span>String</span> name<span>;</span>
    <span>private</span> <span>int</span> age<span>;</span>

    <span>//假设现在有新需求，需要在构造器中写出40行代码，那如果4个构造器全部都需要写就太冗余了</span>
    <span>//所以可以使用this方法来调用已写了的构造器从而减少冗余</span>
    <span>public</span> <span>Person</span><span>(</span><span>)</span><span>{</span>
        <span>//注意这里不能使用这个，不然会陷入死循环，自己调用自己</span>
        <span>//this();</span>
        <span>String</span> info <span>=</span> <span>"假设Person初始化时需要考虑1、2、3、4...（共40行代码）"</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>info<span>)</span><span>;</span>
        <span>study</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>Person</span><span>(</span><span>String</span> name<span>)</span><span>{</span>
        <span>//可以使用this()方式调用上面的构造器，然后再执行this下面的代码，注意必须放首行</span>
        <span>this</span><span>(</span><span>)</span><span>;</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>
    <span>public</span> <span>Person</span><span>(</span><span>int</span> age<span>)</span><span>{</span>
        <span>this</span><span>(</span><span>)</span><span>;</span>
        <span>eat</span><span>(</span><span>)</span><span>;</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
    <span>}</span>
    <span>public</span> <span>Person</span><span>(</span><span>String</span> name<span>,</span><span>int</span> age<span>)</span><span>{</span>
        <span>//通过调用第三个构造器（调用第一个构造器）,从而实现下面两行注释的过程</span>
        <span>this</span><span>(</span>age<span>)</span><span>;</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
        <span>//this.age = age;</span>
        <span>//Person初始化时需要考虑1、2、3、4...（共40行代码）</span>
    <span>}</span>

    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> name<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getAge</span><span>(</span><span>)</span> <span>{</span>
        <span>// return this.age;</span>
        <span>return</span> age<span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>setName</span><span>(</span><span>String</span> name<span>)</span><span>{</span>
        <span>//如果传入的参数与类的属性不重名，this可忽略</span>
        <span>//name = name//但如果是重名的情况，像这里的操作其实是传入的name自己赋值给自己，没有更改到类的属性</span>
        <span>//this: 当前对象</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>setAge</span><span>(</span><span>int</span> age<span>)</span><span>{</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>eat</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"人吃饭"</span><span>)</span><span>;</span>
        <span>this</span><span>.</span><span>study</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>study</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"人学习"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br></div></div><h3 id="练习-4"> 练习</h3>
<ul>
<li>添加必要的构造器，综合应用构造器的重载，this关键字</li>
</ul>
<p><img src="./images/04类与面向对象/image-20211122205139428.png" alt="image-20211122205139428" /></p>
<div><pre><code><span>//Boy.java</span>
<span>package</span> <span>day10<span>.</span>exer2</span><span>;</span>

<span>public</span> <span>class</span> <span>Boy</span> <span>{</span>
    <span>private</span> <span>String</span> name<span>;</span>
    <span>private</span> <span>int</span> age<span>;</span>

    <span>public</span> <span>Boy</span><span>(</span><span>)</span> <span>{</span>
    <span>}</span>

    <span>public</span> <span>Boy</span><span>(</span><span>String</span> name<span>,</span> <span>int</span> age<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
    <span>}</span>

    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> name<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setName</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getAge</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> age<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setAge</span><span>(</span><span>int</span> age<span>)</span> <span>{</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>marry</span><span>(</span><span>Girl</span> girl<span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"我想娶"</span> <span>+</span> girl<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>shout</span><span>(</span><span>)</span><span>{</span>
        <span>if</span><span>(</span><span>this</span><span>.</span>age <span>>=</span> <span>22</span><span>)</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"可以合法登记结婚！"</span><span>)</span><span>;</span>
        <span>}</span><span>else</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"再多谈一下恋爱先~"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><div><pre><code><span>//Girl.java</span>
<span>package</span> <span>day10<span>.</span>exer2</span><span>;</span>

<span>public</span> <span>class</span> <span>Girl</span> <span>{</span>
    <span>private</span> <span>String</span> name<span>;</span>
    <span>private</span> <span>int</span> age<span>;</span>

    <span>public</span> <span>Girl</span><span>(</span><span>)</span> <span>{</span>
    <span>}</span>

    <span>public</span> <span>Girl</span><span>(</span><span>String</span> name<span>,</span> <span>int</span> age<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
    <span>}</span>

    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> name<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setName</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>marry</span><span>(</span><span>Boy</span> boy<span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"我想嫁给"</span> <span>+</span> boy<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>//需要传入girl（当前对象），而不是name或者age参数</span>
        boy<span>.</span><span>marry</span><span>(</span><span>this</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * @Description 比较两个对象的大小
     * @author bit
     * @date 2021.11.22 21:20
     * @param girl
     * @return 正数：当前对象大；负数：当前对象小；0：当前对象与形参对象相等
     //引申：对象排序，一般是参考对象里面的属性来排序
     */</span>
    <span>public</span> <span>int</span> <span>compare</span><span>(</span><span>Girl</span> girl<span>)</span><span>{</span>
        <span>// if(this.age > girl.age){</span>
        <span>//     return 1;</span>
        <span>// }else if(this.age &lt; girl.age){</span>
        <span>//     return -1;</span>
        <span>// }else{</span>
        <span>//     return 0;</span>
        <span>// }</span>
        <span>return</span> <span>this</span><span>.</span>age <span>-</span> girl<span>.</span>age<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><div><pre><code><span>//BoyGirlTest.java</span>
<span>package</span> <span>day10<span>.</span>exer2</span><span>;</span>

<span>public</span> <span>class</span> <span>BoyGirlTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Boy</span> boy <span>=</span> <span>new</span> <span>Boy</span><span>(</span><span>"罗密欧"</span><span>,</span> <span>21</span><span>)</span><span>;</span>
        boy<span>.</span><span>shout</span><span>(</span><span>)</span><span>;</span>

        <span>Girl</span> girl <span>=</span> <span>new</span> <span>Girl</span><span>(</span><span>"朱丽叶"</span><span>,</span> <span>18</span><span>)</span><span>;</span>
        girl<span>.</span><span>marry</span><span>(</span>boy<span>)</span><span>;</span>

        <span>Girl</span> girl1 <span>=</span> <span>new</span> <span>Girl</span><span>(</span><span>"祝英台"</span><span>,</span> <span>19</span><span>)</span><span>;</span>
        <span>int</span> compare <span>=</span> girl<span>.</span><span>compare</span><span>(</span>girl1<span>)</span><span>;</span>
        <span>if</span><span>(</span>compare <span>></span> <span>0</span><span>)</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>girl<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>"大"</span><span>)</span><span>;</span>
        <span>}</span><span>else</span> <span>if</span><span>(</span>compare <span>&lt;</span> <span>0</span><span>)</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>girl1<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>"大"</span><span>)</span><span>;</span>
        <span>}</span><span>else</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>girl<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>"与"</span> <span>+</span> girl1<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>"一样大"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h3 id="实验一"> 实验一</h3>
<p>模拟用户与账户之间的存取款操作</p>
<div><pre><code><span>//Account.java</span>
<span>package</span> <span>day10<span>.</span></span><span>Account_Customer</span><span>;</span>

<span>public</span> <span>class</span> <span>Account</span> <span>{</span>
    <span>private</span> <span>int</span> id<span>;</span>
    <span>private</span> <span>double</span> balance<span>;</span>
    <span>private</span> <span>double</span> annuallnterestRate<span>;</span>

    <span>/**
     * @param id                 账号
     * @param balance            余额
     * @param annuallnterestRate 年利率
     */</span>
    <span>public</span> <span>Account</span><span>(</span><span>int</span> id<span>,</span> <span>double</span> balance<span>,</span> <span>double</span> annuallnterestRate<span>)</span> <span>{</span>
        <span>this</span><span>.</span>id <span>=</span> id<span>;</span>
        <span>this</span><span>.</span>balance <span>=</span> balance<span>;</span>
        <span>this</span><span>.</span>annuallnterestRate <span>=</span> annuallnterestRate<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getId</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> id<span>;</span>
    <span>}</span>

    <span>public</span> <span>double</span> <span>getBalance</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> balance<span>;</span>
    <span>}</span>

    <span>public</span> <span>double</span> <span>getAnnuallnterestRate</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> annuallnterestRate<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setId</span><span>(</span><span>int</span> id<span>)</span> <span>{</span>
        <span>this</span><span>.</span>id <span>=</span> id<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setBalance</span><span>(</span><span>double</span> balance<span>)</span> <span>{</span>
        <span>this</span><span>.</span>balance <span>=</span> balance<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setAnnuallnterestRate</span><span>(</span><span>double</span> annuallnterestRate<span>)</span> <span>{</span>
        <span>this</span><span>.</span>annuallnterestRate <span>=</span> annuallnterestRate<span>;</span>
    <span>}</span>
    <span>/**
     * @description: 取钱
     * @param   amount
     * @author  bit
     * @date    2021/11/23 14:00
     */</span>
    <span>public</span> <span>void</span> <span>withdraw</span><span>(</span><span>double</span> amount<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>balance <span>>=</span> amount<span>)</span> <span>{</span>
            balance <span>-=</span> amount<span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"成功取出！"</span> <span>+</span> amount <span>+</span> <span>", 剩余余额为："</span> <span>+</span> balance<span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"余额不足！取款失败"</span><span>)</span><span>;</span>
        <span>}</span>

    <span>}</span>

    <span>/**
     * @description: 存钱
     * @param   amount
     * @author  bit
     * @date    2021/11/23 13:53
     */</span>
    <span>public</span> <span>void</span> <span>deposit</span><span>(</span><span>double</span> amount<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>amount <span>></span> <span>0</span><span>)</span><span>{</span>
            balance <span>+=</span> amount<span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"成功存入："</span> <span>+</span> amount <span>+</span> <span>", 剩余余额为："</span> <span>+</span> balance<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br></div></div><div><pre><code><span>//Customer.java</span>
<span>package</span> <span>day10<span>.</span></span><span>Account_Customer</span><span>;</span>

<span>public</span> <span>class</span> <span>Customer</span> <span>{</span>
    <span>private</span> <span>String</span> firstName<span>;</span>
    <span>private</span> <span>String</span> lastName<span>;</span>
    <span>private</span> <span>Account</span> account<span>;</span>

    <span>public</span> <span>Customer</span><span>(</span><span>String</span> f<span>,</span> <span>String</span> l<span>)</span> <span>{</span>
        <span>this</span><span>.</span>firstName <span>=</span> f<span>;</span>
        <span>this</span><span>.</span>lastName <span>=</span> l<span>;</span>
    <span>}</span>

    <span>public</span> <span>String</span> <span>getFirstName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> firstName<span>;</span>
    <span>}</span>

    <span>public</span> <span>String</span> <span>getLastName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> lastName<span>;</span>
    <span>}</span>

    <span>public</span> <span>Account</span> <span>getAccount</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> account<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setAccount</span><span>(</span><span>Account</span> account<span>)</span> <span>{</span>
        <span>this</span><span>.</span>account <span>=</span> account<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><div><pre><code><span>//CustomerTest.java</span>
<span>package</span> <span>day10<span>.</span></span><span>Account_Customer</span><span>;</span>

<span>public</span> <span>class</span> <span>CustomerTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Customer</span> c1 <span>=</span> <span>new</span> <span>Customer</span><span>(</span><span>"Jane"</span><span>,</span> <span>"Smith"</span><span>)</span><span>;</span>

        <span>Account</span> account <span>=</span> <span>new</span> <span>Account</span><span>(</span><span>1000</span><span>,</span> <span>2000</span><span>,</span> <span>0.0123</span><span>)</span><span>;</span>
        c1<span>.</span><span>setAccount</span><span>(</span>account<span>)</span><span>;</span>

        c1<span>.</span><span>getAccount</span><span>(</span><span>)</span><span>.</span><span>deposit</span><span>(</span><span>100</span><span>)</span><span>;</span>
        c1<span>.</span><span>getAccount</span><span>(</span><span>)</span><span>.</span><span>withdraw</span><span>(</span><span>960</span><span>)</span><span>;</span>
        c1<span>.</span><span>getAccount</span><span>(</span><span>)</span><span>.</span><span>withdraw</span><span>(</span><span>2000</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Customer ["</span> <span>+</span> c1<span>.</span><span>getLastName</span><span>(</span><span>)</span> <span>+</span> <span>", "</span> <span>+</span> c1<span>.</span><span>getFirstName</span><span>(</span><span>)</span> <span>+</span> <span>"] has a account: id is "</span> <span>+</span>
                c1<span>.</span><span>getAccount</span><span>(</span><span>)</span><span>.</span><span>getId</span><span>(</span><span>)</span> <span>+</span> <span>", annuallnterestRate is "</span> <span>+</span> c1<span>.</span><span>getAccount</span><span>(</span><span>)</span><span>.</span><span>getAnnuallnterestRate</span><span>(</span><span>)</span> <span>*</span> <span>100</span> <span>+</span>
                <span>"%, balance is "</span> <span>+</span> c1<span>.</span><span>getAccount</span><span>(</span><span>)</span><span>.</span><span>getBalance</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id="实验二"> 实验二</h3>
<p>基于实验一增加银行，通过银行来对账户与用户操作</p>
<div><pre><code><span>//Customer.java</span>
<span>package</span> <span>day10<span>.</span></span><span>Account_Customer_Bank</span><span>;</span>

<span>/**
 * @description: 用户类
 * @author bit
 * @date 2021/11/23 14:56
 * @version 1.0
 */</span>
<span>public</span> <span>class</span> <span>Customer</span> <span>{</span>
    <span>private</span> <span>String</span> firstName<span>;</span>
    <span>private</span> <span>String</span> lastName<span>;</span>
    <span>private</span> <span>Account</span> account<span>;</span>

    <span>public</span> <span>Customer</span><span>(</span><span>String</span> f<span>,</span> <span>String</span> l<span>)</span> <span>{</span>
        <span>this</span><span>.</span>firstName <span>=</span> f<span>;</span>
        <span>this</span><span>.</span>lastName <span>=</span> l<span>;</span>
    <span>}</span>

    <span>public</span> <span>String</span> <span>getFirstName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> firstName<span>;</span>
    <span>}</span>

    <span>public</span> <span>String</span> <span>getLastName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> lastName<span>;</span>
    <span>}</span>

    <span>public</span> <span>Account</span> <span>getAccount</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> account<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setAccount</span><span>(</span><span>Account</span> account<span>)</span> <span>{</span>
        <span>this</span><span>.</span>account <span>=</span> account<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><div><pre><code><span>//Account.java</span>
<span>package</span> <span>day10<span>.</span></span><span>Account_Customer_Bank</span><span>;</span>

<span>/**
 * @description: 账户类
 * @author bit
 * @date 2021/11/23 14:56
 * @version 1.0
 */</span>
<span>public</span> <span>class</span> <span>Account</span> <span>{</span>
    <span>private</span> <span>double</span> balance<span>;</span>

    <span>public</span> <span>Account</span><span>(</span><span>double</span> init_balance<span>)</span><span>{</span>
        balance <span>=</span> init_balance<span>;</span>
    <span>}</span>

    <span>public</span> <span>double</span> <span>getBalance</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> balance<span>;</span>
    <span>}</span>
    <span>/**
     * @description: 存款
     * @param   amt 需要操作的钱数额
     * @author  bit
     * @date    2021/11/23 14:43
     */</span>
    <span>public</span> <span>void</span> <span>deposit</span><span>(</span><span>double</span> amt<span>)</span><span>{</span>
        <span>if</span> <span>(</span>amt <span>></span> <span>0</span><span>)</span><span>{</span>
            balance <span>+=</span> amt<span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"成功存入："</span> <span>+</span> amt <span>+</span> <span>", 剩余余额为："</span> <span>+</span> balance<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>/**
     * @description: 取款
     * @param   amt 需要操作的钱数额
     * @author  bit
     * @date    2021/11/23 14:46
     */</span>
    <span>public</span> <span>void</span> <span>withdraw</span><span>(</span><span>double</span> amt<span>)</span><span>{</span>
        <span>if</span><span>(</span>balance <span>&lt;</span> amt<span>)</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"余额不足！取款失败"</span><span>)</span><span>;</span>
            <span>return</span><span>;</span>
        <span>}</span>
        balance <span>-=</span> amt<span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"成功取出！"</span> <span>+</span> amt <span>+</span> <span>", 剩余余额为："</span> <span>+</span> balance<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><div><pre><code><span>//Bank.java</span>
<span>package</span> <span>day10<span>.</span></span><span>Account_Customer_Bank</span><span>;</span>

<span>/**
 * @description: 银行类
 * @author bit
 * @date 2021/11/23 14:57
 * @version 1.0
 */</span>
<span>public</span> <span>class</span> <span>Bank</span> <span>{</span>
    <span>private</span> <span>Customer</span><span>[</span><span>]</span> customers<span>;</span> <span>// 用于存放多个客户的数组</span>
    <span>private</span> <span>int</span> numberOfCustomer<span>;</span> <span>// 记录客户的个数</span>

    <span>public</span> <span>Bank</span><span>(</span><span>)</span> <span>{</span>
        customers <span>=</span> <span>new</span> <span>Customer</span><span>[</span><span>10</span><span>]</span><span>;</span>
    <span>}</span>

    <span>/**
     * @description: 添加一个客户
     * @param   f first name
     * @param   l last name
     * @author  bit
     * @date    2021/11/23 14:57
     */</span>
    <span>public</span> <span>void</span> <span>addCustomer</span><span>(</span><span>String</span> f<span>,</span> <span>String</span> l<span>)</span><span>{</span>
        <span>Customer</span> cust <span>=</span> <span>new</span> <span>Customer</span><span>(</span>f<span>,</span> l<span>)</span><span>;</span>
        <span>// customer[numberOfCustomer] = cust;</span>
        <span>// numberOfCustomer++;</span>
        customers<span>[</span>numberOfCustomer<span>++</span><span>]</span> <span>=</span> cust<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getNumberOfCustomer</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> numberOfCustomer<span>;</span>
    <span>}</span>

    <span>public</span> <span>Customer</span> <span>getCustomer</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
        <span>// return customers[index];//单纯这样写会出现越界等问题</span>

        <span>if</span><span>(</span>index <span>>=</span> <span>0</span> <span>&amp;&amp;</span> index <span>&lt;</span> numberOfCustomer<span>)</span><span>{</span>
            <span>return</span> customers<span>[</span>index<span>]</span><span>;</span>
        <span>}</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><div><pre><code><span>//BankTest.java</span>
<span>package</span> <span>day10<span>.</span></span><span>Account_Customer_Bank</span><span>;</span>

<span>public</span> <span>class</span> <span>BankTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Bank</span> bank <span>=</span> <span>new</span> <span>Bank</span><span>(</span><span>)</span><span>;</span>
        <span>// 创建新用户</span>
        bank<span>.</span><span>addCustomer</span><span>(</span><span>"jane"</span><span>,</span> <span>"smith"</span><span>)</span><span>;</span>

        <span>// 初始化smith用户的账户，设置初始余额为2000</span>
        bank<span>.</span><span>getCustomer</span><span>(</span><span>0</span><span>)</span><span>.</span><span>setAccount</span><span>(</span><span>new</span> <span>Account</span><span>(</span><span>2000</span><span>)</span><span>)</span><span>;</span>
        <span>// 得到在银行索引值为0的用户的用户对象，对此用户对象取款操作</span>
        bank<span>.</span><span>getCustomer</span><span>(</span><span>0</span><span>)</span><span>.</span><span>getAccount</span><span>(</span><span>)</span><span>.</span><span>withdraw</span><span>(</span><span>500</span><span>)</span><span>;</span>

        <span>double</span> balance <span>=</span> bank<span>.</span><span>getCustomer</span><span>(</span><span>0</span><span>)</span><span>.</span><span>getAccount</span><span>(</span><span>)</span><span>.</span><span>getBalance</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"客户"</span> <span>+</span> bank<span>.</span><span>getCustomer</span><span>(</span><span>0</span><span>)</span><span>.</span><span>getFirstName</span><span>(</span><span>)</span> <span>+</span> <span>"的账户余额为："</span> <span>+</span> balance<span>)</span><span>;</span>

        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"--------------------"</span><span>)</span><span>;</span>

        bank<span>.</span><span>addCustomer</span><span>(</span><span>"金"</span><span>,</span> <span>"白"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"银行目前的客户数量为: "</span> <span>+</span> bank<span>.</span><span>getNumberOfCustomer</span><span>(</span><span>)</span><span>)</span><span>;</span>

    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h2 id="关键字-package的使用"> 关键字：package的使用</h2>
<ol>
<li>
<p>为了更好的实现项目中类的管理，提供包的概念</p>
<ul>
<li>按不同的功能分为不同的包，类就放在不同的包下面</li>
</ul>
</li>
<li>
<p>使用package声明类或接口所属的包，声明在源文件的首行</p>
</li>
<li>
<p>包(package) 属于标识符，遵循标识符的命名规则、规范(xxx.yyy.zzz)、<code>见名知意</code></p>
</li>
<li>
<p>每<code>.</code>一次，就代表一层文件目录</p>
</li>
</ol>
<ul>
<li>补充：<strong>同一个包下，不能命名同名的接口、类</strong>；不同的包下，可以命名同名的接口、类</li>
</ul>
<h3 id="jdk中主要的包介绍"> JDK中主要的包介绍</h3>
<ol>
<li>java.lang----包含一些Java语言的核心类， 如String、 Math、 Integer、 System和Thread， 提供常用功能</li>
<li>java.net----包含执行与网络相关的操作的类和接口。</li>
<li>java.io ----包含能提供多种输入/输出功能的类。</li>
<li>java.util----包含一些实用工具类， 如定义系统特性、 接口的集合框架类、 使用与日期日历相关的函数。</li>
<li>java.text----包含了一些java格式化相关的类</li>
<li>java.sql----包含了java进行JDBC数据库编程的相关类/接口</li>
<li>java.awt----包含了构成抽象窗口工具集（abstract window toolkits） 的多个类， 这些类被用来构建和管理应用程序的图形用户界面(GUI)。 B/S C/S</li>
</ol>
<h3 id="mvc设计模式"> MVC设计模式</h3>
<p>MVC是常用的设计模式之一，将整个程序分为三个层次： <strong>视图模型层(V)，控制器层(C)，与数据模型层(M)</strong>。 这种将程序输入输出、数据处理，以及数据的展示分离开来的设计模式使程序结构变的灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程序的耦合性。</p>
<ul>
<li><strong>模型层 model 主要处理数据</strong>
<ul>
<li>数据对象封装 model.bean/domain</li>
<li>数据库操作类 model.dao</li>
<li>数据库 model.db</li>
<li>视图层 view 显示数据</li>
<li>相关工具类 view.utils</li>
<li>自定义view view.ui</li>
</ul>
</li>
<li><strong>视图层 view 显示数据</strong>
<ul>
<li>相关工具类 view.utils</li>
<li>自定义view view.ui</li>
</ul>
</li>
<li><strong>控制层 controller 处理业务逻辑</strong>
<ul>
<li>应用界面相关 controller.activity</li>
<li>存放fragment controller.fragment</li>
<li>显示列表的适配器 controller.adapter</li>
<li>服务相关的 controller.service</li>
<li>抽取的基类 controller.base</li>
</ul>
</li>
</ul>
<p><img src="./images/04类与面向对象/image-20211123172337519.png" alt="image-20211123172337519" /></p>
<h2 id="关键字-import的使用"> 关键字：import的使用</h2>
<p>import: 导入</p>
<ol>
<li>在源文件中显式的使用import结构导入指定包下的<strong>类、接口</strong></li>
<li>声明在包(package)的声明和类的声明之间</li>
<li>如果要导入多个结构，则并列写出即可</li>
<li>可以使用<code>xxx.*</code>的方式，表示可以导入<code>xxx</code>包下所有的结构</li>
<li>如果使用的类或接口是<code>java.lang</code>包下定义的，则可以省略import结构</li>
<li>如果使用的类或接口是本包下定义的，则可以省略import结构</li>
<li>如果在源文件中，使用了不同包下的同名的类，则必须至少有一个类需要以全类名的方式显示</li>
<li>使用<code>xxx.*</code>方式可以调用xxx包下所有的结构，但如果使用的是<code>xxx</code>子包下的结构，则仍需要显式导入</li>
<li>import static：导入指定类或接口中的静态结构：<strong>属性或方法</strong></li>
</ol>
<div><pre><code><span>package</span> <span>day10<span>.</span>java2</span><span>;</span>

<span>import</span> <span>day10<span>.</span></span><span>Account_Customer_Bank<span>.</span>Account</span><span>;</span>
<span>import</span> <span>day10<span>.</span></span><span>Account_Customer_Bank<span>.</span>Bank</span><span>;</span>

<span>//导入包下的所有接口</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>*</span><span>;</span>
<span>// 使用java.util.*;即代表下面的结构</span>
<span>// import java.util.ArrayList;</span>
<span>// import java.util.Arrays;</span>
<span>// import java.util.HashMap;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Field</span><span>;</span>
<span>import</span> U4类与面向对象<span>.</span>day10<span>.</span>java2<span>.</span>java3<span>.</span>Dog<span>;</span>

<span>//可以使用System类下接口静态的结构</span>
<span>import</span> <span>static</span> <span>java<span>.</span>lang<span>.</span></span><span>System</span><span>.</span>*<span>;</span>
<span>import</span> <span>static</span> <span>java<span>.</span>lang<span>.</span></span><span>Math</span><span>.</span>*<span>;</span>
<span>// 注意是类中的结构而不是类</span>
<span>// import static java.lang.Math;</span>
<span>public</span> <span>class</span> <span>PackageImportTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>String</span> info <span>=</span> <span>Arrays</span><span>.</span><span>toString</span><span>(</span><span>new</span> <span>int</span><span>[</span><span>]</span><span>{</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>}</span><span>)</span><span>;</span>

        <span>Bank</span> bank <span>=</span> <span>new</span> <span>Bank</span><span>(</span><span>)</span><span>;</span>

        <span>ArrayList</span> list <span>=</span> <span>new</span> <span>ArrayList</span><span>(</span><span>)</span><span>;</span>
        <span>HashMap</span> map <span>=</span> <span>new</span> <span>HashMap</span><span>(</span><span>)</span><span>;</span>

        <span>Scanner</span> s <span>=</span> <span>null</span><span>;</span>

        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"hello!"</span><span>)</span><span>;</span>

        <span>Person</span> p <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span>
        <span>Account</span> acct <span>=</span> <span>new</span> <span>Account</span><span>(</span><span>1000</span><span>)</span><span>;</span>
        <span>//全类名的方式显示</span>
        <span><span>day10<span>.</span></span>Account_Customer<span>.</span>Account</span> acct1 <span>=</span> <span>new</span> <span><span>day10<span>.</span></span>Account_Customer<span>.</span>Account</span><span>(</span><span>1000</span><span>,</span> <span>2000</span><span>,</span><span>0.0123</span><span>)</span><span>;</span>

        <span>//全类名的实际举例</span>
        <span>Date</span> date <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>;</span>
        <span><span>java<span>.</span>sql<span>.</span></span>Date</span> date1 <span>=</span> <span>new</span> <span><span>java<span>.</span>sql<span>.</span></span>Date</span><span>(</span><span>11L</span><span>)</span><span>;</span>

        <span>Dog</span> dog <span>=</span> <span>new</span> <span>Dog</span><span>(</span><span>)</span><span>;</span>

        <span>Field</span> field <span>=</span> <span>null</span><span>;</span>

        out<span>.</span><span>println</span><span>(</span><span>"hello"</span><span>)</span><span>;</span>
        <span>long</span> num <span>=</span> <span>round</span><span>(</span><span>123.434</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><h3 id="考察-3"> 考察</h3>
<ol>
<li>
<p>构造器的作用是什么？使用中有哪些注意点</p>
<ul>
<li>
<p>作用</p>
<ol>
<li>创建对象</li>
<li>初始化对象结构</li>
</ol>
</li>
<li>
<p>注意点</p>
<ul>
<li>一个类中一定有构造器，默认的构造器是无参的</li>
<li>构造器没有返回值</li>
<li>可以声明多个构造器</li>
</ul>
</li>
</ul>
</li>
<li>
<p>关于类的属性的赋值，有几种赋值方式。谈谈赋值的先后顺序。</p>
<ul>
<li>默认初始化 -&gt; 显示初始化 -&gt; 构造器中初始化 -&gt; <code>对象.方法</code> 或 <code>对象.属性</code> 赋值</li>
</ul>
</li>
<li>
<p>this关键字可以用来调用那些结构，简单说明一下其使用</p>
<ul>
<li>this: 属性、方法、构造器</li>
<li>this 理解为当前对象，当前正在创建的对象</li>
</ul>
</li>
<li>
<p>java中目前学习涉及到的四种权限修饰符都有什么？并说明各自的权限范围</p>
<ul>
<li>private、缺省、protected、public</li>
</ul>
</li>
<li>
<p>创建Circle类，提供私有radius属性，提供相应的get和set方法，提供求圆面积的方法</p>
<div><pre><code><span>private</span> <span>double</span> radius<span>;</span>
<span>public</span> <span>double</span> <span>getRadius</span><span>(</span><span>)</span><span>{</span>
    <span>return</span> <span>this</span><span>.</span>radius<span>;</span>
<span>}</span>
<span>public</span> <span>void</span> <span>setRadius</span><span>(</span><span>double</span> radius<span>)</span><span>{</span>
    <span>this</span><span>.</span>radius <span>=</span> radius<span>;</span>
<span>}</span>
<span>public</span> <span>double</span> <span>findArea</span><span>(</span><span>)</span><span>{</span>
    <span>return</span> <span>3.14</span> <span>*</span> radius <span>*</span> radius<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div></li>
</ol>
<p>day11</p>
<h2 id="额外-关于eclipse的快捷键"> 额外 - 关于Eclipse的快捷键</h2>
<ul>
<li>
<p><code>ctrl+1</code>：快速修复</p>
</li>
<li>
<p><code>ctrl+shift+o</code>：批量导包</p>
</li>
<li>
<p><code>ctrl+alt+down 或 ctrl+alt+up</code>：赋值指定行的代码</p>
</li>
<li>
<p><code>ctrl+d</code>：删除指定行的代码</p>
</li>
<li>
<p><code>alt+? 或 alt+/</code>：自动补全代码或者提示代码</p>
</li>
<li>
<p><code>ctrl+o</code>：快速outline视图</p>
</li>
<li>
<p><code>ctrl+shift+r</code>：打开资源列表</p>
</li>
<li>
<p><code>ctrl+shift+f</code>：格式化代码</p>
</li>
<li>
<p><code>ctrl+e</code>：快速转换编辑器</p>
</li>
<li>
<p><code>ctrl+page down 或 ctrl+page up</code>： 选项卡之间快速切换</p>
</li>
<li>
<p><code>shift+enter 及 ctrl+shift+enter</code>： 在当前行上或者下边创建空白。</p>
</li>
<li>
<p><code>Alt+方向键上下</code>：上下行交换内容或把当前行内容把上或下移动</p>
</li>
<li>
<p><code>Control+Alt+方向上下键</code>：复制高亮显示的一行或多行</p>
</li>
<li>
<p><code>ctrl+m</code>：当前编辑页面窗口最大化</p>
</li>
<li>
<p><code>ctrl+/</code>：自动注释当前行或者选择的多行</p>
</li>
<li>
<p><code>ctrl+shift+/</code>：自动注释掉选择的代码块</p>
</li>
<li>
<p><code>ctrl+d</code>：删除当前行</p>
</li>
<li>
<p><code>ctrl+shift+x 和 ctrl+shift+y</code>：英文字母大小写的转换</p>
</li>
<li>
<p><code>ctrl+shift+o</code>：自动引入包和删除无用包</p>
</li>
</ul>
<h2 id="项目二-客户信息管理软件"> 项目二 - 客户信息管理软件</h2>
<p><img src="./images/04类与面向对象/image-20211125154147118.png" alt="image-20211125154147118" /></p>
<ul>
<li>
<p>该软件由以下三个模块组成</p>
<ul>
<li>CustomerView为主模块，负责菜单的显示和处理用户操作</li>
<li>CustomerList为Customer对象的管理模块，内部用数组管理一组Customer对象，并提供相应的添加、修改、删除和遍历方法，供CustomerView调用</li>
<li>Customer为实体对象，用来封装客户信息</li>
</ul>
</li>
<li>
<p>Customer</p>
<ul>
<li>
<p>封装的信息</p>
<div><pre><code><span>String</span> name<span>;</span> <span>//客户信息</span>
<span>char</span> gender<span>;</span> <span>//性别</span>
<span>int</span> age<span>;</span> <span>//年龄</span>
<span>String</span> phone<span>;</span><span>//电话号码</span>
<span>String</span> email<span>;</span><span>//电子邮件</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p>提供合适的构造器</p>
</li>
<li>
<p>提供get/set方法</p>
</li>
</ul>
</li>
<li>
<p>CustomerList</p>
<ul>
<li>
<p>封装信息</p>
<div><pre><code><span>private</span> <span>Customer</span><span>[</span><span>]</span> customers<span>;</span><span>//用以保存客户对象的数组</span>
<span>private</span> <span>int</span> total <span>=</span> <span>0</span><span>;</span><span>//记录已保存客户对象的数量</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>提供以下构造器与方法</p>
<div><pre><code><span>public</span> <span>CustomerList</span><span>(</span><span>int</span> totalCustomer<span>)</span><span>{</span><span>}</span><span>;</span>
<span>public</span> <span>boolean</span> <span>addCustomer</span><span>(</span><span>Customer</span> customer<span>)</span><span>{</span><span>}</span><span>;</span>
<span>public</span> <span>boolean</span> <span>replaceCustomer</span><span>(</span><span>int</span> index<span>,</span> <span>Customer</span> cust<span>)</span><span>{</span><span>}</span><span>;</span>
<span>public</span> <span>boolean</span> <span>deleteCustomer</span><span>(</span><span>int</span> index<span>)</span><span>{</span><span>}</span><span>;</span>
<span>public</span> <span>Customer</span><span>[</span><span>]</span> <span>getAllCustomers</span><span>(</span><span>)</span><span>{</span><span>}</span><span>;</span>
<span>public</span> <span>Customer</span> <span>getCustomer</span><span>(</span><span>int</span> index<span>)</span><span>{</span><span>}</span><span>;</span>
<span>public</span> <span>int</span> <span>getTotal</span><span>(</span><span>)</span><span>{</span><span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
</ul>
</li>
<li>
<p>CustomerView</p>
<ul>
<li>
<p>封装信息</p>
<div><pre><code><span>CustomerList</span> customerList <span>=</span> <span>new</span> <span>CustomerList</span><span>(</span><span>10</span><span>)</span><span>;</span><span>//创建最大包括10个客户对象的CustomerLIst对象，供以下各成员方法使用</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>提供以下方法</p>
<div><pre><code><span>public</span> <span>void</span> <span>enterMainMenu</span><span>(</span><span>)</span><span>{</span><span>}</span><span>;</span>
<span>private</span> <span>void</span> <span>addNewCustomer</span><span>(</span><span>)</span><span>{</span><span>}</span>；
<span>private</span> <span>void</span> <span>modifyCustomer</span><span>(</span><span>)</span><span>{</span><span>}</span>；
<span>private</span> <span>void</span> <span>deleteCustomer</span><span>(</span><span>)</span><span>{</span><span>}</span>；
<span>private</span> <span>void</span> <span>listAllCustomers</span><span>(</span><span>)</span><span>{</span><span>}</span>；
<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span><span>{</span><span>}</span>；
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
</ul>
</li>
</ul>
<h3 id="文件目录"> 文件目录</h3>
<div><pre><code>├─bean
  ├─Customer.java: 为实体对象，用来封装客户信息
├─service
  ├─CustomerList.java: Customer对象的管理模块
├─ui
  ├─CustomerView.java: 主模块，负责菜单的显示和处理用户操作
└─util
  ├─CMUtility.java: 关于输入的工具方法
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="customer-java"> Customer.java</h3>
<div><pre><code><span>package</span> <span>myproject02<span>.</span>bean</span><span>;</span>
<span>/**
 * @description: Customer为实体对象，用来封装客户信息
 * @author bit
 * @date 2021/11/24 20:46
 * @version 1.0
 */</span>


<span>public</span> <span>class</span> <span>Customer</span> <span>{</span>
    <span>private</span> <span>String</span> name<span>;</span>    <span>//客户信息</span>
    <span>private</span> <span>char</span> gender<span>;</span>    <span>//性别</span>
    <span>private</span> <span>int</span> age<span>;</span>        <span>//年龄</span>
    <span>private</span> <span>String</span> phone<span>;</span>   <span>//电话号码</span>
    <span>private</span> <span>String</span> email<span>;</span>   <span>//电子邮件</span>

    <span>public</span> <span>Customer</span><span>(</span><span>)</span><span>{</span>

    <span>}</span>

    <span>public</span> <span>Customer</span><span>(</span><span>String</span> name<span>,</span> <span>char</span> gender<span>,</span> <span>int</span> age<span>,</span> <span>String</span> phone<span>,</span> <span>String</span> email<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
        <span>this</span><span>.</span>gender <span>=</span> gender<span>;</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
        <span>this</span><span>.</span>phone <span>=</span> phone<span>;</span>
        <span>this</span><span>.</span>email <span>=</span> email<span>;</span>
    <span>}</span>

    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> name<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setName</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>

    <span>public</span> <span>char</span> <span>getGender</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> gender<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setGender</span><span>(</span><span>char</span> gender<span>)</span> <span>{</span>
        <span>this</span><span>.</span>gender <span>=</span> gender<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getAge</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> age<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setAge</span><span>(</span><span>int</span> age<span>)</span> <span>{</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
    <span>}</span>

    <span>public</span> <span>String</span> <span>getPhone</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> phone<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setPhone</span><span>(</span><span>String</span> phone<span>)</span> <span>{</span>
        <span>this</span><span>.</span>phone <span>=</span> phone<span>;</span>
    <span>}</span>

    <span>public</span> <span>String</span> <span>getEmail</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> email<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setEmail</span><span>(</span><span>String</span> email<span>)</span> <span>{</span>
        <span>this</span><span>.</span>email <span>=</span> email<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br></div></div><h3 id="customerlist-java"> CustomerList.java</h3>
<div><pre><code><span>package</span> <span>myproject02<span>.</span>service</span><span>;</span>
<span>import</span> <span>myproject02<span>.</span>bean<span>.</span></span><span>Customer</span><span>;</span>
<span>/**
 * @description: CustomerList为Customer对象的管理模块，内部用数组管理一组Customer对象，并提供相应的添加、修改、删除和遍历方法，供CustomerView调用
 * @author bit
 * @date 2021/11/24 20:49
 * @version 1.0
 */</span>
<span>public</span> <span>class</span> <span>CustomerList</span> <span>{</span>
    <span>private</span> <span>Customer</span><span>[</span><span>]</span> customers<span>;</span><span>//用以保存客户对象的数组</span>
    <span>private</span> <span>int</span> total <span>=</span> <span>0</span><span>;</span><span>//记录已保存客户对象的数量</span>

    <span>/**
     * @description: 用来初始化customers数组的构造器
     * @param   totalCustomer 指定数组的长度
     * @author  bit
     * @date    2021/11/25 10:47
     */</span>
    <span>public</span> <span>CustomerList</span><span>(</span><span>int</span> totalCustomer<span>)</span> <span>{</span>
       customers <span>=</span> <span>new</span> <span>Customer</span><span>[</span>totalCustomer<span>]</span><span>;</span>
    <span>}</span>

    <span>/**
     * @description: 将指定的客户添加到数组中
     * @param   customer 用户类
     * @return  true:添加成功 false:添加失败
     * @author  bit
     * @date    2021/11/25 10:48
     */</span>
    <span>public</span> <span>boolean</span> <span>addCustomer</span><span>(</span><span>Customer</span> customer<span>)</span> <span>{</span>
        <span>if</span><span>(</span>total <span>>=</span> customers<span>.</span>length<span>)</span><span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>
        customers<span>[</span>total<span>++</span><span>]</span> <span>=</span> customer<span>;</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>

    <span>/**
     * @description: 修改指定索引位置上的客户信息
     * @param   index 索引值
     * @param   cust 修改的新用户类的引用地址
     * @return  true: 添加成功; false: 添加失败
     * @author  bit
     * @date    2021/11/25 10:53
     */</span>
    <span>public</span> <span>boolean</span> <span>replaceCustomer</span><span>(</span><span>int</span> index<span>,</span> <span>Customer</span> cust<span>)</span> <span>{</span>
        <span>if</span><span>(</span>index <span>&lt;</span> <span>0</span> <span>||</span> index <span>>=</span> total<span>)</span><span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>
        customers<span>[</span>index<span>]</span> <span>=</span> cust<span>;</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>

    <span>/**
     * @description: 删除指定索引位置上的客户
     * @param   index 索引值
     * @return  true:添加成功 false:添加失败
     * @author  bit
     * @date    2021/11/25 10:58
     */</span>
    <span>public</span> <span>boolean</span> <span>deleteCustomer</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
        <span>if</span><span>(</span>index <span>&lt;</span> <span>0</span> <span>||</span> index <span>>=</span> total<span>)</span><span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>
        <span>//这里total需要-1，因为total后面是没有东西的，执行到最后一个循环的时候，i-1=total</span>
        <span>for</span><span>(</span><span>int</span> i <span>=</span> index<span>;</span>i <span>&lt;</span> total<span>-</span><span>1</span><span>;</span>i<span>++</span><span>)</span><span>{</span>
            customers<span>[</span>i<span>]</span> <span>=</span> customers<span>[</span>i<span>+</span><span>1</span><span>]</span><span>;</span>
        <span>}</span>
        <span>//此时最后一个元素的需要置为null</span>
        customers<span>[</span><span>--</span>total<span>]</span> <span>=</span> <span>null</span><span>;</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>

    <span>/**
     * @description: 获取所有的客户信息。将customers里面保存的地址值赋值给custs
     * @return  返回所有的客户类数组
     * @author  bit
     * @date    2021/11/25 11:06
     */</span>
    <span>public</span> <span>Customer</span><span>[</span><span>]</span> <span>getAllCustomers</span><span>(</span><span>)</span> <span>{</span>
         <span>Customer</span><span>[</span><span>]</span> custs <span>=</span> <span>new</span> <span>Customer</span><span>[</span>total<span>]</span><span>;</span>
         <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span>i <span>&lt;</span> total<span>;</span>i<span>++</span><span>)</span><span>{</span>
             <span>//这里存储的是每个客户类的地址值</span>
             custs<span>[</span>i<span>]</span> <span>=</span> customers<span>[</span>i<span>]</span><span>;</span>
         <span>}</span>
         <span>return</span> custs<span>;</span>
    <span>}</span>

    <span>/**
     * @description: 获取指定索引值的客户地址
     * @param   index 索引值
     * @return  如果找到了则返回指定的客户类，反之返回null
     * @author  bit
     * @date    2021/11/25 11:10
     */</span>
    <span>public</span> <span>Customer</span> <span>getCustomer</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
        <span>if</span><span>(</span>index <span>&lt;</span> <span>0</span> <span>||</span> index <span>>=</span> total<span>)</span><span>{</span>
            <span>return</span> <span>null</span><span>;</span>
        <span>}</span>
        <span>return</span> customers<span>[</span>index<span>]</span><span>;</span>
    <span>}</span>

    <span>/**
     * @description: 获取存储的客户数量
     * @return  客户数量，type int
     * @author  bit
     * @date    2021/11/25 11:12
     */</span>
    <span>public</span> <span>int</span> <span>getTotal</span><span>(</span><span>)</span> <span>{</span>
        <span>//这里注意不要写成customers.length，这是数组的总长度，而非客户的数量值！</span>
        <span>return</span> total<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br></div></div><h3 id="customerview-java"> CustomerView.java</h3>
<div><pre><code><span>package</span> <span>myproject02<span>.</span>ui</span><span>;</span>

<span>import</span> <span>myproject02<span>.</span>bean<span>.</span></span><span>Customer</span><span>;</span>
<span>import</span> <span>myproject02<span>.</span>service<span>.</span></span><span>CustomerList</span><span>;</span>
<span>import</span> <span>myproject02<span>.</span>util<span>.</span></span><span>CMUtility</span><span>;</span>

<span>/**
 * @description: CustomerView为主模块，负责菜单的显示和处理用户操作
 * @author bit
 * @date 2021/11/24 20:50
 * @version 1.0
 */</span>
<span>public</span> <span>class</span> <span>CustomerView</span> <span>{</span>
    <span>CustomerList</span> customerList <span>=</span> <span>new</span> <span>CustomerList</span><span>(</span><span>10</span><span>)</span><span>;</span>

    <span>public</span> <span>CustomerView</span><span>(</span><span>)</span> <span>{</span>
        <span>Customer</span> customer <span>=</span> <span>new</span> <span>Customer</span><span>(</span><span>"小米"</span><span>,</span> <span>'男'</span><span>,</span>  <span>23</span><span>,</span>  <span>"12222222"</span><span>,</span> <span>"mi@mail.com"</span><span>)</span><span>;</span>
        customerList<span>.</span><span>addCustomer</span><span>(</span>customer<span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * @description: 显示《客户信息管理软解》界面的方法
     * @author  bit
     * @date    2021/11/25 11:21
     */</span>
    <span>private</span> <span>void</span> <span>enterMainMenu</span><span>(</span><span>)</span><span>{</span>
        <span>boolean</span> isFlag <span>=</span> <span>true</span><span>;</span>
        <span>while</span><span>(</span>isFlag<span>)</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"\n-----------------客户信息管理软件-----------------\n"</span><span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"                   1 添 加 客 户"</span><span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"                   2 修 改 客 户"</span><span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"                   3 删 除 客 户"</span><span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"                   4 客 户 列 表"</span><span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"                   5 退       出\n"</span><span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>"                   请选择(1-5)："</span><span>)</span><span>;</span>
            <span>char</span> menu <span>=</span> <span>CMUtility</span><span>.</span><span>readMenuSelection</span><span>(</span><span>)</span><span>;</span>
            <span>switch</span> <span>(</span>menu<span>)</span><span>{</span>
                <span>case</span> <span>'1'</span><span>:</span>
                    <span>addNewCustomer</span><span>(</span><span>)</span><span>;</span>
                    <span>break</span><span>;</span>
                <span>case</span> <span>'2'</span><span>:</span>
                    <span>modifyCustomer</span><span>(</span><span>)</span><span>;</span>
                    <span>break</span><span>;</span>
                <span>case</span> <span>'3'</span><span>:</span>
                    <span>deleteCustomer</span><span>(</span><span>)</span><span>;</span>
                    <span>break</span><span>;</span>
                <span>case</span> <span>'4'</span><span>:</span>
                    <span>listAllCustomers</span><span>(</span><span>)</span><span>;</span>
                    <span>break</span><span>;</span>
                <span>case</span> <span>'5'</span><span>:</span>
                    <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>"是否确认退出(Y/N)"</span><span>)</span><span>;</span>
                    <span>char</span> isExit <span>=</span> <span>CMUtility</span><span>.</span><span>readConfirmSelection</span><span>(</span><span>)</span><span>;</span>
                    <span>if</span><span>(</span>isExit <span>==</span> <span>'Y'</span><span>)</span><span>{</span>
                        isFlag <span>=</span> <span>false</span><span>;</span>
                    <span>}</span>
                    <span>break</span><span>;</span>
            <span>}</span>
        <span>}</span>

    <span>}</span>
    <span>/**
     * @description: 添加客户的操作
     * @author  bit
     * @date    2021/11/25 11:21
     */</span>
    <span>private</span> <span>void</span> <span>addNewCustomer</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"---------------------添加客户---------------------"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>"姓名："</span><span>)</span><span>;</span>
        <span>String</span> name <span>=</span> <span>CMUtility</span><span>.</span><span>readString</span><span>(</span><span>10</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>"性别："</span><span>)</span><span>;</span>
        <span>char</span> gender <span>=</span> <span>CMUtility</span><span>.</span><span>readChar</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>"年龄："</span><span>)</span><span>;</span>
        <span>int</span> age <span>=</span> <span>CMUtility</span><span>.</span><span>readInt</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>"电话："</span><span>)</span><span>;</span>
        <span>String</span> phone <span>=</span> <span>CMUtility</span><span>.</span><span>readString</span><span>(</span><span>13</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>"邮箱："</span><span>)</span><span>;</span>
        <span>String</span> email <span>=</span> <span>CMUtility</span><span>.</span><span>readString</span><span>(</span><span>15</span><span>)</span><span>;</span>

        <span>//将上面输入的数据封装到对象中</span>
        <span>Customer</span> customer <span>=</span> <span>new</span> <span>Customer</span><span>(</span>name<span>,</span> gender<span>,</span> age<span>,</span> phone<span>,</span> email<span>)</span><span>;</span>
        <span>boolean</span> isSuccess <span>=</span> customerList<span>.</span><span>addCustomer</span><span>(</span>customer<span>)</span><span>;</span>
        <span>if</span> <span>(</span>isSuccess<span>)</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"---------------------添加完成---------------------"</span><span>)</span><span>;</span>
        <span>}</span><span>else</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"----------------客户目录已满,无法添加-----------------"</span><span>)</span><span>;</span>
        <span>}</span>

    <span>}</span>
    <span>/**
     * @description: 修改客户的操作
     * @author  bit
     * @date    2021/11/25 11:21
     */</span>
    <span>private</span> <span>void</span> <span>modifyCustomer</span><span>(</span><span>)</span><span>{</span>
        <span>Customer</span> cust<span>;</span>
        <span>int</span> index<span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"---------------------修改客户---------------------"</span><span>)</span><span>;</span>
        <span>for</span><span>(</span><span>;</span><span>;</span><span>)</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>"请选择待修改客户编号(-1退出)："</span><span>)</span><span>;</span>
            index <span>=</span> <span>CMUtility</span><span>.</span><span>readInt</span><span>(</span><span>)</span><span>;</span>

            <span>if</span><span>(</span>index <span>==</span> <span>-</span><span>1</span><span>)</span><span>{</span>
                <span>return</span><span>;</span>
            <span>}</span>
            cust <span>=</span> customerList<span>.</span><span>getCustomer</span><span>(</span>index <span>-</span> <span>1</span><span>)</span><span>;</span>
            <span>if</span> <span>(</span>cust <span>==</span> <span>null</span><span>)</span><span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"无法找到指定客户"</span><span>)</span><span>;</span>
            <span>}</span><span>else</span><span>{</span><span>//找到了index-1的客户，跳出循环</span>
                <span>break</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>//跳出循环说明找到了对应的客户类并修改信息</span>
        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>"姓名("</span> <span>+</span> cust<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>"）:"</span><span>)</span><span>;</span>
        <span>String</span> name <span>=</span> <span>CMUtility</span><span>.</span><span>readString</span><span>(</span><span>10</span><span>,</span> cust<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>"性别("</span> <span>+</span> cust<span>.</span><span>getGender</span><span>(</span><span>)</span> <span>+</span> <span>"）:"</span><span>)</span><span>;</span>
        <span>char</span> gender <span>=</span> <span>CMUtility</span><span>.</span><span>readChar</span><span>(</span>cust<span>.</span><span>getGender</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>"年龄("</span> <span>+</span> cust<span>.</span><span>getAge</span><span>(</span><span>)</span> <span>+</span> <span>"）:"</span><span>)</span><span>;</span>
        <span>int</span> age <span>=</span> <span>CMUtility</span><span>.</span><span>readInt</span><span>(</span>cust<span>.</span><span>getAge</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>"电话("</span> <span>+</span> cust<span>.</span><span>getPhone</span><span>(</span><span>)</span> <span>+</span> <span>"）:"</span><span>)</span><span>;</span>
        <span>String</span> phone <span>=</span> <span>CMUtility</span><span>.</span><span>readString</span><span>(</span><span>13</span><span>,</span> cust<span>.</span><span>getPhone</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>"邮箱("</span> <span>+</span> cust<span>.</span><span>getEmail</span><span>(</span><span>)</span> <span>+</span> <span>"）:"</span><span>)</span><span>;</span>
        <span>String</span> email <span>=</span> <span>CMUtility</span><span>.</span><span>readString</span><span>(</span><span>13</span><span>,</span> cust<span>.</span><span>getEmail</span><span>(</span><span>)</span><span>)</span><span>;</span>

        <span>Customer</span> newCust <span>=</span> <span>new</span> <span>Customer</span><span>(</span>name<span>,</span> gender<span>,</span> age<span>,</span> phone<span>,</span> email<span>)</span><span>;</span>

        <span>boolean</span> isRepalaced <span>=</span> customerList<span>.</span><span>replaceCustomer</span><span>(</span>index <span>-</span> <span>1</span><span>,</span> newCust<span>)</span><span>;</span>
        <span>if</span><span>(</span>isRepalaced<span>)</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"---------------------修改完成---------------------"</span><span>)</span><span>;</span>
        <span>}</span><span>else</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"----------无法找到指定客户,修改失败--------------"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>/**
     * @description: 删除客户的操作
     * @author  bit
     * @date    2021/11/25 11:21
     */</span>
    <span>private</span> <span>void</span> <span>deleteCustomer</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"---------------------删除客户---------------------"</span><span>)</span><span>;</span>
        <span>Customer</span> customer<span>;</span>
        <span>int</span> index<span>;</span>
        <span>for</span><span>(</span><span>;</span><span>;</span><span>)</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>"请选择待删除客户编号(-1退出)："</span><span>)</span><span>;</span>
            index <span>=</span> <span>CMUtility</span><span>.</span><span>readInt</span><span>(</span><span>)</span><span>;</span>
            <span>if</span><span>(</span>index <span>==</span> <span>-</span><span>1</span><span>)</span><span>{</span>
                <span>return</span><span>;</span>
            <span>}</span>
            customer <span>=</span> customerList<span>.</span><span>getCustomer</span><span>(</span>index <span>-</span> <span>1</span><span>)</span><span>;</span>
            <span>if</span> <span>(</span>customer <span>==</span> <span>null</span><span>)</span><span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"无法找到指定客户！"</span><span>)</span><span>;</span>
            <span>}</span> <span>else</span><span>{</span>
                <span>break</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>//找到了指定用户</span>
        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>"确认是否删除(Y/N)："</span><span>)</span><span>;</span>
        <span>char</span> isDelete <span>=</span> <span>CMUtility</span><span>.</span><span>readConfirmSelection</span><span>(</span><span>)</span><span>;</span>
        <span>if</span><span>(</span>isDelete <span>==</span> <span>'Y'</span><span>)</span><span>{</span>
            <span>boolean</span> deleteSuccess <span>=</span> customerList<span>.</span><span>deleteCustomer</span><span>(</span>index <span>-</span> <span>1</span><span>)</span><span>;</span>
            <span>if</span><span>(</span>deleteSuccess<span>)</span><span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"---------------------删除完成---------------------"</span><span>)</span><span>;</span>
            <span>}</span><span>else</span><span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"----------无法找到指定客户,删除失败--------------"</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>


    <span>}</span>
    <span>/**
     * @description: 显示客户的操作
     * @author  bit
     * @date    2021/11/25 11:21
     */</span>
    <span>private</span> <span>void</span> <span>listAllCustomers</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"---------------------------客户列表---------------------------"</span><span>)</span><span>;</span>
        <span>int</span> total <span>=</span> customerList<span>.</span><span>getTotal</span><span>(</span><span>)</span><span>;</span>
        <span>if</span><span>(</span>total <span>==</span> <span>0</span><span>)</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"没有客户信息"</span><span>)</span><span>;</span>
        <span>}</span><span>else</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"编号\t姓名\t\t性别\t\t年龄\t\t电话\t\t\t\t邮箱"</span><span>)</span><span>;</span>
            <span>Customer</span><span>[</span><span>]</span> custs <span>=</span> customerList<span>.</span><span>getAllCustomers</span><span>(</span><span>)</span><span>;</span>
            <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span>i <span>&lt;</span> custs<span>.</span>length<span>;</span>i<span>++</span><span>)</span><span>{</span>
                <span>Customer</span> cust <span>=</span> custs<span>[</span>i<span>]</span><span>;</span>
               <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i <span>+</span> <span>1</span> <span>+</span> <span>"\t"</span> <span>+</span> custs<span>[</span>i<span>]</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>"\t\t"</span> <span>+</span> custs<span>[</span>i<span>]</span><span>.</span><span>getGender</span><span>(</span><span>)</span> <span>+</span> <span>"\t\t"</span> <span>+</span> custs<span>[</span>i<span>]</span><span>.</span><span>getAge</span><span>(</span><span>)</span> <span>+</span> <span>"\t\t"</span> <span>+</span> custs<span>[</span>i<span>]</span><span>.</span><span>getPhone</span><span>(</span><span>)</span> <span>+</span> <span>"\t\t"</span> <span>+</span> custs<span>[</span>i<span>]</span><span>.</span><span>getEmail</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>

        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"-------------------------客户列表完成-------------------------"</span><span>)</span><span>;</span>

    <span>}</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span><span>{</span>
        <span>CustomerView</span> view <span>=</span> <span>new</span> <span>CustomerView</span><span>(</span><span>)</span><span>;</span>
        view<span>.</span><span>enterMainMenu</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br><span>170</span><br><span>171</span><br><span>172</span><br><span>173</span><br><span>174</span><br><span>175</span><br><span>176</span><br><span>177</span><br><span>178</span><br><span>179</span><br><span>180</span><br><span>181</span><br><span>182</span><br><span>183</span><br><span>184</span><br><span>185</span><br><span>186</span><br><span>187</span><br><span>188</span><br><span>189</span><br><span>190</span><br><span>191</span><br><span>192</span><br><span>193</span><br><span>194</span><br><span>195</span><br><span>196</span><br></div></div><h3 id="项目简图"> 项目简图</h3>
<p><img src="./images/04类与面向对象/image-20211125221001736.png" alt="image-20211125221001736" /></p>
<h2 id="面向对象特征之二-继承性"> 面向对象特征之二：继承性</h2>
<h3 id="继承性的好处-why"> 继承性的好处（why？）</h3>
<ol>
<li>减少了代码的冗余</li>
<li>便于功能的扩展</li>
<li>为之后多态性的使用，提供了前提</li>
</ol>
<h3 id="继承性的格式"> 继承性的格式</h3>
<ul>
<li><code>class A extends B{}</code>
<ul>
<li>A: 子类、派生类、subclass</li>
<li>B: 父类、超类、基类、superclass</li>
</ul>
</li>
<li>体现：一旦子类A继承父类B之后，子类A中就获取了父类B中声明的结构：所有的属性和方法
<ul>
<li>包括私有的属性与方法，但外部调用时需要提供方法</li>
<li>特别的，父类中声明为private的属性或方法，子类继承父类以后，是会获取到父类中私有的结构，只是因为封装性的影响，使得子类不能直接调用父类的结构</li>
</ul>
</li>
<li>子类继承父类以后，还可以声明自己特有的属性或方法，实现功能的扩展
<ul>
<li>子类和父类的关系，不同于子集和集合的关系</li>
<li>extends: 延展、扩展</li>
</ul>
</li>
</ul>
<h3 id="java中关于继承性的规定"> Java中关于继承性的规定</h3>
<ul>
<li>
<p>java中<strong>只支持单继承和多层继承</strong>，不允许多重继承</p>
<ul>
<li>一个子类只能有一个父类</li>
<li>一个父类可以派生楚多个子类
<ul>
<li><code>class SubDemo extends Demo{}</code></li>
</ul>
</li>
</ul>
<p><img src="./images/04类与面向对象/image-20211126203407273.png" alt="image-20211126203407273" /></p>
</li>
<li>
<p>多重继承在C++语言中支持</p>
<img src="images/04类与面向对象/image-20211126203441392.png" alt="image-20211126203441392" style="zoom:50%;" />
</li>
</ul>
<ol>
<li>
<p>一个类可以被多个子类继承</p>
</li>
<li>
<p>java中类中的单继承性：一个类只能有一个父类</p>
</li>
<li>
<p>子父类是相对的概念</p>
</li>
<li>
<p>子类直接继承的父类，称为<strong>直接父类</strong>；间接继承的父类称为间接父类</p>
<p>下图中Student是Graduate的直接父类，Person是Graduate的间接父类</p>
<p><img src="./images/04类与面向对象/image-20211126203656178.png" alt="image-20211126203656178" /></p>
</li>
<li>
<p>子类继承父类以后，就获取了<strong>直接父类以及所有间接父类中声明的属性和方法</strong></p>
</li>
</ol>
<h3 id="object的继承性"> Object的继承性</h3>
<ol>
<li>如果我们没有显式的声明一个类的父类的话，则此类继承于<code>java.lang.Object</code>类</li>
<li>所有的java类（除<code>java.lang.Object</code>之外）都直接或间接继承于<code>java.lang.Object</code></li>
<li>也就意味着，所有的java类都具有<code>java.lang.Object</code>类声明的功能</li>
</ol>
<h3 id="具体的代码"> 具体的代码</h3>
<ul>
<li>
<p><code>Crature</code>继承给<code>Person</code>，<code>Person</code>继承给<code>Student</code></p>
</li>
<li>
<p>对于<code>Student</code>来说，<code>Crature</code>是间接继承，Person是直接继承</p>
</li>
<li>
<p><code>ExtendsTest</code>负责这三者的测试与调用</p>
</li>
<li>
<p>注意这里的package请以你本地的package（文件夹）实际为准</p>
</li>
</ul>
<div><pre><code><span>// Crature.java</span>
<span>package</span> <span>day11<span>.</span>java</span><span>;</span>

<span>public</span> <span>class</span> <span>Crature</span> <span>{</span>
    <span>public</span> <span>void</span> <span>breath</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"呼吸"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code><span>//Person.java</span>
<span>package</span> <span>day11<span>.</span>java</span><span>;</span>

<span>public</span> <span>class</span> <span>Person</span> <span>extends</span> <span>Crature</span><span>{</span>
    <span>String</span> name<span>;</span>
    <span>private</span> <span>int</span> age<span>;</span>

    <span>public</span> <span>Person</span><span>(</span><span>)</span> <span>{</span>
    <span>}</span>

    <span>public</span> <span>Person</span><span>(</span><span>String</span> name<span>,</span> <span>int</span> age<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>eat</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"吃饭"</span><span>)</span><span>;</span>
        <span>sleep</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    <span>private</span> <span>void</span> <span>sleep</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"睡觉"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getAge</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> age<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setAge</span><span>(</span><span>int</span> age<span>)</span> <span>{</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><div><pre><code><span>//Student.java</span>
<span>package</span> <span>day11<span>.</span>java</span><span>;</span>

<span>public</span> <span>class</span> <span>Student</span> <span>extends</span> <span>Person</span><span>{</span>
    <span>String</span> major<span>;</span>

    <span>public</span> <span>Student</span><span>(</span><span>)</span> <span>{</span>
    <span>}</span>

    <span>public</span> <span>Student</span><span>(</span><span>String</span> name<span>,</span> <span>int</span> age<span>,</span> <span>String</span> major<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
        <span>// this.age = age;</span>
        <span>setAge</span><span>(</span>age<span>)</span><span>;</span>
        <span>this</span><span>.</span>major <span>=</span> major<span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>study</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"学习"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>show</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"name: "</span> <span>+</span> name <span>+</span> <span>", age: "</span> <span>+</span> <span>getAge</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><div><pre><code><span>//ExtendsTest.java</span>
<span>package</span> <span>day11<span>.</span>java</span><span>;</span>

<span>public</span> <span>class</span> <span>ExtendsTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Person</span> p1 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span>
        <span>// p1.age = 1;</span>
        p1<span>.</span><span>eat</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span>

        <span>Student</span> s1 <span>=</span> <span>new</span> <span>Student</span><span>(</span><span>)</span><span>;</span>
        s1<span>.</span><span>eat</span><span>(</span><span>)</span><span>;</span>
        <span>// s1.sleep();</span>
        s1<span>.</span>name <span>=</span> <span>"小米"</span><span>;</span>
        s1<span>.</span><span>setAge</span><span>(</span><span>10</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s1<span>.</span><span>getAge</span><span>(</span><span>)</span><span>)</span><span>;</span>

        s1<span>.</span><span>breath</span><span>(</span><span>)</span><span>;</span>

        <span>Crature</span> c <span>=</span> <span>new</span> <span>Crature</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>c<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h3 id="练习1-人"> 练习1 - 人</h3>
<ul>
<li>
<p>定义一个ManKind类，包括</p>
<ul>
<li>
<p>成员变量int sex和int salary；</p>
</li>
<li>
<p>方法void manOrWoman()：根据sex的值显示“man” (sex==1)或者“woman”(sex==0)；</p>
</li>
<li>
<p>方法void employeed()：根据salary的值显示“no job” (salary==0)或者“ job”(salary!=0)。</p>
</li>
</ul>
</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>ManKind</span> <span>{</span>
    <span>private</span> <span>int</span> sex<span>;</span><span>//性别</span>
    <span>private</span> <span>int</span> salary<span>;</span><span>//薪资</span>

    <span>public</span> <span>ManKind</span><span>(</span><span>)</span> <span>{</span>
    <span>}</span>

    <span>public</span> <span>ManKind</span><span>(</span><span>int</span> sex<span>,</span> <span>int</span> salary<span>)</span> <span>{</span>
        <span>this</span><span>.</span>sex <span>=</span> sex<span>;</span>
        <span>this</span><span>.</span>salary <span>=</span> salary<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>manOrWoman</span><span>(</span><span>)</span><span>{</span>
        <span>if</span> <span>(</span>sex <span>==</span> <span>1</span><span>)</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"man"</span><span>)</span><span>;</span>
        <span>}</span><span>else</span> <span>if</span><span>(</span>sex <span>==</span> <span>0</span><span>)</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"woman"</span><span>)</span><span>;</span>
        <span>}</span>

    <span>}</span>
    <span>public</span> <span>void</span> <span>employeed</span><span>(</span><span>)</span><span>{</span>
        <span>// if (salary == 0){</span>
        <span>//     System.out.println("no job");</span>
        <span>// }else{</span>
        <span>//     System.out.println("job");</span>
        <span>// }</span>
        <span>//或 三元写法</span>
        <span>String</span> jobInfo <span>=</span> <span>(</span>salary <span>==</span> <span>0</span><span>)</span> <span>?</span> <span>"no job"</span> <span>:</span> <span>"job"</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>jobInfo<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getSex</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> sex<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setSex</span><span>(</span><span>int</span> sex<span>)</span> <span>{</span>
        <span>this</span><span>.</span>sex <span>=</span> sex<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getSalary</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> salary<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setSalary</span><span>(</span><span>int</span> salary<span>)</span> <span>{</span>
        <span>this</span><span>.</span>salary <span>=</span> salary<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><ul>
<li>
<p>定义类Kids继承ManKind，并包括</p>
<ul>
<li>
<p>成员变量int yearsOld；</p>
</li>
<li>
<p>方法printAge()打印yearsOld的值。</p>
</li>
</ul>
</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>Kids</span> <span>extends</span> <span>ManKind</span><span>{</span>
    <span>private</span> <span>int</span> yearsOld<span>;</span>

    <span>public</span> <span>Kids</span><span>(</span><span>)</span> <span>{</span>
    <span>}</span>

    <span>public</span> <span>Kids</span><span>(</span><span>int</span> yearsOld<span>)</span> <span>{</span>
        <span>this</span><span>.</span>yearsOld <span>=</span> yearsOld<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>printAge</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"I am "</span> <span>+</span> yearsOld <span>+</span> <span>"year old."</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getYearsOld</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> yearsOld<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setYearsOld</span><span>(</span><span>int</span> yearsOld<span>)</span> <span>{</span>
        <span>this</span><span>.</span>yearsOld <span>=</span> yearsOld<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><ul>
<li>定义类KidsTest，在类的main方法中实例化Kids的对象someKid，用该对象访问
其父类的成员变量及方法。</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>KidsTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Kids</span> someKid <span>=</span> <span>new</span> <span>Kids</span><span>(</span><span>12</span><span>)</span><span>;</span>
        someKid<span>.</span><span>printAge</span><span>(</span><span>)</span><span>;</span>

        someKid<span>.</span><span>setSalary</span><span>(</span><span>0</span><span>)</span><span>;</span>
        someKid<span>.</span><span>setSex</span><span>(</span><span>1</span><span>)</span><span>;</span>

        someKid<span>.</span><span>employeed</span><span>(</span><span>)</span><span>;</span>
        someKid<span>.</span><span>manOrWoman</span><span>(</span><span>)</span><span>;</span>

    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="练习2-圆柱"> 练习2 - 圆柱</h3>
<ul>
<li>Circle</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>Circle</span> <span>{</span>
    <span>private</span> <span>double</span> radius<span>;</span><span>//半径</span>

    <span>public</span> <span>Circle</span><span>(</span><span>)</span> <span>{</span>
        radius <span>=</span> <span>1</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>double</span> <span>getRadius</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> radius<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setRadius</span><span>(</span><span>double</span> radius<span>)</span> <span>{</span>
        <span>this</span><span>.</span>radius <span>=</span> radius<span>;</span>
    <span>}</span>
    <span>/**
     * @description: 返回圆的面积
     * @return  double
     * @author  bit
     * @date    2021/11/27 11:14
     */</span>
    <span>public</span> <span>double</span> <span>findArea</span><span>(</span><span>)</span><span>{</span>
        <span>return</span> <span>Math</span><span>.</span>PI <span>*</span> radius <span>*</span> radius<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><ul>
<li>Cylinder</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>Cylinder</span> <span>extends</span> <span>Circle</span><span>{</span>
    <span>private</span> <span>double</span> length<span>;</span><span>//高</span>

    <span>public</span> <span>Cylinder</span><span>(</span><span>)</span> <span>{</span>
        length <span>=</span> <span>1.0</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>double</span> <span>getLength</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> length<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setLength</span><span>(</span><span>double</span> length<span>)</span> <span>{</span>
        <span>this</span><span>.</span>length <span>=</span> length<span>;</span>
    <span>}</span>
    <span>//圆柱的体积</span>
    <span>public</span> <span>double</span> <span>findVolume</span><span>(</span><span>)</span><span>{</span>
        <span>// return Math.PI * getRadius() * getRadius() * getLength();</span>
        <span>return</span> <span>findArea</span><span>(</span><span>)</span> <span>*</span> <span>getLength</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><ul>
<li>CylinderTest
<ul>
<li>在CylinderTest类中创建Cylinder类的对象，设置圆
柱的底面半径和高，并输出圆柱的体积</li>
</ul>
</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>CylinderTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Cylinder</span> cy <span>=</span> <span>new</span> <span>Cylinder</span><span>(</span><span>)</span><span>;</span>
        cy<span>.</span><span>setRadius</span><span>(</span><span>2.1</span><span>)</span><span>;</span>
        cy<span>.</span><span>setLength</span><span>(</span><span>3.4</span><span>)</span><span>;</span>

        <span>double</span> volume <span>=</span> cy<span>.</span><span>findVolume</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"圆柱的体积为："</span> <span>+</span> volume<span>)</span><span>;</span>

        <span>double</span> area <span>=</span> cy<span>.</span><span>findArea</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"圆柱的底面积为："</span> <span>+</span> area<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="debug调试"> Debug调试</h2>
<p>day12</p>
<p>debug的方法：</p>
<ul>
<li>硬看</li>
<li>调试程序
<ol>
<li><code>System.out.println();</code>使用输出语句输出，缺点是不适应于代码量多的情况</li>
<li>使用编辑器自带的Debug调试功能
<ul>
<li>设置断点即可在调试时查看变量的变化
<ul>
<li><code>Step Over</code>下一步</li>
<li><code>Step Into</code>可以查看使用的方法</li>
<li><code>Resume Program</code>是执行到下一个断点</li>
<li><code>Drop Frame</code>是返回上一层</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="方法的重写-override-overwrite"> 方法的重写（Override/Overwrite）</h2>
<ul>
<li>
<p>概念</p>
<ul>
<li>定义
<ul>
<li>在子类中可以根据需要对父类中继承来的方法进行改造，也常称为方法的<strong>重置、覆盖</strong>。在程序执行</li>
</ul>
</li>
<li>要求
<ol>
<li>子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表</li>
<li>子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型</li>
<li>子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限
<ul>
<li>子类不能重写父类中声明为 private1权限的方法</li>
</ul>
</li>
<li>子类方法抛出的异常不能大于父类被重写方法的异常</li>
</ol>
</li>
<li>注意
<ul>
<li>子类与父类中同名同参数的方法必须同时声明为非 static的（即为重写），或者同时声明为
static的（不是重写）。因为 static方法是属于类的，子类无法爱盖父类的方法。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>重载：overload</p>
</li>
<li>
<p>重写：override</p>
</li>
</ul>
<ol>
<li>
<p>重写：子类继承父类以后，可以对父类中同名同参数的方法进行覆盖操作</p>
</li>
<li>
<p>应用：重写以后，当创建子类对象以后，通过子类对象调用子父类中同名同参的方法时，实际执行的是子类重写父类的方法</p>
</li>
<li>
<p>重写的规定：</p>
<ul>
<li>方法的声明：<div><pre><code><span>@Override</span>
权限修饰符 返回值类下 方法名<span>(</span>参数列表<span>)</span> <span>throws</span> 异常的类型<span>{</span>
              <span>//方法体</span>
         <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
<li>约定俗称：子类中的叫重写方法，父类中的叫被重写方法</li>
<li>使用重写，建议在其上面添加<code>@Override</code>(注解)，这样可以避免被重写函数变动导致重写的函数独立成一个新的函数</li>
</ul>
<ol>
<li>子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同</li>
<li>子类重写的方法的权限修饰符需要不小于等于被重写的方法的权限修饰符
<ul>
<li>特殊的：子类中不能重写父类中声明为private权限的方法
<ul>
<li>如果按着此方法，则只会调用父类中private的方法，而非子函数的</li>
</ul>
</li>
</ul>
</li>
<li>返回值类型：
<ul>
<li>父类被重写的方法的返回值类型是void，则子类重写的方法返回值类型只能是void</li>
<li>父类被重写的方法的返回值类型是A类型，则子类重写的方法返回值类型可以是A类或A类的子类</li>
<li>父类被重写的方法的返回值类型是基本数据类型，则子类重写的方法返回值类型必须是相同的基本数据类型
<ul>
<li>如果父是double，则子也必须是double（double与int没有子父类关系，他们是平行关系）</li>
</ul>
</li>
</ul>
</li>
<li>子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（具体见异常处理章节中）</li>
</ol>
</li>
</ol>
<ul>
<li>
<p>额外的</p>
<ul>
<li>子类和父类中的同名参数的方法要么都声明为非static的(再考虑重写)，要么都声明为static的(非重写)</li>
</ul>
</li>
<li>
<p>面试题：区分方法的重载与重写</p>
</li>
<li>
<p>通过Person&amp;Student&amp;Person来解释</p>
<div><pre><code><span>//Person.java</span>
<span>package</span> <span>day12<span>.</span>java1</span><span>;</span>

<span>public</span> <span>class</span> <span>Person</span> <span>{</span>
    <span>String</span> name<span>;</span>
    <span>int</span> age<span>;</span>

    <span>public</span> <span>Person</span><span>(</span><span>)</span> <span>{</span>
    <span>}</span>

    <span>public</span> <span>Person</span><span>(</span><span>String</span> name<span>,</span> <span>int</span> age<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
    <span>}</span>
    <span>//若这里使用static，则Student也需要使用static</span>
    <span>// static void eat(){</span>
    <span>void</span> <span>eat</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"吃饭"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>walk</span><span>(</span><span>int</span> distance<span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"走路走的距离是："</span> <span>+</span> distance <span>+</span> <span>"公里"</span><span>)</span><span>;</span>
        <span>show</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    <span>private</span> <span>void</span> <span>show</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"I am a man"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>Object</span> <span>info</span><span>(</span><span>)</span><span>{</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>double</span> <span>info1</span><span>(</span><span>)</span><span>{</span>
        <span>return</span> <span>1.0</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><div><pre><code><span>//Student.java</span>
<span>package</span> <span>day12<span>.</span>java1</span><span>;</span>

<span>public</span> <span>class</span> <span>Student</span> <span>extends</span> <span>Person</span> <span>{</span>
    <span>String</span> major<span>;</span>

    <span>public</span> <span>Student</span><span>(</span><span>)</span> <span>{</span>
    <span>}</span>

    <span>public</span> <span>Student</span><span>(</span><span>String</span> major<span>)</span> <span>{</span>
        <span>this</span><span>.</span>major <span>=</span> major<span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>study</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"学习，专业是："</span> <span>+</span> major<span>)</span><span>;</span>
    <span>}</span>
    <span>//对父类中的eat()进行了重写</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>eat</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"学生在吃"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>show</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"I am a man"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>@Override</span>
    <span>public</span> <span>String</span> <span>info</span><span>(</span><span>)</span><span>{</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>}</span>
    <span>@Override</span>
    <span>public</span> <span>double</span> <span>info1</span><span>(</span><span>)</span><span>{</span>
        <span>return</span> <span>1</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>walk</span><span>(</span><span>int</span> distance<span>)</span> <span>{</span>
        <span>super</span><span>.</span><span>walk</span><span>(</span>distance<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><div><pre><code><span>//PersonTest.java</span>
<span>package</span> <span>day12<span>.</span>java1</span><span>;</span>
<span>public</span> <span>class</span> <span>PersonTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Student</span> s <span>=</span> <span>new</span> <span>Student</span><span>(</span><span>"CS class"</span><span>)</span><span>;</span>
        s<span>.</span><span>eat</span><span>(</span><span>)</span><span>;</span>
        <span>//这里可以看出输出的是Person的show()，而非Student的，因为Person的是private</span>
        s<span>.</span><span>walk</span><span>(</span><span>10</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"----------"</span><span>)</span><span>;</span>

        s<span>.</span><span>study</span><span>(</span><span>)</span><span>;</span>

        <span>Person</span> p1 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span>
        p1<span>.</span><span>eat</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div></li>
</ul>
<h3 id="练习-5"> 练习</h3>
<ol>
<li>如果现在父类的一个方法定义成private访问权限，在子类中将此方法声明为default访问权限，那么这样还叫重写吗？
<ul>
<li>不能</li>
</ul>
</li>
<li>修改1.2中定义的类Kids，在Kids中重写定义employee()方法，覆盖父类ManKind中定义的employeed()方法，输出”kids shouldstudy and no job&quot;</li>
</ol>
<h2 id="四种权限修饰-protected"> 四种权限修饰 - protected</h2>
<ul>
<li>
<p>protected大部分用于子类的继承当中</p>
</li>
<li>
<p>同一个包中的其他类，不可以调用Order类中私有的属性、方法</p>
</li>
<li>
<p>在不同包的子类中，不能调用Order类中声明为private和缺省权限的属性、方法</p>
</li>
<li>
<p>不同包下的普通类（非子类）要使用Order类，不可以调用声明为private、缺省、protected权限的属性、方法</p>
</li>
<li>
<p>具体见 day12-java1&amp;java2</p>
</li>
</ul>
<h2 id="关键字-super"> 关键字 - super</h2>
<ul>
<li>super关键字的使用
<ol>
<li>super理解为：父类的</li>
<li>super可以用来调用：属性、方法、构造器</li>
<li>super的使用
<ol>
<li>我们可以在子类的方法或构造器中，通过使用<code>super.属性</code>或<code>super.方法</code>的方式，显式的调用父类中声明的属性或方法。但是通常情况下，我们都习惯省略<code>super.**</code></li>
<li>特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用<code>super.属性</code>的方式，表明调用的时父类中声明的属性。</li>
<li>特殊情况：当子类重写了父类的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用<code>super.属性</code>的方式，表明调用的时父类中被重写的方法。</li>
</ol>
</li>
<li>super调用构造器
<ol>
<li>我们可以在子类的构造器中显式的使用<code>super(形参列表)</code>的方式，调用父类中声明的指定的构造器</li>
<li><code>super(形参列表)</code>的使用，必须声明在子类构造器的首行</li>
<li>在类的构造器中，正对于<code>this(形参列表)</code>或<code>super(形参列表)</code>只能二选一，不能同时出现</li>
<li>在构造器的首行，没有显式的声明<code>this(形参列表)</code>或<code>super(形参列表)</code>，则默认调用的时父类中空参的构造器，即<code>super()</code>
<ul>
<li>如果将父类的空参注释掉，则子类会报错，因为其子类会默认调用super()</li>
</ul>
</li>
</ol>
</li>
<li>在类的多个构造器中，至少有一个类的构造器中使用了<code>super(形参列表)</code>，调用父类中的构造器</li>
</ol>
</li>
</ul>
<h3 id="子类对象实例化过程"> 子类对象实例化过程</h3>
<ul>
<li>
<p>子类对象实例化的全过程</p>
<ol>
<li>从结果上来看：（继承性）
<ul>
<li>子类继承父类以后，就获取了父类中声明的属性或方法</li>
<li>创建子类的对象，在堆空间中，就会加载所有父类中声明的属性</li>
</ul>
</li>
<li>从过程上来看：
<ul>
<li>当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器进而父类的父类构造器，直到调用到<code>java.lang.Object</code>类中空参的构造器为止.正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用。</li>
</ul>
</li>
</ol>
</li>
<li>
<p>明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象</p>
</li>
</ul>
<p><img src="./images/04类与面向对象/image-20211130203403586.png" alt="image-20211130203403586" /></p>
<h3 id="课后实验"> 课后实验</h3>
<ul>
<li>
<p>Account</p>
<div><pre><code><span>package</span> <span>day12<span>.</span>exer2</span><span>;</span>

<span>public</span> <span>class</span> <span>Account</span> <span>{</span>
    <span>private</span> <span>int</span> id<span>;</span>
    <span>private</span> <span>double</span> balance<span>;</span>
    <span>private</span> <span>double</span> annualInterestRate<span>;</span>


    <span>public</span> <span>Account</span><span>(</span><span>int</span> id<span>,</span> <span>double</span> balance<span>,</span> <span>double</span> annualInterestRate<span>)</span> <span>{</span>
        <span>super</span><span>(</span><span>)</span><span>;</span>
        <span>this</span><span>.</span>id <span>=</span> id<span>;</span><span>//账号</span>
        <span>this</span><span>.</span>balance <span>=</span> balance<span>;</span><span>//余额</span>
        <span>this</span><span>.</span>annualInterestRate <span>=</span> annualInterestRate<span>;</span><span>//年利率</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getId</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> id<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setId</span><span>(</span><span>int</span> id<span>)</span> <span>{</span>
        <span>this</span><span>.</span>id <span>=</span> id<span>;</span>
    <span>}</span>

    <span>public</span> <span>double</span> <span>getBalance</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> balance<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setBalance</span><span>(</span><span>double</span> balance<span>)</span> <span>{</span>
        <span>this</span><span>.</span>balance <span>=</span> balance<span>;</span>
    <span>}</span>

    <span>public</span> <span>double</span> <span>getannualInterestRate</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> annualInterestRate<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setannualInterestRate</span><span>(</span><span>double</span> annualInterestRate<span>)</span> <span>{</span>
        <span>this</span><span>.</span>annualInterestRate <span>=</span> annualInterestRate<span>;</span>
    <span>}</span>
    <span>/**
     * @description: 返回月利率
     * @return  double
     * @author  bit
     * @date    2021/12/2 18:54
     */</span>
    <span>public</span> <span>double</span> <span>getMonthlylnterest</span><span>(</span><span>)</span><span>{</span>
        <span>return</span> annualInterestRate <span>/</span> <span>12</span><span>;</span>
    <span>}</span>
    <span>/**
     * @description: 取钱
     * @param   amount 账户
     * @author  bit
     * @date    2021/12/2 18:56
     */</span>
    <span>public</span> <span>void</span> <span>withdraw</span><span>(</span><span>double</span> amount<span>)</span> <span>{</span>
        <span>if</span><span>(</span>balance <span>>=</span> amount<span>)</span><span>{</span>
            balance <span>-=</span> amount<span>;</span>
            <span>return</span><span>;</span>
        <span>}</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"余额不足"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>/**
     * @description: 存钱
     * @param   amount 账户
     * @author  bit
     * @date    2021/12/2 18:56
     */</span>
    <span>public</span> <span>void</span> <span>deposit</span><span>(</span><span>double</span> amount<span>)</span> <span>{</span>
        <span>if</span><span>(</span>amount <span>></span> <span>0</span><span>)</span><span>{</span>
            balance <span>+=</span> amount<span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br></div></div></li>
<li>
<p>AccountTest</p>
<ul>
<li>写一个用户程序测试Account类。在用户程序中，
创建一个账号为1122、余额为20000、年利率4.5%的Account对象。
使用withdraw方法提款30000元，并打印余额。
再使用withdraw方法提款2500元，
使用deposit方法存款3000元，然后打印余额和月利率。</li>
</ul>
<div><pre><code><span>/**
 * @description: 账户测试类
 * @author  bit
 * @date    2021/12/2 18:57
 */</span>
<span>public</span> <span>class</span> <span>AccountTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Account</span> a <span>=</span> <span>new</span> <span>Account</span><span>(</span><span>1122</span><span>,</span> <span>2000</span><span>,</span> <span>0.045</span><span>)</span><span>;</span>
        a<span>.</span><span>withdraw</span><span>(</span><span>30000</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"您的账户余额为："</span> <span>+</span> a<span>.</span><span>getBalance</span><span>(</span><span>)</span><span>)</span><span>;</span>

        a<span>.</span><span>withdraw</span><span>(</span><span>2500</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"您的账户余额为："</span> <span>+</span> a<span>.</span><span>getBalance</span><span>(</span><span>)</span><span>)</span><span>;</span>
        a<span>.</span><span>deposit</span><span>(</span><span>3000</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"您的账户余额为："</span> <span>+</span> a<span>.</span><span>getBalance</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"您的账户月利率为："</span> <span>+</span> a<span>.</span><span>getannualInterestRate</span><span>(</span><span>)</span><span>*</span><span>100</span> <span>+</span> <span>"%"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div></li>
<li>
<p>CheckAccount</p>
<ul>
<li>创建Account类的一个子类CheckAccount代表可透支的账户，该账户中定义一个属性overdraft代表可透支限额。
在CheckAccount类中重写withdraw方法，其算法如下：
如果（取款金额&lt;账户余额），
可直接取款
如果（取款金额&gt;账户余额），
计算需要透支的额度
判断可透支额overdraft是否足够支付本次透支需要，如果可以
将账户余额修改为0，冲减可透支金额
如果不可以
提示用户超过可透支额的限额</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>CheckAccount</span> <span>extends</span> <span>Account</span><span>{</span>
    <span>private</span> <span>double</span> overdraft<span>;</span><span>//可透支限额</span>

    <span>public</span> <span>CheckAccount</span><span>(</span><span>int</span> id<span>,</span> <span>double</span> balance<span>,</span> <span>double</span> annualInterestRate<span>,</span> <span>double</span> overdraft<span>)</span> <span>{</span>
        <span>super</span><span>(</span>id<span>,</span> balance<span>,</span> annualInterestRate<span>)</span><span>;</span>
        <span>this</span><span>.</span>overdraft <span>=</span> overdraft<span>;</span>
    <span>}</span>

    <span>public</span> <span>double</span> <span>getOverdraft</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> overdraft<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setOverdraft</span><span>(</span><span>double</span> overdraft<span>)</span> <span>{</span>
        <span>this</span><span>.</span>overdraft <span>=</span> overdraft<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>withdraw</span><span>(</span><span>double</span> amount<span>)</span> <span>{</span>
        <span>if</span><span>(</span><span>getBalance</span><span>(</span><span>)</span> <span>>=</span> amount<span>)</span><span>{</span><span>//余额足够消费</span>
            <span>//方式一</span>
            <span>// setBalance(getBalance() - amount);</span>
            <span>//方式二，调用父类的取钱方式</span>
            <span>super</span><span>.</span><span>withdraw</span><span>(</span>amount<span>)</span><span>;</span>
        <span>}</span><span>else</span> <span>if</span><span>(</span>overdraft <span>>=</span> amount <span>-</span> <span>getBalance</span><span>(</span><span>)</span><span>)</span><span>{</span><span>//透支额度+余额足够消费</span>
            overdraft <span>-=</span> amount <span>-</span> <span>getBalance</span><span>(</span><span>)</span><span>;</span>
            <span>//setBalance(0);</span>
            <span>//或</span>
            <span>super</span><span>.</span><span>withdraw</span><span>(</span><span>getBalance</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span><span>else</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"超过可透支额的限额！"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div></li>
<li>
<p>CheckAccountTest</p>
<ul>
<li>写一个用户程序测试CheckAccount类。
在用户程序中，创建一个账号为1122、余额为20000、年利率4.5%，可透支限额为5000元的CheckAccount对象。
使用withdraw方法提款5000元，并打印账户余额和可透支额。
再使用withdraw方法提款18000元，并打印账户余额和可透支额。
再使用withdraw方法提款3000元，并打印账户余额和可透支额。</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>CheckAccountTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>CheckAccount</span> acct <span>=</span> <span>new</span> <span>CheckAccount</span><span>(</span><span>1122</span><span>,</span> <span>20000</span><span>,</span> <span>0.045</span><span>,</span> <span>5000</span><span>)</span><span>;</span>

        acct<span>.</span><span>withdraw</span><span>(</span><span>5000</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"您的账户余额为："</span> <span>+</span> acct<span>.</span><span>getBalance</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"您的可透支额度为："</span> <span>+</span> acct<span>.</span><span>getOverdraft</span><span>(</span><span>)</span><span>)</span><span>;</span>
        acct<span>.</span><span>withdraw</span><span>(</span><span>18000</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"您的账户余额为："</span> <span>+</span> acct<span>.</span><span>getBalance</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"您的可透支额度为："</span> <span>+</span> acct<span>.</span><span>getOverdraft</span><span>(</span><span>)</span><span>)</span><span>;</span>
        acct<span>.</span><span>withdraw</span><span>(</span><span>3000</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"您的账户余额为："</span> <span>+</span> acct<span>.</span><span>getBalance</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"您的可透支额度为："</span> <span>+</span> acct<span>.</span><span>getOverdraft</span><span>(</span><span>)</span><span>)</span><span>;</span>

    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div></li>
</ul>
<h2 id="面向对象特征之三-多态性"> 面向对象特征之三：多态性</h2>
<p>day13</p>
<ul>
<li>
<p>概念</p>
<ul>
<li>
<p>多态性，是面向对象中最重要的概念，在java中的体现：</p>
<ul>
<li><strong>对象的多态性：父类的引用指向子类的对象</strong>
<ul>
<li>可以直接应用在抽象类和接口上</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Java引用变量有两个类型： <strong>编译时类型和运行时类型</strong>。 编译时类型由声明该变量时使用的类型决定， 运行时类型由实际赋给该变量的对象决定。 简称： 编译时， 看左边；运行时， 看右边。</p>
<ul>
<li><strong>若编译时类型和运行时类型不一致， 就出现了对象的多态性(Polymorphism)</strong></li>
<li>多态情况下，
<ul>
<li><strong>“看左边” ：</strong> 看的是父类的引用（父类中不具备子类特有的方法）</li>
<li><strong>“看右边” ：</strong> 看的是子类的对象（实际运行的是子类重写父类的方法）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>理解多态性：可以理解为一个事物的多种形态</li>
<li>何为多态性
<ul>
<li>对象的多态性:父类的引用指向子类的对象（或子类的对象赋给父类的引用）</li>
</ul>
</li>
<li>多态的使用：<strong>虚拟方法的使用</strong>
<ul>
<li>有了对象的多态性以后：我们在编译器只能调用父类中声明的方法，但在运行时，我们实际执行的时子类重写父类的方法</li>
<li><strong>总结：编译，看左边(父类)；运行，看右边(子类)</strong></li>
</ul>
</li>
<li>多态性的使用前提：
<ol>
<li>要有类的继承关系</li>
<li>要有方法的重写</li>
</ol>
</li>
<li>对象的多态性，只适用于方法，不适用于属性，属性是不存在多态性的**（编译和运行都看左边）**</li>
<li></li>
</ol>
<h3 id="多态性的使用举例"> 多态性的使用举例</h3>
<div><pre><code><span>package</span> <span>day12<span>.</span>java4</span><span>;</span>

<span>import</span> <span>java<span>.</span>sql<span>.</span></span><span>Connection</span><span>;</span>
<span>/*
多态性的使用举例一：

 */</span>
<span>public</span> <span>class</span> <span>AnimalTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>AnimalTest</span> test <span>=</span> <span>new</span> <span>AnimalTest</span><span>(</span><span>)</span><span>;</span>
        <span>//Animal animal = new Dog();//声明的是animal，实际上是new的Dog</span>
        test<span>.</span><span>func</span><span>(</span><span>new</span> <span>Dog</span><span>(</span><span>)</span><span>)</span><span>;</span>
        test<span>.</span><span>func</span><span>(</span><span>new</span> <span>Cat</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
    <span>//有继承性的情况</span>
    <span>public</span> <span>void</span> <span>func</span><span>(</span><span>Animal</span> animal<span>)</span><span>{</span>
        animal<span>.</span><span>eat</span><span>(</span><span>)</span><span>;</span>
        animal<span>.</span><span>shout</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    <span>//无继承性的情况，需要重复构造多个重载</span>
    <span>/*
    public void func(Dog dog){
        dog.eat();
        dog.shout();
    }
    public void func(Cat cat){
        cat.eat();
        cat.shout();
    }*/</span>
<span>}</span>
<span>class</span> <span>Animal</span><span>{</span>
    <span>public</span> <span>void</span> <span>eat</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"动物，进食"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>shout</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"动物，叫"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>class</span> <span>Dog</span> <span>extends</span> <span>Animal</span><span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>eat</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"狗吃骨头"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>shout</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"汪汪汪"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
<span>class</span> <span>Cat</span> <span>extends</span> <span>Animal</span><span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>eat</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"猫吃鱼"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>shout</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"喵喵喵"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>//举例二</span>

<span>class</span> <span>Order</span><span>{</span>
    <span>public</span> <span>void</span> <span>method</span><span>(</span><span>Object</span> obj<span>)</span><span>{</span>
    <span>}</span>
<span>}</span>
<span>//举例三：</span>
<span>class</span> <span>Driver</span><span>{</span>
    <span>public</span> <span>void</span> <span>doData</span><span>(</span><span>Connection</span> conn<span>)</span><span>{</span>
        <span>//连接多种不同的数据库，这里传入的是不同的对象</span>
        <span>//由于操作步骤都重写过了，都不需要更改操作步骤</span>
        <span>//conn = new MySqlConnection();</span>
        <span>//conn = new OracleConnection();</span>
        <span>//规范的步骤去操作数据</span>
        <span>// conn.method1();</span>
        <span>// conn.method2();</span>
        <span>// conn.method3();</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br></div></div><h3 id="虚拟方法调用-virtual-method-invocation"> 虚拟方法调用(Virtual Method Invocation)</h3>
<ul>
<li>
<p>正常的方法调用</p>
<div><pre><code><span>Person</span> e <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span>
e<span>.</span><span>getInfo</span><span>(</span><span>)</span><span>;</span>
<span>Student</span> e <span>=</span> <span>new</span> <span>Student</span><span>(</span><span>)</span><span>;</span>
e<span>.</span><span>getInfo</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
<li>
<p>虚拟方法调用(多态情况下)</p>
<ul>
<li>
<p><strong>子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。</strong></p>
<div><pre><code><span>Person</span> e <span>=</span> <span>new</span> <span>Student</span><span>(</span><span>)</span><span>;</span>
e<span>.</span><span>getInfo</span><span>(</span><span>)</span><span>;</span> <span>//调用Student类的getInfo()方法</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
</ul>
</li>
<li>
<p>编译时类型和运行时类型</p>
<ul>
<li>编译时e为Person类型，而方法的调用是在运行时确定的，所以调用的是Student类的getInfo()方法。 ——<strong>动态绑定</strong></li>
</ul>
</li>
<li>
<p>面试题</p>
<ul>
<li>多态是编译时行为还是运行时行为？<strong>运行时行为</strong></li>
</ul>
</li>
</ul>
<h3 id="小结-方法的重载与重写"> 小结：方法的重载与重写</h3>
<ul>
<li>
<p>从编译和运行的角度看：</p>
<ul>
<li>重载，是指允许存在多个同名方法，而这些方法的参数不同。 编译器根据方法不同的参数表， 对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。 <strong>它们的调用地址在编译期就绑定了。</strong> Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。</li>
<li>所以： 对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为**“早绑定”或“静态绑定”** ；</li>
<li>而对于多态，只有等到方法调用的那一刻， 解释运行器才会确定所要调用的具体方法，这称为**“晚绑定”或“动态绑定”** 。</li>
</ul>
<blockquote>
<p>引用一句Bruce Eckel的话**： “不要犯傻，如果它不是晚绑定， 它就不是多态。”**</p>
</blockquote>
</li>
<li>
<p><strong>所以重写可以理解成是多态，因为他是属于<u>晚绑定或动态绑定</u></strong></p>
</li>
<li>
<p>而重载在编译期就已经确定了，所以他不是多态</p>
</li>
</ul>
<h3 id="考察-4"> 考察</h3>
<ol>
<li>
<p>什么是多态性？什么是虚拟方法调用？</p>
<ul>
<li>
<p>对象的多态性：父类的引用指向子类的对象</p>
<div><pre><code><span>Person</span> p <span>=</span> <span>new</span> <span>Student</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>虚拟方法调用方法时，编译时看左边，运行时看右边</p>
<ul>
<li>假设调用<code>p.eat()</code>，编译时认为调用的方法是父类的方法，真正解释运行时实际实现的时子类重写的方法</li>
</ul>
</li>
<li>
<p>特殊的，调用属性时编译运行都看右边，</p>
</li>
</ul>
</li>
<li>
<p>一个类可以有几个直接父类？一个父类可以有多少个子类？子类能获取直接父类的父类中的结构吗？子类能否获取父类中private权限的属性或方法？</p>
<ul>
<li>一个类只能有一个直接父类</li>
<li>一个父类可以有多个子类</li>
<li>子类可以获取直接父类的父类（间接父类）</li>
<li>子类可以获取父类中private权限的属性或方法（通过get set进行操作）</li>
</ul>
</li>
<li>
<p>方法的重写(override/overwrite)的具体规则有哪些</p>
<ul>
<li><strong>方法名、形参列表一样</strong></li>
<li>子类的权限修饰符不能小于父类的修饰符</li>
<li>子类的返回值不能大于父类的返回值
<ul>
<li>父类void，子类也得void</li>
<li>父类为基本数据类型，子类只能一样</li>
<li>父类为引用类型（类），子类可以一样，或是类的子类</li>
</ul>
</li>
<li>子类抛出的异常可以与父类一样或小一点</li>
</ul>
</li>
<li>
<p>super调用构造器，有哪些具体的注意点</p>
<ul>
<li>this(形参列表)：本类重载的其他的构造器</li>
<li>super(形参列表)：调用父类中指定的构造器</li>
<li>注意点
<ul>
<li>this与super必须写第一行，而且只能二选一</li>
<li>若两者都没有写，默认是super()</li>
<li>在一个类中有n个构造器，n-1个用了this，则至少有一个用了super</li>
</ul>
</li>
</ul>
</li>
<li>
<p>在下面的代码结构中，使用关键字：this, super方法的重写、继承</p>
<ul>
<li>具体建day12(Circle.java, Cylinder.java, CylinderTest.java)</li>
</ul>
</li>
</ol>
<p>​</p>
<h2 id="强转与instanceof操作符-多态性的补充内容"> 强转与instanceof操作符 - 多态性的补充内容</h2>
<p>2021-12-07</p>
<ul>
<li>
<p>从基本数据类型的转换来看</p>
<ul>
<li>将较低级的基本数据类型<strong>自动类型提升</strong>成较高级的基本数据类型</li>
<li>将较高级的基本数据类型<strong>强制类型转换</strong>成较低级的基本数据类型
<ul>
<li>风险是数据的精度会有损失</li>
</ul>
</li>
</ul>
</li>
<li>
<p>从多态性的转换来看</p>
<ul>
<li>将子类赋给父类**（向上转型、多态）**</li>
<li>将父类转成子类**（向下转型）**
<ul>
<li>使用instanceof进行判断</li>
<li>风险在于转换可能会失败，所以为了避免抛出异常，这里使用instanceof语句先进行判断操作再执行强转</li>
</ul>
</li>
</ul>
</li>
<li>
<p>instanceof关键字的使用:</p>
<ul>
<li><code>a instanceof A</code>:判断对象a是否时类A的实例。如果是，返回true；如果不是，返回false</li>
<li>使用情景：为了避免在向下转型时出现ClassCastException的异常，在向下转型之前先进行instanceof的判断，一旦返回true，就进行向下转型，若返回false，则不向下转型</li>
<li>例子
<ul>
<li>如果<code>a instanceof A</code>返回true，且<code>a instanceof B</code>也返回true。
<ul>
<li>所以类B时类A的父类</li>
</ul>
</li>
</ul>
</li>
</ul>
<div><pre><code><span>//此处的p2 new的是man，所以p2不是woman的子类</span>
<span>if</span><span>(</span>p2 <span>instanceof</span> <span>Woman</span><span>)</span><span>{</span>
    <span>Woman</span> w1 <span>=</span> <span>(</span><span>Woman</span><span>)</span>p2<span>;</span>
    w1<span>.</span><span>goShopping</span><span>(</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"-----Woman执行-----"</span><span>)</span><span>;</span>
<span>}</span><span>else</span> <span>if</span><span>(</span>p2 <span>instanceof</span> <span>Man</span><span>)</span><span>{</span>
    <span>Man</span> m2 <span>=</span> <span>(</span><span>Man</span><span>)</span>p2<span>;</span>
    m2<span>.</span><span>earnMoney</span><span>(</span><span>)</span><span>;</span>
    m2<span>.</span>isSmoking <span>=</span> <span>false</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"-----Man执行-----"</span><span>)</span><span>;</span>
<span>}</span>
<span>if</span><span>(</span>p2 <span>instanceof</span> <span>Person</span><span>)</span><span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"--Person--"</span><span>)</span><span>;</span>
    <span>if</span><span>(</span>p2 <span>instanceof</span> <span>Object</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"--Object--"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
<span>//练习</span>
<span>//问题1：编译通过，运行时不通过</span>
<span>//不是父类强转子类</span>
<span>// Person p3 = new Woman();</span>
<span>// Man m3 = (Man)p3;</span>
<span>//不是父类强转子类的情况</span>
<span>// Person p4 = new Person();</span>
<span>// Man m4 = (Man)p4;</span>

<span>//问题2：编译通过，运行时通过</span>
<span>Object</span> obj <span>=</span> <span>new</span> <span>Woman</span><span>(</span><span>)</span><span>;</span>
<span>Person</span> p <span>=</span> <span>(</span><span>Person</span><span>)</span>obj<span>;</span>

<span>//问题3：编译不通过</span>
<span>//m5与新建的对象没有子父类的关系</span>
<span>// Man m5 = new Woman();</span>
<span>//相当于下面，他俩完全没关系所以也报错了</span>
<span>// String str = new Data();</span>

<span>//如果要将两个不相干的转换，则可以先转换为其父类，再强制转换</span>
<span>// Object o = new Data();</span>
<span>// String str1 = (String)o;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div></li>
</ul>
<h3 id="练习1"> 练习1</h3>
<ol>
<li>若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中。
<ul>
<li>编译看左边，运行看右边</li>
</ul>
</li>
<li>对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量
<ul>
<li>编译运行都看左边</li>
</ul>
</li>
</ol>
<h3 id="练习2"> 练习2</h3>
<ul>
<li>建立InstanceTest 类，在类中定义方法
method(Person e);
在method中:</li>
</ul>
<ol>
<li>根据e的类型调用相应类的getInfo()方法。</li>
<li>根据e的类型执行：
<ul>
<li>如果e为Person类的对象， 输出：
<ul>
<li>“a person”;</li>
</ul>
</li>
<li>如果e为Student类的对象， 输出：
<ul>
<li>“a student”</li>
<li>“a person ”</li>
</ul>
</li>
<li>如果e为Graduate类的对象，输出：
<ul>
<li>“a graduated student”</li>
<li>“a student”</li>
<li>“a person”</li>
</ul>
</li>
</ul>
</li>
</ol>
<div><pre><code><span>public</span> <span>class</span> <span>InstanceTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>InstanceTest</span> test <span>=</span> <span>new</span> <span>InstanceTest</span><span>(</span><span>)</span><span>;</span>
        test<span>.</span><span>method</span><span>(</span><span>new</span> <span>Student</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>method</span><span>(</span><span>Person</span> e<span>)</span><span>{</span>
        <span>//这里调用的是谁就使用谁重写的getInfo()方法</span>
        <span>//虚拟方法调用</span>
        <span>String</span> info <span>=</span> e<span>.</span><span>getInfo</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>info<span>)</span><span>;</span>

        <span>if</span><span>(</span>e <span>instanceof</span> <span>Graduate</span><span>)</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"a graduated student"</span><span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"a student"</span><span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"a person"</span><span>)</span><span>;</span>
        <span>}</span><span>else</span> <span>if</span><span>(</span>e <span>instanceof</span> <span>Student</span><span>)</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"a student"</span><span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"a person"</span><span>)</span><span>;</span>
        <span>}</span><span>else</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"a person"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
<span>class</span> <span>Person</span> <span>{</span>
    <span>protected</span> <span>String</span> name<span>=</span><span>"person"</span><span>;</span>
    <span>protected</span> <span>int</span> age<span>=</span><span>50</span><span>;</span>
    <span>public</span> <span>String</span> <span>getInfo</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>"Name: "</span><span>+</span> name <span>+</span> <span>"\n"</span> <span>+</span><span>"age: "</span><span>+</span> age<span>;</span>
    <span>}</span>
<span>}</span>
<span>class</span> <span>Student</span> <span>extends</span> <span>Person</span> <span>{</span>
    <span>protected</span> <span>String</span> school<span>=</span><span>"pku"</span><span>;</span>
    <span>@Override</span>
    <span>public</span> <span>String</span> <span>getInfo</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>"Name: "</span><span>+</span> name <span>+</span> <span>"\nage: "</span><span>+</span> age
                <span>+</span> <span>"\nschool: "</span><span>+</span> school<span>;</span>
    <span>}</span>
<span>}</span>
<span>class</span> <span>Graduate</span> <span>extends</span> <span>Student</span><span>{</span>
    <span>public</span> <span>String</span> major<span>=</span><span>"IT"</span><span>;</span>
    <span>@Override</span>
    <span>public</span> <span>String</span> <span>getInfo</span><span>(</span><span>)</span>
    <span>{</span>
        <span>return</span> <span>"Name: "</span><span>+</span> name <span>+</span> <span>"\nage: "</span><span>+</span> age
                <span>+</span> <span>"\nschool: "</span><span>+</span> school<span>+</span><span>"\nmajor:"</span><span>+</span>major<span>;</span>
    <span>}</span>
<span>}</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><h3 id="练习3"> 练习3</h3>
<ul>
<li>
<p>定义三个类，父类GeometricObject代表几何形状，子类Circle代圆形， MyRectangle代表矩形。定义一个测试类GeometricTest， 编写equalsArea方法测试两个对象的面积是否相等（注意方法的参数类型，利用动态绑定技术），编写displayGeometricObject方法显示对象的面积（注意方法的参数类型，利用动态绑定技术）。</p>
<p><img src="./images/04类与面向对象/image-20211207203156694.png" alt="image-20211207203156694" /></p>
</li>
<li>
<p>面试题</p>
<ul>
<li>
<p>多态是编译时行为还是运行时行为？如何证明？</p>
</li>
<li>
<p>扩展</p>
<div><pre><code><span>//InterviewTest1.java</span>
<span>package</span> <span>day13<span>.</span>exec</span><span>;</span>
<span>//考查多态的笔试题目：</span>
<span>public</span> <span>class</span> <span>InterviewTest1</span> <span>{</span>

	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
		<span>Base1</span> base <span>=</span> <span>new</span> <span>Sub1</span><span>(</span><span>)</span><span>;</span>
		base<span>.</span><span>add</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>;</span><span>//sub_1</span>

		<span>// Sub1 s = (Sub1)base;</span>
		<span>// s.add(1,2,3);//sub_2</span>
	<span>}</span>
<span>}</span>

<span>class</span> <span>Base1</span> <span>{</span>
	<span>public</span> <span>void</span> <span>add</span><span>(</span><span>int</span> a<span>,</span> <span>int</span><span>.</span><span>.</span><span>.</span> arr<span>)</span> <span>{</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"base"</span><span>)</span><span>;</span>
	<span>}</span>
<span>}</span>
<span>class</span> <span>Sub1</span> <span>extends</span> <span>Base1</span> <span>{</span>

	<span>//此处的第二个参数理解为与Base1的add方法进行了重写操作</span>
	<span>@Override</span>
	<span>public</span> <span>void</span> <span>add</span><span>(</span><span>int</span> a<span>,</span> <span>int</span><span>[</span><span>]</span> arr<span>)</span> <span>{</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"sub_1"</span><span>)</span><span>;</span>
	<span>}</span>
	<span>//若单纯打开此函数调用base，则会执行上面的sub_1，因为这里没有对父类进行重写，所以不构成多态不会执行到这里</span>
	<span>//若打开了s方法，将base强转为Sub1，相比与上面方法的可变个数的形参，则会优先调用确定的这个方法</span>
	<span>// public void add(int a, int b, int c) {</span>
	<span>// 	System.out.println("sub_2");</span>
	<span>// }</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div></li>
</ul>
</li>
</ul>
<h2 id="object类的使用"> Object类的使用</h2>
<ul>
<li>
<p>Object类是所有java类的根父类</p>
</li>
<li>
<p>如果在类的声明中未使用extends关键字指明其父类，则默认父类为<strong>java.lang.Object类</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>Person</span><span>{</span>
    ···
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>等价于</p>
<div><pre><code><span>public</span> <span>class</span> <span>Person</span> <span>extends</span> <span>Object</span><span>{</span>
    ···
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>
<p>例</p>
<div><pre><code><span>method</span><span>(</span><span>Object</span> obj<span>)</span><span>{</span>···<span>}</span><span>//可以接收任何类作为其参数</span>
<span>Person</span> o <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span>
<span>method</span><span>(</span>o<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
</ul>
</li>
</ul>
<h3 id="object类的主要结构"> Object类的主要结构</h3>
<table>
<thead>
<tr>
<th>NO.</th>
<th>方法名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>public Object()</td>
<td>构造</td>
<td>构造器</td>
</tr>
<tr>
<td>2</td>
<td>public boolean equals(Object obj)</td>
<td>普通</td>
<td>对象比较</td>
</tr>
<tr>
<td>3</td>
<td>public int hashCode()</td>
<td>普通</td>
<td>取得Hash码</td>
</tr>
<tr>
<td>4</td>
<td>public String toString()</td>
<td>普通</td>
<td>对象打印时调用</td>
</tr>
</tbody>
</table>
<ul>
<li>Object自带的方法，即每个对象都有的方法
<ul>
<li><strong>equals()</strong>, 比较两个对象是否相等</li>
<li><strong>toString()</strong>,</li>
<li>getClass()/ hashCode()/ clone()/ finalize()/ wait()/ notify()/ notifylAll()
<ul>
<li>clone(), 克隆对象</li>
<li>finalize(), 垃圾回收（一般不建议使用</li>
<li>getclass(), 获取指定对象是哪个类造的</li>
<li>...</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="关于equals-的用法"> 关于equals()的用法</h3>
<h4 id="面试题-和equals-区别"> 面试题：==和equals()区别</h4>
<ol>
<li>
<p>回顾==的使用
==，运算符</p>
<ol>
<li>可以使用在基本数据类型变量和引用数据类型变量中</li>
<li>类型比较
<ol>
<li>如果比较的是基本数据类型变量，比较两个变量保存的数据是否相等。（不一定要类型相等）</li>
<li>如果比较的是应用数据类型变量，比较两个对象的地址值是否相同，即两个引用是否指向同一个对象实体</li>
</ol>
</li>
<li>补充：==符号使用时，必须保证符号左右两边的变量类型一致</li>
</ol>
</li>
<li>
<p>equals()方法的使用：</p>
<ol>
<li>
<p>是一个方法，而非运算符</p>
</li>
<li>
<p>只能适用于引用数据类型</p>
</li>
<li>
<p>Object类中equals()的定义</p>
<ul>
<li>说明：Object类中定义的equals()和==的作用是相同的，比较两个对象的地址值是否相同，即两个引用是否指向同一个对象实体</li>
</ul>
<div><pre><code><span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> obj<span>)</span> <span>{</span>
    <span>return</span> <span>(</span><span>this</span> <span>==</span> obj<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p>像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是两个引用的地址值是否相同，而是比较两个对象的<code>实体内容</code>是否相同</p>
</li>
<li>
<p>通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的<code>实体内容</code>是否相同。那么我们就需要对Object类中的equals()进行重写</p>
<ul>
<li>重写的原则：比较两个对象的实体内容是否相同</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="关于重写equals"> 关于重写equals()</h4>
<ul>
<li>重写equals()方法的原则
<ul>
<li><strong>对称性</strong>： 如果x.equals(y)返回是“ true” ， 那么y.equals(x)也应该返回是“true” 。</li>
<li><strong>自反性</strong>： x.equals(x)必须返回是“true” 。</li>
<li><strong>传递性</strong>： 如果x.equals(y)返回是“true” ， 而且y.equals(z)返回是“true” ，那么z.equals(x)也应该返回是“true” 。</li>
<li><strong>一致性</strong>： 如果x.equals(y)返回是“true” ， 只要x和y内容一直不变， 不管你重复x.equals(y)多少次， 返回都是“true” 。</li>
<li>任何情况下：
<ul>
<li>x.equals(null)， 永远返回是“false” ；</li>
<li>谁与null比都是false</li>
<li>x.equals(和x不同类型的对象)永远返回是“false” 。</li>
</ul>
</li>
</ul>
</li>
<li>关于代码：</li>
</ul>
<div><pre><code><span>//EqualsTest.java</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Date</span><span>;</span>
<span>public</span> <span>class</span> <span>EqualsTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>//基础数据类型</span>
        <span>int</span> i <span>=</span> <span>10</span><span>;</span>
        <span>int</span> j <span>=</span> <span>10</span><span>;</span>
        <span>double</span> d <span>=</span> <span>10.0</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i <span>==</span> j<span>)</span><span>;</span><span>//true</span>
        <span>//int和double进行判断，也会进行自动类型提升，所以一样</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i <span>==</span> d<span>)</span><span>;</span><span>//true</span>

        <span>boolean</span> b <span>=</span> <span>true</span><span>;</span>
        <span>//这里是不允许比较的，因为基本数据类型不能和布尔值进行比较</span>
        <span>// System.out.println(i == b);</span>

        <span>char</span> c <span>=</span> <span>10</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i <span>==</span> c<span>)</span><span>;</span><span>//true</span>

        <span>char</span> c1 <span>=</span> <span>'A'</span><span>;</span>
        <span>char</span> c2 <span>=</span> <span>65</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>c1 <span>==</span> c2<span>)</span><span>;</span><span>//true</span>

        <span>//引用类型</span>
        <span>Customer</span> cust1 <span>=</span> <span>new</span> <span>Customer</span><span>(</span><span>"Tom"</span><span>,</span><span>21</span><span>)</span><span>;</span>
        <span>Customer</span> cust2 <span>=</span> <span>new</span> <span>Customer</span><span>(</span><span>"Tom"</span><span>,</span><span>21</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>cust1 <span>==</span> cust2<span>)</span><span>;</span><span>//false</span>

        <span>String</span> str1 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"hello"</span><span>)</span><span>;</span>
        <span>String</span> str2 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"hello"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str1 <span>==</span> str2<span>)</span><span>;</span><span>//false</span>

        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"--------"</span><span>)</span><span>;</span>
        <span>//调用的是java.lang.Object的equals</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>cust1<span>.</span><span>equals</span><span>(</span>cust2<span>)</span><span>)</span><span>;</span><span>//false-->true</span>
        <span>//调用的是java.lang.String的equals</span>
        <span>//比较的是内部属性（值）是否相同</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str1<span>.</span><span>equals</span><span>(</span>str2<span>)</span><span>)</span><span>;</span><span>//true</span>

        <span>Date</span> date1 <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>32432525324L</span><span>)</span><span>;</span>
        <span>Date</span> date2 <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>32432525324L</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>date1<span>.</span><span>equals</span><span>(</span>date2<span>)</span><span>)</span><span>;</span><span>//true</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><div><pre><code><span>//Customer.java</span>
<span>public</span> <span>class</span> <span>Customer</span> <span>{</span>
    <span>private</span> <span>String</span> name<span>;</span>
    <span>private</span> <span>int</span> age<span>;</span>

    <span>public</span> <span>Customer</span><span>(</span><span>)</span> <span>{</span>
    <span>}</span>

    <span>public</span> <span>Customer</span><span>(</span><span>String</span> name<span>,</span> <span>int</span> age<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
    <span>}</span>

    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> name<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setName</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getAge</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> age<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setAge</span><span>(</span><span>int</span> age<span>)</span> <span>{</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
    <span>}</span>
    <span>//自动实现equals()的重写（alt+Insert）</span>
    <span>@Override</span>
    <span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>this</span> <span>==</span> o<span>)</span> <span>{</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span>o <span>==</span> <span>null</span> <span>||</span> <span>getClass</span><span>(</span><span>)</span> <span>!=</span> o<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>

        <span>Customer</span> customer <span>=</span> <span>(</span><span>Customer</span><span>)</span> o<span>;</span>

        <span>if</span> <span>(</span>age <span>!=</span> customer<span>.</span>age<span>)</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>
        <span>return</span> name <span>!=</span> <span>null</span> <span>?</span> name<span>.</span><span>equals</span><span>(</span>customer<span>.</span>name<span>)</span> <span>:</span> customer<span>.</span>name <span>==</span> <span>null</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>int</span> <span>hashCode</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>}</span>
    <span>//重写的原则：比较两个对象的实体内容（即name和age）是否相同</span>
    <span>//手动实现equals()的重写</span>
    <span>/*@Override
    public boolean equals(Object o) {
        // System.out.println("Customer equals()");
        //若这两个地址值相同，则返回true
        // if (this == o) return true;
        //若传入的对象地址值为空或两者不在一个父类下则返回false
        // if (o == null || getClass() != o.getClass()) return false;
        //先将传入的对象强转为Customer对象类型以便计算Customer的实体内容
        // Customer customer = (Customer) o;
        //若实体内容相同则返回true，age为数字所以可以用==，而name为引用数据类型，所以需要用equals()进行对比name的实体内容
        // if (age != customer.age) return false;
        // return name != null ? name.equals(customer.name) : customer.name == null;
        if(this == o){
            return true;
        }
        //判断这个o是否为Customer
        if(o instanceof Customer){
            Customer cust = (Customer)o;
            //比较两个对象的每个属性是否都相同，前面是数字可以用==，但后面是String，所以需要用java.lang.String.equals()方法比较
            // if(this.age == cust.age &amp;&amp; this.name.equals(cust.name)){
            //     return true;
            // }else{
            //     return false;
            // }
            //或
            return this.age == cust.age &amp;&amp; this.name.equals(cust.name);
        }else{
            return false;
        }
    }*/</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br></div></div><h3 id="面试题-与equals-的区别"> 面试题：<code>==</code>与<code>equals()</code>的区别</h3>
<ol>
<li>==既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型就是比较内存地址</li>
<li>equals的话，他是属于java.lang.Object类里面的方法，如果该方法没被重写过默认也是==；我们可以看到String等类的equals方法是被重写过的，而且String类在日常开发中用的比较多，久而久之，形成了equals是比较值的错误观点</li>
<li>具体要看自定义类里有没有重新捏Object的equals方法来判断</li>
<li>通常情况下，重写equals方法，会比较类中的相应属性是否都相等</li>
</ol>
<h4 id="练习1-2"> 练习1</h4>
<div><pre><code><span>int</span> it <span>=</span> <span>65</span><span>;</span>
<span>float</span> fl <span>=</span> <span>65.0f</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>“<span>65</span>和<span>65.0f</span>是否相等？ ” <span>+</span> <span>(</span>it <span>==</span> fl<span>)</span><span>)</span><span>;</span> <span>//true</span>
<span>char</span> ch1 <span>=</span> <span>'A'</span><span>;</span> <span>char</span> ch2 <span>=</span> <span>12</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"65和'A'是否相等？ "</span> <span>+</span> <span>(</span>it <span>==</span> ch1<span>)</span><span>)</span><span>;</span><span>//true</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>“<span>12</span>和ch2是否相等？ " <span>+</span> <span>(</span><span>12</span> <span>==</span> ch2<span>)</span><span>)</span><span>;</span><span>//true</span>
<span>String</span> str1 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"hello"</span><span>)</span><span>;</span>
<span>String</span> str2 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"hello"</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"str1和str2是否相等？ "</span><span>+</span> <span>(</span>str1 <span>==</span> str2<span>)</span><span>)</span><span>;</span><span>//false</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"str1是否equals str2？ "</span><span>+</span><span>(</span>str1<span>.</span><span>equals</span><span>(</span>str2<span>)</span><span>)</span><span>)</span><span>;</span><span>//true</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>“hello” <span>==</span> <span>new</span> <span><span>java<span>.</span>util<span>.</span></span>Date</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>//编译不通过</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h4 id="练习2-2"> 练习2</h4>
<p>编写Order类，有int型的orderId， String型的orderName，相应的getter()和setter()方法，两个参数的构造器，重写父类的equals()方法：public boolean equals(Object obj)， 并判断测试类中创建的两个对象是否相等。</p>
<div><pre><code><span>public</span> <span>class</span> <span>OrderTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Order</span> order1 <span>=</span> <span>new</span> <span>Order</span><span>(</span><span>1001</span><span>,</span> <span>"AA"</span><span>)</span><span>;</span>
        <span>Order</span> order2 <span>=</span> <span>new</span> <span>Order</span><span>(</span><span>1002</span><span>,</span> <span>"BB"</span><span>)</span><span>;</span>

        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>order1<span>.</span><span>equals</span><span>(</span>order2<span>)</span><span>)</span><span>;</span>

        <span>Order</span> order3 <span>=</span> <span>new</span> <span>Order</span><span>(</span><span>1002</span><span>,</span> <span>"BB"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>order2<span>.</span><span>equals</span><span>(</span>order3<span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>order2<span>.</span><span>equals</span><span>(</span>order3<span>,</span> <span>"test"</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
<span>class</span> <span>Order</span><span>{</span>
    <span>private</span> <span>int</span> orderId<span>;</span>
    <span>private</span> <span>String</span> orderName<span>;</span>

    <span>public</span> <span>Order</span><span>(</span><span>int</span> orderId<span>,</span> <span>String</span> orderName<span>)</span> <span>{</span>
        <span>this</span><span>.</span>orderId <span>=</span> orderId<span>;</span>
        <span>this</span><span>.</span>orderName <span>=</span> orderName<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getOrderId</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> orderId<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setOrderId</span><span>(</span><span>int</span> orderId<span>)</span> <span>{</span>
        <span>this</span><span>.</span>orderId <span>=</span> orderId<span>;</span>
    <span>}</span>

    <span>public</span> <span>String</span> <span>getOrderName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> orderName<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setOrderName</span><span>(</span><span>String</span> orderName<span>)</span> <span>{</span>
        <span>this</span><span>.</span>orderName <span>=</span> orderName<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> o<span>)</span><span>{</span>
        <span>if</span><span>(</span><span>this</span> <span>==</span> o<span>)</span><span>{</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>
        <span>if</span><span>(</span>o <span>instanceof</span> <span>Order</span><span>)</span><span>{</span>
            <span>Order</span> order <span>=</span> <span>(</span><span>Order</span><span>)</span>o<span>;</span>
            <span>//正确的</span>
            <span>return</span> <span>this</span><span>.</span>orderId <span>==</span> order<span>.</span>orderId <span>&amp;&amp;</span>
                    <span>this</span><span>.</span>orderName<span>.</span><span>equals</span><span>(</span>order<span>.</span>orderName<span>)</span><span>;</span>

            <span>//错误的写法！</span>
            <span>// 但这里结果是true，因为如果定义的是一样的对象，在常量池判断复用则会指向一个地址</span>
            <span>// 此时"aa"=="aa"为true，但如果是new出来的，则会出现与意向不符的情况</span>
            <span>// return this.orderId == order.orderId &amp;&amp;</span>
            <span>//         this.orderName == order.orderName;</span>
        <span>}</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>String</span> <span>equals</span><span>(</span><span>Object</span> o<span>,</span> <span>String</span> a<span>)</span><span>{</span>
        <span>return</span> <span>"关于重写+重载的测试"</span><span>;</span>
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br></div></div><h4 id="练习3-2"> 练习3</h4>
<p>请根据以下代码自行定义能满足需要的MyDate类,在MyDate类中覆盖equals方法，使其判断当两个MyDate类型对象的年月日都相同时，结果为true，否则为false。 public boolean equals(Object o)</p>
<div><pre><code><span>public</span> <span>class</span> <span>MyDateTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>MyDate</span> m1 <span>=</span> <span>new</span> <span>MyDate</span><span>(</span><span>14</span><span>,</span> <span>3</span><span>,</span> <span>1976</span><span>)</span><span>;</span>
        <span>MyDate</span> m2 <span>=</span> <span>new</span> <span>MyDate</span><span>(</span><span>14</span><span>,</span> <span>3</span><span>,</span> <span>1976</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>m1 <span>==</span> m2<span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"m1 == m2"</span><span>)</span><span>;</span>
        <span>}</span><span>else</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"m1 != m2"</span><span>)</span><span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span>m1<span>.</span><span>equals</span><span>(</span>m2<span>)</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"m1 is equal to m2"</span><span>)</span><span>;</span>
        <span>}</span><span>else</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"m1 is not equal to m2"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
<span>class</span> <span>MyDate</span><span>{</span>
    <span>private</span> <span>int</span> day<span>;</span>
    <span>private</span> <span>int</span> month<span>;</span>
    <span>private</span> <span>int</span> year<span>;</span>

    <span>public</span> <span>MyDate</span><span>(</span><span>int</span> day<span>,</span> <span>int</span> month<span>,</span> <span>int</span> year<span>)</span> <span>{</span>
        <span>this</span><span>.</span>day <span>=</span> day<span>;</span>
        <span>this</span><span>.</span>month <span>=</span> month<span>;</span>
        <span>this</span><span>.</span>year <span>=</span> year<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getDay</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> day<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setDay</span><span>(</span><span>int</span> day<span>)</span> <span>{</span>
        <span>this</span><span>.</span>day <span>=</span> day<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getMonth</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> month<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setMonth</span><span>(</span><span>int</span> month<span>)</span> <span>{</span>
        <span>this</span><span>.</span>month <span>=</span> month<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getYear</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> year<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setYear</span><span>(</span><span>int</span> year<span>)</span> <span>{</span>
        <span>this</span><span>.</span>year <span>=</span> year<span>;</span>
    <span>}</span>
    <span>@Override</span>
    <span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> o<span>)</span><span>{</span>
        <span>if</span><span>(</span><span>this</span> <span>==</span> o<span>)</span><span>{</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>
        <span>if</span><span>(</span>o <span>instanceof</span> <span>MyDate</span><span>)</span><span>{</span>
            <span>MyDate</span> mydate <span>=</span> <span>(</span><span>MyDate</span><span>)</span> o<span>;</span>
            <span>return</span> <span>this</span><span>.</span>day <span>==</span> mydate<span>.</span>day <span>&amp;&amp;</span>
                    <span>this</span><span>.</span>month <span>==</span> mydate<span>.</span>month <span>&amp;&amp;</span>
                    <span>this</span><span>.</span>year <span>==</span> mydate<span>.</span>year<span>;</span>
        <span>}</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br></div></div><h3 id="关于tostring的用法"> 关于toString的用法</h3>
<h4 id="关于object类中tostring-的使用"> 关于Object类中toString()的使用</h4>
<ol>
<li>
<p>当我们输出一个对象的引用时，实际上就是调用当前对象的toString()</p>
</li>
<li>
<p>Object类中toString()的定义</p>
<div><pre><code><span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>getClass</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>"@"</span> <span>+</span> <span>Integer</span><span>.</span><span>toHexString</span><span>(</span><span>hashCode</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p>像String、Date、File、包装类等都重写了Object类中的toString()方法。使得在调用对象的toString()时，返回<code>实体内容</code>详细</p>
</li>
<li>
<p>自定义类也可以重写toString()方法，当调用此方法时，返回对象的<code>实体内容</code></p>
</li>
</ol>
<ul>
<li>
<p>代码举例</p>
<div><pre><code><span>public</span> <span>class</span> <span>ToStringTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Customer</span> cust1 <span>=</span> <span>new</span> <span>Customer</span><span>(</span><span>"Tom"</span><span>,</span> <span>21</span><span>)</span><span>;</span>
        <span>//重写后Customer[name = Tom, age = 21]</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>cust1<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span><span>//day13.java1.Customer@0</span>
        <span>//重写后Customer[name = Tom, age = 21]</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>cust1<span>)</span><span>;</span><span>//day13.java1.Customer@0</span>

        <span>String</span> str <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"MM"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str<span>)</span><span>;</span><span>//MM</span>

        <span>Date</span> date <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>2343424L</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>date<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span><span>//Thu Jan 01 08:39:03 CST 1970</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div></li>
</ul>
<h4 id="练习-6"> 练习</h4>
<div><pre><code><span>//CircleTest.java</span>
<span>public</span> <span>class</span> <span>CircleTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Circle</span> circle1 <span>=</span> <span>new</span> <span>Circle</span><span>(</span><span>2.3</span><span>)</span><span>;</span>
        <span>Circle</span> circle2 <span>=</span> <span>new</span> <span>Circle</span><span>(</span><span>2.0</span><span>,</span> <span>"white"</span><span>,</span> <span>2.3</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"颜色是否相等："</span> <span>+</span> circle1<span>.</span><span>getColor</span><span>(</span><span>)</span><span>.</span><span>equals</span><span>(</span>circle2<span>.</span><span>getColor</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span><span>//true</span>
        <span>//由于equals()方法就是比对半径，所以直接调用即可</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"半径是否相等："</span> <span>+</span> circle1<span>.</span><span>equals</span><span>(</span>circle2<span>)</span><span>)</span><span>;</span><span>//false</span>

        <span>//下面两种方式都一样</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>circle1<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>circle2<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
<span>//Circle.java</span>
<span>public</span> <span>class</span> <span>Circle</span> <span>extends</span> <span>GeometricObject</span><span>{</span>
    <span>private</span> <span>double</span> radius<span>;</span>

    <span>public</span> <span>Circle</span><span>(</span><span>)</span> <span>{</span>
        radius <span>=</span> <span>1.0</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>Circle</span><span>(</span><span>double</span> radius<span>)</span> <span>{</span>
        <span>this</span><span>.</span>radius <span>=</span> radius<span>;</span>
    <span>}</span>

    <span>public</span> <span>Circle</span><span>(</span><span>double</span> radius<span>,</span> <span>String</span> color<span>,</span> <span>double</span> weight<span>)</span> <span>{</span>
        <span>super</span><span>(</span>color<span>,</span> weight<span>)</span><span>;</span>
        <span>this</span><span>.</span>radius <span>=</span> radius<span>;</span>
    <span>}</span>

    <span>public</span> <span>double</span> <span>getRadius</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> radius<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setRadius</span><span>(</span><span>double</span> radius<span>)</span> <span>{</span>
        <span>this</span><span>.</span>radius <span>=</span> radius<span>;</span>
    <span>}</span>
    <span>/**
     * @description: 求圆的面积
     * @author bit
     * @date 2021/12/8 22:31
     * @version 1.0
     */</span>
    <span>public</span> <span>double</span> <span>findArea</span><span>(</span><span>)</span><span>{</span>
        <span>return</span> <span>Math</span><span>.</span>PI <span>*</span> radius <span>*</span> radius<span>;</span>
    <span>}</span>
    <span>//比较两个圆的半径是否相等，如相等，返回true</span>
    <span>@Override</span>
    <span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> o<span>)</span><span>{</span>
        <span>if</span><span>(</span><span>this</span> <span>==</span> o<span>)</span><span>{</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>
        <span>if</span><span>(</span>o <span>instanceof</span> <span>Circle</span><span>)</span><span>{</span>
            <span>Circle</span> circle <span>=</span> <span>(</span><span>Circle</span><span>)</span>o<span>;</span>
            <span>return</span> <span>this</span><span>.</span>radius <span>==</span> circle<span>.</span>radius<span>;</span>
        <span>}</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>"Circle{"</span> <span>+</span>
                <span>"radius="</span> <span>+</span> radius <span>+</span>
                <span>'}'</span><span>;</span>
    <span>}</span>
<span>}</span>
<span>//GeometricObject.java</span>
<span>public</span> <span>class</span> <span>GeometricObject</span> <span>{</span>
    <span>protected</span> <span>String</span> color<span>;</span>
    <span>protected</span> <span>double</span> weight<span>;</span>

    <span>public</span> <span>GeometricObject</span><span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>color <span>=</span> <span>"white"</span><span>;</span>
        <span>this</span><span>.</span>weight <span>=</span> <span>1.0</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>GeometricObject</span><span>(</span><span>String</span> color<span>,</span> <span>double</span> weight<span>)</span> <span>{</span>
        <span>this</span><span>.</span>color <span>=</span> color<span>;</span>
        <span>this</span><span>.</span>weight <span>=</span> weight<span>;</span>
    <span>}</span>

    <span>public</span> <span>String</span> <span>getColor</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> color<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setColor</span><span>(</span><span>String</span> color<span>)</span> <span>{</span>
        <span>this</span><span>.</span>color <span>=</span> color<span>;</span>
    <span>}</span>

    <span>public</span> <span>double</span> <span>getWeight</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> weight<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setWeight</span><span>(</span><span>double</span> weight<span>)</span> <span>{</span>
        <span>this</span><span>.</span>weight <span>=</span> weight<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br></div></div><h2 id="额外的-关于垃圾回收的说明"> 额外的：关于垃圾回收的说明</h2>
<p>垃圾回收机制关键点</p>
<p>垃圾回收机制只回收JVM堆内存里的对象空间。</p>
<p>对其他物理连接，比如数据库连接、输入流输出流、Socket连接无能为力</p>
<p>现在的JVM有多种垃圾回收实现算法，表现各异。</p>
<p>垃圾回收发生具有不可预知性，程序无法精确控制垃圾回收机制执行。</p>
<p>可以将对象的引用变量设置为null，暗示垃圾回收机制可以回收该对象。</p>
<p>程序员可以通过System.gc()或者Runtime.getRuntime().gc()来通知系统进行垃圾回收，会有
一些效果，但是系统是否进行垃圾回收依然不确定。</p>
<p>垃圾回收机制回收任何对象之前，总会先调用它的finalize方法（如果覆盖该方法，让一
个新的引用变量重新引用该对象，则会重新激活对象）。</p>
<p>永远不要主动调用某个对象的finalize方法，应该交给垃圾回收机制调用。</p>
<h2 id="单元测试的使用"> 单元测试的使用</h2>
<ul>
<li>
<p>eclipse在Java中的JUnit单元测试 - 步骤：</p>
<ol>
<li>选中当前过程 - 右键选择：build path - add libraries - JUnit 4 - 下一步</li>
<li>创建java类，进行单元测试
<ul>
<li>此时java类要求:
<ol>
<li>此类是public的</li>
<li>此类提供公共的无参构造器</li>
</ol>
</li>
</ul>
</li>
<li>此类中声明单元测试方法：此时的单元测试方法：方法的权限是public，没有返回值，没有形参</li>
<li>此单元测试方法上需要声明注解：@Test，并在单元测试类中导入：<code>import org.junit.Test;</code></li>
<li>声明好单元测试方法以后，就可以在方法体内测试相关的代码</li>
<li>写完代码以后，左键双击单元测试方法名，右键：Run as -&gt; run</li>
</ol>
</li>
<li>
<p>说明：</p>
<ol>
<li>如果执行结果没有任何异常：绿条</li>
<li>如果执行结果出现异常：红条</li>
</ol>
</li>
<li>
<p>当然你也可以直接写以下结构，再alt+enter一键让IDE自动导入<code>org.junit.Test</code></p>
<div><pre><code><span>@Test</span>
<span>public</span> <span>class</span> test<span>{</span>
    
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
<li>
<p>示例</p>
<div><pre><code><span>package</span> <span>day13<span>.</span>java2</span><span>;</span>

<span>import</span> <span>org<span>.</span>junit<span>.</span></span><span>Test</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Date</span><span>;</span>

<span>public</span> <span>class</span> <span>JUnitTest</span> <span>{</span>
    <span>int</span> num <span>=</span> <span>10</span><span>;</span>

    <span>@Test</span>
    <span>public</span> <span>void</span> <span>testEquals</span><span>(</span><span>)</span><span>{</span>
        <span>String</span> s1 <span>=</span> <span>"MM"</span><span>;</span>
        <span>String</span> s2 <span>=</span> <span>"MM"</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s1<span>.</span><span>equals</span><span>(</span>s2<span>)</span><span>)</span><span>;</span>
        <span>//ClassCastException的异常，亮红色</span>
        <span>// Object obj = new String("GG");</span>
        <span>// Date date = (Date)obj;</span>

        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>num<span>)</span><span>;</span>
        <span>show</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>show</span><span>(</span><span>)</span><span>{</span>
        num <span>=</span> <span>20</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"show()"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>//单独调用测试单元，不会运行上面的测试单元</span>
    <span>@Test</span>
    <span>public</span> <span>void</span> <span>testToString</span><span>(</span><span>)</span><span>{</span>
        <span>String</span> s2 <span>=</span> <span>"MM"</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s2<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div></li>
</ul>
<h2 id="包装类的使用"> 包装类的使用</h2>
<ul>
<li>
<p>包装类(Wrapper、封装类)</p>
<ul>
<li>针对八种基本数据类型定义相应的引用类型——包装类</li>
<li>有了类的特点，就可以调用类中的方法，java才是真正的面向对象</li>
</ul>
</li>
<li>
<p>上面六种属于父类Number的，除了int与char是Integer和Character，其余都是首字母大写</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td><strong>Integer</strong></td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td><strong>Character</strong></td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="基本数据、包装类与string类间的转换"> 基本数据、包装类与String类间的转换</h3>
<p><img src="./images/04类与面向对象/image-20211209193340679.png" alt="image-20211209193340679" /></p>
<ol>
<li>java提供了8种基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征</li>
<li>需要掌握的：基本数据类型、包装类、String三者之间的相互转换
<ul>
<li>基本数据类型与包装类之间有自动装箱与自动拆箱</li>
<li>基本数据类型、包装类转换为String的方法：<strong><code>String.valueOf(xxx/Xxx)</code></strong></li>
<li>String转换为基本数据类型、包装类的方法：调用包装类的**<code>parseXxx(String s)</code>**</li>
</ul>
</li>
</ol>
<div><pre><code><span>public</span> <span>class</span> <span>WrapperTest</span> <span>{</span>
    <span>//String类型--->基本数据类型、包装类：调用包装类的parseXxx(String s)方法</span>
    <span>//基本数据类型、包装类--->Stirng类型：调用String重载的valueOf(xxx/Xxx)</span>
    <span>@Test</span>
    <span>public</span> <span>void</span> <span>test4</span><span>(</span><span>)</span><span>{</span>
        <span>int</span> num1 <span>=</span> <span>10</span><span>;</span>
        <span>//方式一：连接运算</span>
        <span>String</span> str1 <span>=</span> num1 <span>+</span> <span>""</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str1<span>)</span><span>;</span>

        <span>//方式二：调用String的valueOf(xxx/Xxx)</span>
        <span>float</span> f1 <span>=</span> <span>12.3f</span><span>;</span>
        <span>String</span> str2 <span>=</span> <span>String</span><span>.</span><span>valueOf</span><span>(</span>f1<span>)</span><span>;</span><span>//"12,3"</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str2<span>)</span><span>;</span>

        <span>Double</span> d1 <span>=</span> <span>new</span> <span>Double</span><span>(</span><span>12.4</span><span>)</span><span>;</span>
        <span>String</span> str3 <span>=</span> <span>String</span><span>.</span><span>valueOf</span><span>(</span>d1<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str3<span>)</span><span>;</span><span>//12.4</span>

    <span>}</span>

    <span>@Test</span>
    <span>public</span> <span>void</span> <span>test5</span><span>(</span><span>)</span><span>{</span>
        <span>String</span> str1 <span>=</span> <span>"123"</span><span>;</span>
        <span>//如果传入的参数有非数字，可能会报NumberFormatException异常</span>
        <span>int</span> num2 <span>=</span> <span>Integer</span><span>.</span><span>parseInt</span><span>(</span>str1<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>num2 <span>+</span> <span>1</span><span>)</span><span>;</span>
        <span>//错误的情况</span>
        <span>// int num1 = (int)str1;</span>
        <span>// Integer in1 = (Integer)str1</span>

        <span>String</span> str2 <span>=</span> <span>"true"</span><span>;</span>
        <span>Boolean</span> b1 <span>=</span> <span>Boolean</span><span>.</span><span>parseBoolean</span><span>(</span>str2<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>b1<span>)</span><span>;</span>
    <span>}</span>

    <span>//JDK5.0新特性：自动装修与自动拆箱</span>

    <span>@Test</span>
    <span>public</span> <span>void</span> <span>test3</span><span>(</span><span>)</span><span>{</span>
        <span>int</span> num1 <span>=</span> <span>10</span><span>;</span>
        <span>//基本数据类型转换成包装类的对象</span>
        <span>// method(num1);</span>

        <span>//自动装箱：基本数据类型--->包装类</span>
        <span>int</span> num2 <span>=</span> <span>10</span><span>;</span>
        <span>Integer</span> in1 <span>=</span> num2<span>;</span><span>//自动装箱</span>

        <span>boolean</span> b1 <span>=</span> <span>true</span><span>;</span>
        <span>Boolean</span> b2 <span>=</span> b1<span>;</span><span>//自动装箱</span>

        <span>//自动拆箱：包装类--->基本数据类型</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>in1<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>int</span> num3 <span>=</span> in1<span>;</span><span>//自动拆箱</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>method</span><span>(</span><span>Object</span> obj<span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>obj<span>)</span><span>;</span>
    <span>}</span>

    <span>//包装类转换为基本数据类型：调用包装类的.xxxValue()</span>
    <span>@Test</span>
    <span>public</span> <span>void</span> <span>test2</span><span>(</span><span>)</span><span>{</span>
        <span>Integer</span> in1 <span>=</span> <span>new</span> <span>Integer</span><span>(</span><span>12</span><span>)</span><span>;</span>
        <span>int</span> i1 <span>=</span> in1<span>.</span><span>intValue</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i1 <span>+</span> <span>1</span><span>)</span><span>;</span>

        <span>Float</span> f1 <span>=</span> <span>new</span> <span>Float</span><span>(</span><span>12.3</span><span>)</span><span>;</span>
        <span>float</span> f2 <span>=</span> f1<span>.</span><span>floatValue</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>f2 <span>+</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span>

    <span>//基本数据类型转换为包装类：调用包装类的构造器</span>
    <span>@Test</span>
    <span>public</span> <span>void</span> <span>test1</span><span>(</span><span>)</span><span>{</span>
        <span>int</span> num1 <span>=</span> <span>10</span><span>;</span>
        <span>Integer</span> in1 <span>=</span> <span>new</span> <span>Integer</span><span>(</span>num1<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>in1<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>

        <span>Integer</span> in2 <span>=</span> <span>new</span> <span>Integer</span><span>(</span><span>"123"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>in2<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>//不能使用英文，</span>
        <span>// Integer in3 = new Integer("123abc");</span>
        <span>// System.out.println(in3.toString());</span>

        <span>Float</span> f1 <span>=</span> <span>new</span> <span>Float</span><span>(</span><span>12.3f</span><span>)</span><span>;</span>
        <span>Float</span> f2 <span>=</span> <span>new</span> <span>Float</span><span>(</span><span>"12.3"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>f1<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>f2<span>)</span><span>;</span>

        <span>Boolean</span> b1 <span>=</span> <span>new</span> <span>Boolean</span><span>(</span><span>true</span><span>)</span><span>;</span>
        <span>Boolean</span> b2 <span>=</span> <span>new</span> <span>Boolean</span><span>(</span><span>"true"</span><span>)</span><span>;</span>
        <span>//可忽略大小写</span>
        <span>Boolean</span> b22 <span>=</span> <span>new</span> <span>Boolean</span><span>(</span><span>"TrUe"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>b2<span>)</span><span>;</span><span>//true</span>
        <span>//Boolean中做了优化，只要不是true，其他都是false</span>
        <span>Boolean</span> b3 <span>=</span> <span>new</span> <span>Boolean</span><span>(</span><span>"true123"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>b3<span>)</span><span>;</span><span>//false</span>

        <span>Order</span> order <span>=</span> <span>new</span> <span>Order</span><span>(</span><span>)</span><span>;</span>
        <span>// boolean，基本数据类型，默认是false</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>order<span>.</span>isMale<span>)</span><span>;</span><span>//false</span>
        <span>// Boolean，包装类，默认是null</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>order<span>.</span>isFemale<span>)</span><span>;</span><span>//null</span>
    <span>}</span>
<span>}</span>
<span>class</span> <span>Order</span><span>{</span>
    <span>boolean</span> isMale<span>;</span>
    <span>Boolean</span> isFemale<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br></div></div><h3 id="练习1-3"> 练习1</h3>
<p>如下分别的输出结果是什么？</p>
<ul>
<li>在编译的时候，前者与后者会进行判断运算，所以前者会进行类型提升变为double</li>
</ul>
<div><pre><code><span>@Test</span>
<span>public</span> <span>void</span> <span>test1</span><span>(</span><span>)</span><span>{</span>
    <span>Object</span> o1 <span>=</span> <span>true</span> <span>?</span> <span>new</span> <span>Integer</span><span>(</span><span>1</span><span>)</span><span>:</span> <span>new</span> <span>Double</span><span>(</span><span>2.0</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>o1<span>)</span><span>;</span><span>//1.0</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li>这里直接判断输出1，注意别被上面的题给恍住了</li>
</ul>
<div><pre><code>
<span>@Test</span>
<span>public</span> <span>void</span> <span>test2</span><span>(</span><span>)</span><span>{</span>
    <span>Object</span> o2<span>;</span>
    <span>if</span><span>(</span><span>true</span><span>)</span>
        o2 <span>=</span> <span>new</span> <span>Integer</span><span>(</span><span>1</span><span>)</span><span>;</span>
    <span>else</span>
        o2 <span>=</span> <span>new</span> <span>Double</span><span>(</span><span>2.0</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>o2<span>)</span><span>;</span><span>//1</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ul>
<li>这里前两部分算是之前的内容了，第一部分是new了两个地址的包装类(对象)，此时==对比的是两个不同的地址值，所以是false</li>
<li>第二部分是由于他们两个的值都一样，所以在静态变量池中指向的是同一个地址，所以这里==对比是true</li>
<li>第三部分
<ul>
<li>Integer内部定义了IntegerCache结构，IntegerCache中定义了Integer[],保存了从-128<sub>127范围的整数。如果我们使用自动装箱的方式，给Integer赋值的范围在-128</sub>127范围内的时，可以直接使用数组中的元素，不用再去new。主要目的是为了提高效率</li>
<li>这里第三部分的相当于new了个Integer对象</li>
<li>在Integer的内部整合了从-128到127的一个数组，如果在这个数组范围内，则直接可以调用，所以两个此范围内的包装类是true，若超出此范围，则会new一个，所以这里两个包装类是false</li>
</ul>
</li>
</ul>
<div><pre><code>    <span>@Test</span>
    <span>public</span> <span>void</span> <span>method1</span><span>(</span><span>)</span><span>{</span>
        <span>Integer</span> i <span>=</span> <span>new</span> <span>Integer</span><span>(</span><span>1</span><span>)</span><span>;</span>
        <span>Integer</span> j <span>=</span> <span>new</span> <span>Integer</span><span>(</span><span>1</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i <span>==</span> j<span>)</span><span>;</span><span>//flase</span>

        <span>Integer</span> m <span>=</span> <span>1</span><span>;</span>
        <span>Integer</span> n <span>=</span> <span>1</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>m <span>==</span> n<span>)</span><span>;</span><span>//true</span>

        <span>Integer</span> x <span>=</span> <span>128</span><span>;</span>
        <span>Integer</span> y <span>=</span> <span>128</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>x <span>==</span> y<span>)</span><span>;</span><span>//false</span>

    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="练习2-3"> 练习2</h3>
<p>利用Vector代替数组处理：从键盘读入学生成绩（以负数代表输入结束），找出最高分，并输出学生成绩等级。</p>
<ul>
<li>提示：数组一旦创建，长度就固定不变，所以在创建数组前就需要知道它的
长度。而向量类java.util.Vector可以根据需要动态伸缩。</li>
<li>创建Vector对象： Vector v=new Vector();</li>
<li>给向量添加元素： v.addElement(Object obj); //obj必须是对象</li>
<li>取出向量中的元素： Object obj=v.elementAt(0);</li>
<li>注意第一个元素的下标是0，返回值是Object类型的。</li>
<li>计算向量的长度： v.size();</li>
<li>若与最高分相差10分内： A等； 20分内： B等；
30分内： C等；其它： D等</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>ScoreTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>//1. 实例化Scanner，用于从键盘获取学生成绩</span>
        <span>Scanner</span> scan <span>=</span> <span>new</span> <span>Scanner</span><span>(</span><span>System</span><span>.</span>in<span>)</span><span>;</span>

        <span>//2. 创建Vector对象： Vector v=new Vector();相当于原来的数组</span>
        <span>Vector</span> v <span>=</span> <span>new</span> <span>Vector</span><span>(</span><span>)</span><span>;</span>

        <span>//3. 通过for(;;)或while(true)方式，给Vector中添加数据</span>
        <span>int</span> maxScore <span>=</span> <span>0</span><span>;</span>
        <span>for</span><span>(</span><span>;</span><span>;</span><span>)</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"请输入学生成绩（以负数代表输入结束）:"</span><span>)</span><span>;</span>
            <span>int</span> score <span>=</span> scan<span>.</span><span>nextInt</span><span>(</span><span>)</span><span>;</span>
            <span>//3.2 当输入是负数时跳出循环</span>
            <span>if</span> <span>(</span>score <span>&lt;</span> <span>0</span><span>)</span><span>{</span>
                <span>break</span><span>;</span>
            <span>}</span>
            <span>if</span><span>(</span>score <span>></span> <span>100</span><span>)</span><span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"输入的数非法，请重写输入"</span><span>)</span><span>;</span>
                <span>continue</span><span>;</span>
            <span>}</span>
            <span>//3.1 添加元素： v.addElement(Object obj);</span>
            <span>//jdk5.0之前</span>
            <span>// Integer inScore = new Integer(score);</span>
            <span>// v.addElement(inScore);//多态</span>
            <span>//jdk5.0之后</span>
            v<span>.</span><span>addElement</span><span>(</span>score<span>)</span><span>;</span><span>//自动装箱</span>
            <span>//4. 获取学生的最大值</span>
            <span>if</span><span>(</span>maxScore <span>&lt;</span> score<span>)</span><span>{</span>
                maxScore <span>=</span> score<span>;</span>
            <span>}</span>
        <span>}</span>

        <span>//5. 通过遍历Vector，得到每个学生的成绩并于最大成绩比较得到每个学生的等级</span>
        <span>char</span> level<span>;</span>
        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span>i <span>&lt;</span> v<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>i<span>++</span><span>)</span><span>{</span>
            <span>Object</span> o <span>=</span> v<span>.</span><span>elementAt</span><span>(</span>i<span>)</span><span>;</span>
            <span>//jdk5.0之前</span>
            <span>// Integer inScore = (Integer) o;</span>
            <span>// int score = inScore.intValue();</span>
            <span>//jdk5.0之后</span>
            <span>// int score = inScore;</span>
            <span>int</span> score <span>=</span> <span>(</span><span>int</span><span>)</span>o<span>;</span>

            <span>if</span><span>(</span>maxScore <span>-</span> score <span>&lt;=</span> <span>10</span><span>)</span><span>{</span>
                level <span>=</span> <span>'A'</span><span>;</span>
            <span>}</span><span>else</span> <span>if</span><span>(</span>maxScore <span>-</span> score <span>&lt;=</span> <span>20</span><span>)</span><span>{</span>
                level <span>=</span> <span>'B'</span><span>;</span>
            <span>}</span><span>else</span> <span>if</span><span>(</span>maxScore <span>-</span> score <span>&lt;=</span> <span>30</span><span>)</span><span>{</span>
                level <span>=</span> <span>'C'</span><span>;</span>
            <span>}</span><span>else</span><span>{</span>
                level <span>=</span> <span>'D'</span><span>;</span>
            <span>}</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"student - "</span> <span>+</span> i <span>+</span> <span>" score is "</span> <span>+</span> score <span>+</span> <span>", level is "</span> <span>+</span> level<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br></div></div><h3 id="考察-5"> 考察</h3>
<ol>
<li>
<p>如何实现向下转型？需要注意上面问题？如何解决此问题</p>
<ul>
<li>
<p>使用强转符：<code>()</code></p>
<div><pre><code><span>Person</span> p <span>=</span> <span>new</span> <span>Man</span><span>(</span><span>)</span><span>;</span>
<span>//Person p = (Person)new Man();//上面的相当于这样</span>
<span>Man</span> m <span>=</span> <span>(</span><span>Man</span><span>)</span>p<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p>使用强转可能会出现<code>ClassCastException</code>异常</p>
</li>
<li>
<p>为了避免出现上面的错误，使用instanceof在进行向下转型前进行判断</p>
<div><pre><code><span>Person</span> p <span>=</span> <span>new</span> <span>Man</span><span>(</span><span>)</span><span>;</span>
<span>if</span> <span>(</span>p instance <span>Man</span><span>)</span><span>{</span>
    <span>Man</span> m <span>=</span> <span>(</span><span>Man</span><span>)</span>p<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
</ul>
</li>
<li>
<p>==和equals()有何区别</p>
<ul>
<li>==既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型就是比较内存地址</li>
<li>equals的话，他是属于java.lang.Object类里面的方法，如果该方法没被重写过默认也是==；我们可以看到String等类的equals方法是被重写过的，而且String类在日常开发中用的比较多，久而久之，形成了equals是比较值的错误观点</li>
<li>具体要看自定义类里有没有重新捏Object的equals方法来判断</li>
<li>通常情况下，重写equals方法，会比较类中的相应属性是否都相等</li>
</ul>
</li>
<li>
<p>重写其equals()方法</p>
<div><pre><code><span>class</span> <span>User</span><span>{</span>
    <span>String</span> name<span>;</span>
    <span>int</span> age<span>;</span>
    <span>//在此重写equals()方法</span>
    <span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> obj<span>)</span><span>{</span>
        <span>if</span><span>(</span>obj <span>==</span> <span>this</span><span>)</span><span>{</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>
        <span>if</span><span>(</span>obj <span>instanceof</span> <span>User</span><span>)</span><span>{</span>
            <span>User</span> u <span>=</span> <span>(</span><span>User</span><span>)</span>obj<span>;</span>
            <span>return</span> <span>this</span><span>.</span>age <span>==</span> u<span>.</span>age <span>&amp;&amp;</span> <span>this</span><span>.</span>name<span>.</span><span>equals</span><span>(</span>u<span>.</span>name<span>)</span>
        <span>}</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div></li>
<li>
<p>写出8种基本数据类型及其对应的包装类</p>
<div><pre><code>int		Integer
byte	Byte
char	Character
short	Short
long	Long
float	Float
double	Double
boolean	Boolean
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></li>
<li>
<p>基本数据类型、包装类与String三者之间如何转换</p>
<div><pre><code><span>//自动装箱、自动拆箱</span>
<span>Integer</span> i <span>=</span> <span>10</span><span>;</span>
<span>//基本数据类型、包装类:转成String: valueOf(Xxx/xxx)</span>
<span>//String转成基本数据类型、包装类:parseXxx(String s) </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
</ol>
<h2 id="关键字-static"> 关键字：static</h2>
<p>static也有其弊端，就是声明的变量生命周期过长，会一直存在，可能会导致出现一些问题</p>
<p>day14</p>
<p>当我们编写一个类时，其实就是在描述其对象的属性和行为，而并没有产生实质上的对象，只有通过new关键字才会产生出对象，这时系统才会分配内存空间给对象，其方法才可以供外部调用。我们有时候希望无论是否产生了对象或无论产生了多少对象的情况下， <strong>某些特定的数据在内存空间里只有一份</strong>，例如所有的中国人都有个国家名称，每一个中国人都共享这个国家名称，不必在每一个中国人的实例对象中都单独分配一个用于代表国家名称的变量。</p>
<p><img src="./images/04类与面向对象/image-20211213213550430.png" alt="image-20211213213550430" /></p>
<ul>
<li>
<p>static关键字的使用</p>
<ol>
<li>
<p>static：静态的</p>
</li>
<li>
<p>static可以用来修饰：属性、方法、代码块、内部类</p>
</li>
<li>
<p>使用static修饰属性：静态变量（类变量）</p>
<ol>
<li>
<p>属性，按是否使用static修饰，又分为：静态属性 vs 非静态属性(实例变量)</p>
<ul>
<li>实例变量：我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性，当我们修改其中一个对象中的非静态属性值，不会导致其他对象中同样属性值的修改</li>
<li>静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用静态变量时，时修改过的</li>
</ul>
</li>
<li>
<p>static修饰属性的其他说明</p>
<ol>
<li><strong>静态变量随着类的加载而加载</strong>。可以通过<code>类.静态变量</code>的方式进行调用</li>
<li>静态变量的加载<strong>要早于对象的加载</strong>。</li>
<li>由于类只会加载一次，则静态变量在内存中也只会存在一份，存在方法区的静态域中</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>类变量</th>
<th>实例变量</th>
</tr>
</thead>
<tbody>
<tr>
<td>类</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>对象</td>
<td>yes</td>
<td>yes</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>静态属性举例，System.out(); Math.PI;</p>
</li>
</ol>
</li>
<li>
<p>使用static修饰方法：</p>
<ol>
<li>
<p>随着类的加载而加载，可以通过<code>类.静态方法</code>的方式进行调用</p>
<table>
<thead>
<tr>
<th></th>
<th>静态方法</th>
<th>非静态变量</th>
</tr>
</thead>
<tbody>
<tr>
<td>类</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>对象</td>
<td>yes</td>
<td>yes</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>对于非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性</p>
</li>
</ol>
</li>
<li>
<p>static使用注意点</p>
<ol>
<li>
<p>在静态的方法内，不能使用this关键字、super关键字</p>
<ul>
<li>
<p>因为静态变量的加载早于对象的加载，所以不能使用</p>
</li>
<li>
<p>静态的方法可以调用其他静态的方法</p>
</li>
</ul>
</li>
<li>
<p>关于静态属性和静态方法的使用，都<strong>从生命周期的角度区理解</strong></p>
</li>
</ol>
</li>
<li>
<p>在实际开发中</p>
<ul>
<li>开发中如何确定一个<strong>属性</strong>是否要声明为static
<ul>
<li><strong>属性是可以被多个对象所共享的，不会随着对象的不同而不同的</strong></li>
<li>类中的<strong>常量也常常声明static</strong></li>
</ul>
</li>
<li>开发中如何确定一个<strong>方法</strong>是否要声明为static
<ul>
<li><strong>操作静态属性的方法</strong>，通常设置为static的</li>
<li><strong>工具类中的方法</strong>，习惯上声明为static
<ul>
<li>比如Math、Arrays、Collections</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p>默认情况下toString只会将当前类的非static类型输出出来</p>
</li>
</ul>
<h3 id="类变量与实例变量的内存解析"> 类变量与实例变量的内存解析</h3>
<p><img src="./images/04类与面向对象/image-20211214194840425.png" alt="image-20211214194840425" /></p>
<h3 id="static应用举例"> static应用举例</h3>
<div><pre><code><span>package</span> <span>day14<span>.</span>java1</span><span>;</span>
<span>/*
static关键字的应用
 */</span>
<span>public</span> <span>class</span> <span>CircleTest</span><span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span><span>{</span>
        <span>Circle</span> c1 <span>=</span> <span>new</span> <span>Circle</span><span>(</span><span>)</span><span>;</span>
        <span>Circle</span> c2 <span>=</span> <span>new</span> <span>Circle</span><span>(</span><span>)</span><span>;</span>
        <span>Circle</span> c3 <span>=</span> <span>new</span> <span>Circle</span><span>(</span><span>3.4</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"c1的id："</span> <span>+</span> c1<span>.</span><span>getId</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"c2的id："</span> <span>+</span> c2<span>.</span><span>getId</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"c2的id："</span> <span>+</span> c3<span>.</span><span>getId</span><span>(</span><span>)</span><span>)</span><span>;</span>

        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"创建的圆的个数为："</span> <span>+</span> <span>Circle</span><span>.</span><span>getTotal</span><span>(</span><span>)</span><span>)</span><span>;</span>

    <span>}</span>
<span>}</span>
<span>class</span> <span>Circle</span><span>{</span>
    <span>private</span> <span>double</span> radius<span>;</span>
    <span>private</span> <span>int</span> id<span>;</span>

    <span>public</span> <span>Circle</span><span>(</span><span>)</span> <span>{</span>
        id <span>=</span> init<span>++</span><span>;</span>
        total<span>++</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>Circle</span><span>(</span><span>double</span> radius<span>)</span> <span>{</span>
        <span>this</span><span>(</span><span>)</span><span>;</span>
        <span>//this();等同于</span>
        <span>// id = init++;</span>
        <span>// total++;</span>
        <span>this</span><span>.</span>radius <span>=</span> radius<span>;</span>
    <span>}</span>

    <span>private</span> <span>static</span> <span>int</span> total<span>;</span><span>//记录创建圆的个数</span>
    <span>private</span> <span>static</span> <span>int</span> init <span>=</span> <span>1001</span><span>;</span><span>//static声明的属性被所以对象所共享</span>

    <span>public</span> <span>double</span> <span>finaArea</span><span>(</span><span>)</span><span>{</span>
        <span>return</span> <span>Math</span><span>.</span>PI <span>*</span> radius <span>*</span> radius<span>;</span>
    <span>}</span>

    <span>public</span> <span>double</span> <span>getRadius</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> radius<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setRadius</span><span>(</span><span>double</span> radius<span>)</span> <span>{</span>
        <span>this</span><span>.</span>radius <span>=</span> radius<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getId</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> id<span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>int</span> <span>getTotal</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> total<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br></div></div><h3 id="练习-7"> 练习</h3>
<ul>
<li>编写一个类实现银行账户的概念，包含的属性有“帐号”、“密码”、“存款余额”、“利率”、“最小余额”，定义封装这些属性的方法。 账号要自动生成。编写主类，使用银行账户类，输入、输出3个储户的上述信息。</li>
<li>考虑：哪些属性可以设计成static属性。</li>
</ul>
<div><pre><code><span>//Account.java</span>
<span>public</span> <span>class</span> <span>Account</span> <span>{</span>
    <span>private</span> <span>int</span> id<span>;</span>
    <span>private</span> <span>String</span> pwd<span>=</span><span>"000000"</span><span>;</span>
    <span>private</span> <span>double</span> balance<span>;</span>

    <span>private</span> <span>static</span> <span>double</span> interestRate<span>;</span>
    <span>private</span> <span>static</span> <span>double</span> minMoney <span>=</span> <span>1.0</span><span>;</span>
    <span>private</span> <span>static</span> <span>int</span> init <span>=</span> <span>1001</span><span>;</span><span>//用于自动生成id</span>
    <span>public</span> <span>Account</span><span>(</span><span>)</span><span>{</span>
        id <span>=</span> init<span>++</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>Account</span><span>(</span><span>String</span> pwd<span>,</span><span>double</span> balance<span>)</span><span>{</span>
        <span>this</span><span>(</span><span>)</span><span>;</span>
        <span>this</span><span>.</span>pwd <span>=</span> pwd<span>;</span>
        <span>this</span><span>.</span>balance <span>=</span> balance<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getId</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> id<span>;</span>
    <span>}</span>

    <span>public</span> <span>double</span> <span>getBalance</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> balance<span>;</span>
    <span>}</span>

    <span>public</span> <span>String</span> <span>getPwd</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> pwd<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setPwd</span><span>(</span><span>String</span> pwd<span>)</span> <span>{</span>
        <span>this</span><span>.</span>pwd <span>=</span> pwd<span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>double</span> <span>getInterestRate</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> interestRate<span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>setInterestRate</span><span>(</span><span>double</span> interestRate<span>)</span> <span>{</span>
        <span>Account</span><span>.</span>interestRate <span>=</span> interestRate<span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>double</span> <span>getMinMoney</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> minMoney<span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>setMinMoney</span><span>(</span><span>double</span> minMoney<span>)</span> <span>{</span>
        <span>Account</span><span>.</span>minMoney <span>=</span> minMoney<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>"Account{"</span> <span>+</span>
                <span>"id="</span> <span>+</span> id <span>+</span>
                <span>", pwd='"</span> <span>+</span> pwd <span>+</span> <span>'\''</span> <span>+</span>
                <span>", balance="</span> <span>+</span> balance <span>+</span>
                <span>'}'</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br></div></div><div><pre><code><span>//AccountTest.java</span>
<span>public</span> <span>class</span> <span>AccountTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Account</span> acct1 <span>=</span> <span>new</span> <span>Account</span><span>(</span><span>)</span><span>;</span>
        <span>Account</span> acct2 <span>=</span> <span>new</span> <span>Account</span><span>(</span><span>"qwerty"</span><span>,</span><span>2000</span><span>)</span><span>;</span>
        <span>Account</span><span>.</span><span>setInterestRate</span><span>(</span><span>0.012</span><span>)</span><span>;</span>
        <span>Account</span><span>.</span><span>setMinMoney</span><span>(</span><span>100</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>acct1<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>acct2<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>acct1<span>.</span><span>getInterestRate</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>acct1<span>.</span><span>getMinMoney</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="单例-singleton-设计模式"> 单例(Singleton)设计模式</h3>
<ul>
<li>设计模式<strong>是在大量的实践中总结和理论化之后优选的代码结构、编程风格、</strong>
<strong>以及解决问题的思考方式</strong>。 设计模免去我们自己再思考和摸索。就像是经典
的棋谱，不同的棋局，我们用不同的棋谱。 设计模式就好比**”套路”**</li>
<li>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类<strong>只能存在一个对象实例</strong>，并且该类只提供一个取得其对象实例的方法。如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将类的<strong>构****造器的访问权限设置为private</strong>，这样，就不能用new操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，<strong>只能调用该类的某个静态方法</strong>以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的该类对象的变量也必须定义成静态的。**</li>
<li>由于单例模式只生成一个实例， <strong>减少了系统性能开销</strong>，当一个对象的
产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可
以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方
式来解决。</li>
</ul>
<h4 id="饿汉式与懒汉式"> 饿汉式与懒汉式</h4>
<ul>
<li>单例设计模式
<ol>
<li>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例</li>
<li>如何实现？
<ul>
<li>饿汉式与懒汉式</li>
</ul>
</li>
<li>区分饿汉式和懒汉式
<ul>
<li>饿汉式
<ul>
<li>坏处：对象加载时间过长</li>
<li>好处：饿汉式是线程安全的</li>
</ul>
</li>
<li>懒汉式
<ul>
<li>好处：延迟对象的创建</li>
<li>坏处：目前的写法坏处是线程不安全的（于多线程内容时再修改）</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>若笔试中没有明确要求饿汉式或懒汉式，建议写饿汉式，因为其结构简单，且无线程安全问题</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>SingletonTest1</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>//饿汉式</span>
        <span>Bank</span> bank1 <span>=</span> <span>Bank</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>
        <span>Bank</span> bank2 <span>=</span> <span>Bank</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>bank1 <span>==</span> bank2<span>)</span><span>;</span>
        <span>//懒汉式</span>
        <span>Order</span> order1 <span>=</span> <span>Order</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>
        <span>Order</span> order2 <span>=</span> <span>Order</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>order1 <span>==</span> order2<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>//饿汉式</span>
<span>class</span> <span>Bank</span><span>{</span>
    <span>//1. 私有化类的构造器</span>
    <span>private</span> <span>Bank</span><span>(</span><span>)</span><span>{</span>

    <span>}</span>
    <span>//2. 内部创建类的对象</span>
    <span>//4.  要求此对象也必须声明为静态的</span>
    <span>private</span> <span>static</span> <span>Bank</span> instance <span>=</span> <span>new</span> <span>Bank</span><span>(</span><span>)</span><span>;</span>

    <span>//3. 提供公共的静态的方法，返回类的对象</span>
    <span>public</span> <span>static</span> <span>Bank</span> <span>getInstance</span><span>(</span><span>)</span><span>{</span>
        <span>return</span> instance<span>;</span>
    <span>}</span>
<span>}</span>

<span>//懒汉式</span>
<span>class</span> <span>Order</span><span>{</span>
    <span>//1. 私有化类的构造器</span>
    <span>private</span> <span>Order</span><span>(</span><span>)</span><span>{</span>

    <span>}</span>
    <span>//2. 声明当前类对象，没有初始化</span>
    <span>//4. 此对象也必须声明为static</span>
    <span>private</span> <span>static</span> <span>Order</span> instance <span>=</span> <span>null</span><span>;</span>

    <span>//3. 声明public、static的返回当前类对象的方法</span>
    <span>public</span> <span>static</span> <span>Order</span> <span>getInstance</span><span>(</span><span>)</span><span>{</span>
        <span>if</span> <span>(</span>instance <span>==</span> <span>null</span><span>)</span><span>{</span>
            instance <span>=</span> <span>new</span> <span>Order</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> instance<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><h4 id="单例设计模式的应用场景"> 单例设计模式的应用场景</h4>
<ul>
<li>网站的计数器，一般也是单例模式实现，否则难以同步。</li>
<li>应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作， 否则内容不好追加。</li>
<li>数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。</li>
<li>项目中， 读取配置文件的类，一般也只有一个对象。没有必要每次使用配置文件数据，都生成一个对象去读取。</li>
<li>Application 也是单例的典型应用</li>
<li>Windows的Task Manager (任务管理器)就是很典型的单例模式</li>
<li>Windows的Recycle Bin (回收站)也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例</li>
</ul>
<h2 id="经典的设计模式"> 经典的设计模式</h2>
<p>设计模式<strong>是在大量的实践中总结和理论化之后优选的代码结构、编程风格、</strong>
<strong>以及解决问题的思考方式</strong>。 设计模免去我们自己再思考和摸索。就像是经典
的棋谱，不同的棋局，我们用不同的棋谱。 设计模式就好比**”套路”**</p>
<ul>
<li>创建型模式：共五种
<ul>
<li>工厂方式模式、抽象工厂模式、单例模式、建造者模式、原型模式</li>
</ul>
</li>
<li>结构型模式：共七种
<ul>
<li>适配器模式、装饰器模式、代理模式、外观模式、组合模式、享元模式</li>
</ul>
</li>
<li>行为型模式：共十一种
<ul>
<li>策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式</li>
</ul>
</li>
</ul>
<h2 id="理解main方法的语法"> 理解main方法的语法</h2>
<ul>
<li>
<p>概念</p>
<ul>
<li>
<p>由于Java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public， 又因为Java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static的，该方法接收一个String类型的数组参数，该数组中保存执行Java命令时传递给所运行的类的参数。</p>
</li>
<li>
<p>又因为main() 方法是静态的，我们不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员，这种情况，我们在之前的例子中多次碰到</p>
</li>
<li>
<p>命令行参数用法举例</p>
<p><img src="./images/04类与面向对象/image-20211215214940998.png" alt="image-20211215214940998" /></p>
</li>
</ul>
</li>
<li>
<p>静态里面只能调用静态，因为静态方法或变量是在对象之前初始化的（static的知识点）</p>
</li>
<li>
<p><strong>在其他的方法中可以也使用main()方法，且main方法也可以传入数据</strong></p>
</li>
<li>
<p>你也可以使用main()方法按带参的方式进行运行</p>
<ul>
<li>在idea中运行
<ul>
<li>找到函数入口的<code>Edit Configurations</code>，找到<code>Program arguments</code>，其中的内容可以直接填写，用空格隔开，带双引号和不带双引号都一样，都是String类型</li>
</ul>
</li>
<li>在cmd中运行
<ul>
<li>先使用<code>javac MainDemo.java</code>编译，注意此时文件不能带有<code>package</code>引入，否则会执行报错</li>
<li>使用<code>java MainDemo 17 97 &quot;98&quot; 9</code>带参执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<div><pre><code><span>//MainDemo.java</span>
<span>public</span> <span>class</span> <span>MainDemo</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span>i <span>&lt;</span> args<span>.</span>length<span>;</span>i<span>++</span><span>)</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"***"</span> <span>+</span> args<span>[</span>i<span>]</span><span>)</span><span>;</span>

            <span>int</span> num <span>=</span> <span>Integer</span><span>.</span><span>parseInt</span><span>(</span>args<span>[</span>i<span>]</span><span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"###"</span> <span>+</span> num<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="类的成员之四-代码块-或初始化块"> 类的成员之四：代码块（或初始化块）</h2>
<p>2021-12-19</p>
<ul>
<li>默认情况下toString只会将当前类的非static的属性输出</li>
<li>一般情况使用代码块的频率不高且不会用多个重复的代码块</li>
<li>在main方法执行前，会先执行父类的static的代码块</li>
<li>代码块就是用大括号括起来的结构</li>
</ul>
<ol>
<li>
<p>代码块的作用：用来初始化类、对象</p>
</li>
<li>
<p>代码块如果有修饰的话，只能用static</p>
</li>
<li>
<p>分类：静态代码块与非静态代码块</p>
</li>
<li>
<p>静态代码块</p>
<ul>
<li>内部可以有输出语句</li>
<li>随着<strong>类的加载</strong>而执行，而且只执行一次</li>
<li>作用：初始化类的信息</li>
<li>如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行（可以定义多个，但一般只用一个</li>
<li>静态代码快的执行要优先于非静态代码块的执行</li>
<li>静态代码块内只能调用静态的属性、静态的方法、不能调用非静态的结构</li>
</ul>
</li>
<li>
<p>非静态代码块</p>
<ul>
<li>内部可以有输出语句</li>
<li>随着<strong>对象的创建</strong>而执行</li>
<li>每创建一个对象，就执行一次非静态代码块</li>
<li>作用：可以在创建对象时，对对象的属性等进行初始化</li>
<li>如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行（可以定义多个，但一般只用一个</li>
<li>非静态代码块内可以调用静态的属性、静态的方法或非静态的属性、非静态的方法</li>
</ul>
</li>
</ol>
<ul>
<li>对属性可以赋值的位置
<ol>
<li>默认初始化</li>
<li>显示初始化</li>
<li>构造器中初始化</li>
<li>有了对象以后，可以通过<code>对象.属性</code>或<code>对象.方法</code>的方式进行赋值</li>
<li>在代码块中赋值</li>
</ol>
</li>
</ul>
<h3 id="练习-8"> 练习</h3>
<ul>
<li>LeafTest.java Son.java</li>
<li>由父及子，静态先行</li>
<li>在main方法执行前，也会执行super()前往父类中的static的代码块</li>
<li>当new()子类时，也会super()将父类也进行一次构造从而执行了父类的非静态代码块与构造器</li>
</ul>
<h2 id="关键字-final"> 关键字：final</h2>
<ul>
<li>native是调用底层的c/c++的代码</li>
<li>final：最终的
<ol>
<li>final可以来修饰的结构：类、方法、变量</li>
<li>final用来修饰一个<strong>类</strong>：此类不能被其他类继承
<ul>
<li>例如：String类、System类、StringBuffer类</li>
</ul>
</li>
<li>final用来修饰一个<strong>方法</strong>：表明此方法不可以被重写
<ul>
<li>比如：Object类中getClass();</li>
</ul>
</li>
<li>final用来修饰<strong>变量</strong>：此时的&quot;变量&quot;就称为是一个常量
<ol>
<li>final修饰属性：可以考虑赋值的位置有：<strong>显示初始化、代码块中初始化、构造器中初始化</strong></li>
<li>final修饰局部变量：
<ul>
<li>尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重写赋值</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li>final static
<ul>
<li>final static 修饰属性一般用于：全局常量（一般是使用大写的变量表明常量）</li>
<li>final static 修饰方法一般用于：类中不能被修改方法</li>
</ul>
</li>
<li>一般不允许默认初始化常量，但如果要使用默认初始化则需要在代码块或构造器中赋值</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>Something</span><span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span><span>P</span><span>{</span>
        <span>Other</span> o <span>=</span> <span>new</span> <span>Other</span><span>(</span><span>)</span><span>;</span>
    	<span>new</span> <span>Something</span><span>(</span><span>)</span><span>.</span><span>addOne</span><span>(</span>o<span>)</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>addOne</span><span>(</span><span>final</span> <span>Other</span> o<span>)</span><span>{</span>
        <span>//o = new Other；</span>
        <span>//这样是可以的，因为只要不改变常量o即可</span>
        o<span>.</span>i<span>++</span><span>;</span>
    <span>}</span>
<span>}</span>
<span>class</span> <span>Other</span><span>{</span>
    <span>public</span> <span>int</span> i<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="考察-6"> 考察</h3>
<ol>
<li>
<p>static修饰的属性，相较于实例变量，有哪些特别之处(&gt;=3点)</p>
<ul>
<li>随着类的加载而加载</li>
<li>static要早于对象的创建</li>
<li>只要权限允许，可以通过<code>对象.static的属性</code>的方式去调用</li>
<li>static是存储在方法区的静态域中
<ul>
<li>静态域是用于专门存放static声明的属性</li>
</ul>
</li>
</ul>
</li>
<li>
<p>final可以用来修饰哪些结构，分别表示上面意思</p>
<ul>
<li>修饰类，类不能被继承</li>
<li>就是方法，方法不能被重写</li>
<li>修饰变量则变量变为常量
<ul>
<li>如果是属性，则变量变为常量，且属性只能被显示初始化、代码块中初始化、构造器中初始化</li>
<li>如果是局部变量，尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重写或</li>
</ul>
</li>
<li>final static 修饰属性一般用于：全局常量（一般是使用大写的变量表明常量）</li>
<li>final static 修饰方法一般用于：类中不能被修改方法</li>
<li>一般常量使用全大写的方式命名</li>
</ul>
</li>
<li>
<p>代码实现单例模式的饿汉式</p>
<div><pre><code><span>//饿汉式</span>
<span>class</span> <span>Bank</span><span>{</span>
    <span>//1. 私有化类的构造器</span>
    <span>private</span> <span>Bank</span><span>(</span><span>)</span><span>{</span>

    <span>}</span>
    <span>//2. 内部创建类的对象</span>
    <span>//4. 要求此对象也必须声明为静态的</span>
    <span>private</span> <span>static</span> <span>Bank</span> instance <span>=</span> <span>new</span> <span>Bank</span><span>(</span><span>)</span><span>;</span>

    <span>//3. 提供公共的静态的方法，返回类的对象</span>
    <span>public</span> <span>static</span> <span>Bank</span> <span>getInstance</span><span>(</span><span>)</span><span>{</span>
        <span>return</span> instance<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div></li>
<li>
<p>代码实现单例模式的懒汉式(目前教的是线程不安全的)</p>
<div><pre><code><span>class</span> <span>Order</span><span>{</span>
    <span>//1. 私有化类的构造器</span>
    <span>private</span> <span>Order</span><span>(</span><span>)</span><span>{</span>

    <span>}</span>
    <span>//2. 声明当前类对象，没有初始化</span>
    <span>//4. 此对象也必须声明为static</span>
    <span>private</span> <span>static</span> <span>Order</span> instance <span>=</span> <span>null</span><span>;</span>

    <span>//3. 声明public、static的返回当前类对象的方法</span>
    <span>public</span> <span>static</span> <span>Order</span> <span>getInstance</span><span>(</span><span>)</span><span>{</span>
        <span>if</span> <span>(</span>instance <span>==</span> <span>null</span><span>)</span><span>{</span>
            instance <span>=</span> <span>new</span> <span>Order</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> instance<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div></li>
<li>
<p>类的属性赋值的位置有哪些？先后顺序为何？</p>
<ul>
<li>默认初始化</li>
<li>显示初始化、代码块中初始化</li>
<li>构造器中初始化</li>
<li>通过<code>对象.属性</code>或<code>对象.方法</code>的方法赋值</li>
</ul>
</li>
</ol>
<h2 id="抽象类与抽象方法"> 抽象类与抽象方法</h2>
<p>day15</p>
<ul>
<li>abstract关键字的使用
<ol>
<li>abstract：抽象的</li>
<li>abstract可以用来修饰结构：类、方法</li>
<li>abstract修饰类：抽象类
<ul>
<li>此类不能实例化</li>
<li>抽象类中一定由构造器，便于子类实例化时调用（涉及到子类对象实例化的全过程）</li>
<li>开发中，都会提供抽象类的子类，让子类对象实例化，完成相关操作</li>
</ul>
</li>
<li>abstract修饰方法：抽象方法
<ul>
<li>抽象方法只要方法的声明，没用方法体</li>
<li>包含抽象方法的类，一定是一个抽象类。反之抽象类中可以没有抽象方法的</li>
<li>若子类重写了父类中所有的抽象方法后，此子类方可实例化。
<ul>
<li>若子类没用重写父类中所有的抽象方法，则子类也是一个抽象类,需要使用abstract修饰</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>abstract使用上的注意点
<ol>
<li>abstract不能用来修饰：属性、构造器等结构</li>
<li>abstract不能用来修饰私有方法、静态方法、final的方法、final的类
<ul>
<li>私有方法子类被抽象则子类没有权限去修改</li>
<li>静态方法被抽象则子类不能被重写</li>
<li>final的方法、类被抽象化不能被重写</li>
</ul>
</li>
</ol>
</li>
<li>为何要使用抽象，我们通过一个实例来说明
<ul>
<li>若我们有交通工具的父类，其下有汽车与摩托的子类，由于汽车与摩托的燃油效率与速度父类不能很好的提供，所以父类中干脆就直接实例化，让子类强制重写</li>
</ul>
</li>
</ul>
<h3 id="思考题"> 思考题</h3>
<ul>
<li>为什么抽象类不可以使用final关键字声明
<ul>
<li>final的方法、类被抽象化不能被重写</li>
</ul>
</li>
<li>一个抽象类中可以定义构造器嘛
<ul>
<li>可以，而且子类也还需要调用构造器</li>
</ul>
</li>
<li>是否可以这样理解：抽象类就是比普通类多定义了抽象方法，除了不能直接进行类的实例化操作之外，并没有任何的不同？
<ul>
<li>包含抽象方法的类，一定是一个抽象类。反之抽象类中可以没有抽象方法的</li>
</ul>
</li>
</ul>
<h3 id="练习-9"> 练习</h3>
<div><pre><code><span>//Employee.java</span>

<span>/*
编写一个Employee类，声明为抽象类，
包含如下三个属性： name， id， salary。
提供必要的构造器和抽象方法： work()
 */</span>
<span>public</span> <span>abstract</span> <span>class</span> <span>Employee</span> <span>{</span>
    <span>private</span> <span>String</span> name<span>;</span>
    <span>private</span> <span>int</span> id<span>;</span>
    <span>private</span> <span>double</span> salary<span>;</span>
    <span>public</span> <span>Employee</span><span>(</span><span>)</span><span>{</span>
        <span>super</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>Employee</span><span>(</span><span>String</span> name<span>,</span> <span>int</span> id<span>,</span> <span>double</span> salary<span>)</span><span>{</span>
        <span>super</span><span>(</span><span>)</span><span>;</span>
        <span>this</span><span>.</span>name<span>=</span>name<span>;</span>
        <span>this</span><span>.</span>id <span>=</span> id<span>;</span>
        <span>this</span><span>.</span>salary <span>=</span> salary<span>;</span>
    <span>}</span>

    <span>public</span> <span>abstract</span> <span>void</span> <span>work</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><div><pre><code><span>//Manager.java</span>
<span>public</span> <span>class</span> <span>Manager</span> <span>extends</span> <span>Employee</span><span>{</span>
    <span>private</span> <span>double</span> bonus<span>;</span><span>//奖金</span>

    <span>public</span> <span>Manager</span><span>(</span><span>double</span> bonus<span>)</span> <span>{</span>
        <span>this</span><span>.</span>bonus <span>=</span> bonus<span>;</span>
    <span>}</span>

    <span>public</span> <span>Manager</span><span>(</span><span>String</span> name<span>,</span> <span>int</span> id<span>,</span> <span>double</span> salary<span>,</span> <span>double</span> bonus<span>)</span> <span>{</span>
        <span>super</span><span>(</span>name<span>,</span> id<span>,</span> salary<span>)</span><span>;</span>
        <span>this</span><span>.</span>bonus <span>=</span> bonus<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>work</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"管理员工"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><div><pre><code><span>//CommonEmployee</span>
<span>public</span> <span>class</span> <span>CommonEmployee</span> <span>extends</span> <span>Employee</span><span>{</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>work</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"员工在一线工作"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code><span>//EmployeeTest</span>
<span>public</span> <span>class</span> <span>EmployeeTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>//多态</span>
        <span>Employee</span> manager <span>=</span> <span>new</span> <span>Manager</span><span>(</span><span>"Bob"</span><span>,</span> <span>1001</span><span>,</span> <span>10000</span><span>,</span> <span>50000</span><span>)</span><span>;</span>
        manager<span>.</span><span>work</span><span>(</span><span>)</span><span>;</span>

        <span>CommonEmployee</span> commonEmployee <span>=</span> <span>new</span> <span>CommonEmployee</span><span>(</span><span>)</span><span>;</span>
        commonEmployee<span>.</span><span>work</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="模板方法设计模式-templatemethod"> 模板方法设计模式（TemplateMethod）</h2>
<ul>
<li>
<p>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。</p>
</li>
<li>
<p>解决的问题：</p>
<ul>
<li>当功能内部一部分实现是确定的， 一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。</li>
<li><strong>换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。</strong></li>
</ul>
</li>
<li>
<p>最直接的一个例子就是，计算方法运行的时间，在中间嵌入一个抽象方法，通过重写与多态的使用，实现模板方法的设计模式</p>
</li>
<li>
<p>模板方法设计模式是编程中经常用得到的模式。 各个框架、 类库中都有他的影子， 比如常见的有：</p>
<ul>
<li>数据库访问的封装</li>
<li>Junit单元测试</li>
<li>JavaWeb的Servlet中关于doGet/doPost方法调用</li>
<li>Hibernate中模板程序</li>
<li>Spring中JDBCTemlate、 HibernateTemplate等</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>TemplateTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>SubTemplate</span> t <span>=</span> <span>new</span> <span>SubTemplate</span><span>(</span><span>)</span><span>;</span>
        t<span>.</span><span>spendTime</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>abstract</span> <span>class</span> <span>Template</span><span>{</span>
    <span>//计算某段代码执行所需要花费的时间</span>
    <span>public</span> <span>void</span> <span>spendTime</span><span>(</span><span>)</span><span>{</span>
        <span>long</span> start <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>

        <span>this</span><span>.</span><span>code</span><span>(</span><span>)</span><span>;</span><span>//不确定、易变的部分</span>

        <span>long</span> end <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"花费的时间为："</span> <span>+</span> <span>(</span>end <span>-</span> start<span>)</span><span>)</span><span>;</span>

    <span>}</span>
    <span>public</span> <span>abstract</span> <span>void</span> <span>code</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
<span>class</span> <span>SubTemplate</span> <span>extends</span> <span>Template</span><span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>code</span><span>(</span><span>)</span> <span>{</span>
        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>2</span><span>;</span>i <span>&lt;=</span> <span>1000</span><span>;</span>i<span>++</span><span>)</span><span>{</span>
            <span>boolean</span> isFlag <span>=</span> <span>true</span><span>;</span>
            <span>for</span><span>(</span><span>int</span> j <span>=</span> <span>2</span><span>;</span>j <span>&lt;=</span> <span>Math</span><span>.</span><span>sqrt</span><span>(</span>i<span>)</span><span>;</span>j<span>++</span><span>)</span><span>{</span>
                <span>if</span><span>(</span>i <span>%</span> j <span>==</span> <span>0</span><span>)</span><span>{</span>
                    isFlag <span>=</span> <span>false</span><span>;</span>
                    <span>break</span><span>;</span>
                <span>}</span>
            <span>}</span>
            <span>if</span><span>(</span>isFlag<span>)</span><span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><div><pre><code><span>package</span> <span>com<span>.</span>atguigu<span>.</span>java</span><span>;</span>
<span>//抽象类的应用：模板方法的设计模式</span>
<span>public</span> <span>class</span> <span>TemplateMethodTest</span> <span>{</span>

	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
		<span>BankTemplateMethod</span> btm <span>=</span> <span>new</span> <span>DrawMoney</span><span>(</span><span>)</span><span>;</span>
		btm<span>.</span><span>process</span><span>(</span><span>)</span><span>;</span>

		<span>BankTemplateMethod</span> btm2 <span>=</span> <span>new</span> <span>ManageMoney</span><span>(</span><span>)</span><span>;</span>
		btm2<span>.</span><span>process</span><span>(</span><span>)</span><span>;</span>
	<span>}</span>
<span>}</span>
<span>abstract</span> <span>class</span> <span>BankTemplateMethod</span> <span>{</span>
	<span>// 具体方法</span>
	<span>public</span> <span>void</span> <span>takeNumber</span><span>(</span><span>)</span> <span>{</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"取号排队"</span><span>)</span><span>;</span>
	<span>}</span>

	<span>public</span> <span>abstract</span> <span>void</span> <span>transact</span><span>(</span><span>)</span><span>;</span> <span>// 办理具体的业务 //钩子方法</span>

	<span>public</span> <span>void</span> <span>evaluate</span><span>(</span><span>)</span> <span>{</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"反馈评分"</span><span>)</span><span>;</span>
	<span>}</span>

	<span>// 模板方法，把基本操作组合到一起，子类一般不能重写</span>
	<span>public</span> <span>final</span> <span>void</span> <span>process</span><span>(</span><span>)</span> <span>{</span>
		<span>this</span><span>.</span><span>takeNumber</span><span>(</span><span>)</span><span>;</span>

		<span>this</span><span>.</span><span>transact</span><span>(</span><span>)</span><span>;</span><span>// 像个钩子，具体执行时，挂哪个子类，就执行哪个子类的实现代码</span>

		<span>this</span><span>.</span><span>evaluate</span><span>(</span><span>)</span><span>;</span>
	<span>}</span>
<span>}</span>

<span>class</span> <span>DrawMoney</span> <span>extends</span> <span>BankTemplateMethod</span> <span>{</span>
	<span>public</span> <span>void</span> <span>transact</span><span>(</span><span>)</span> <span>{</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"我要取款！！！"</span><span>)</span><span>;</span>
	<span>}</span>
<span>}</span>

<span>class</span> <span>ManageMoney</span> <span>extends</span> <span>BankTemplateMethod</span> <span>{</span>
	<span>public</span> <span>void</span> <span>transact</span><span>(</span><span>)</span> <span>{</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"我要理财！我这里有2000万美元!!"</span><span>)</span><span>;</span>
	<span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div></li>
</ul>
<h3 id="练习-10"> 练习</h3>
<div><pre><code><span>//Employee.java</span>
<span>package</span> <span>day15<span>.</span>exer2</span><span>;</span>
<span>/*
定义一个Employee类，该类包含：
private成员变量name,number,birthday，其中birthday 为MyDate类的对象；
abstract方法earnings()；
toString()方法输出对象的name,number和birthday。
 */</span>
<span>public</span> <span>abstract</span> <span>class</span> <span>Employee</span> <span>{</span>
    <span>private</span> <span>String</span> name<span>;</span>
    <span>private</span> <span>int</span> number<span>;</span>
    <span>private</span> <span>MyDate</span> birthday<span>;</span>

    <span>public</span> <span>Employee</span><span>(</span><span>String</span> name<span>,</span> <span>int</span> number<span>,</span> <span>MyDate</span> birthday<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
        <span>this</span><span>.</span>number <span>=</span> number<span>;</span>
        <span>this</span><span>.</span>birthday <span>=</span> birthday<span>;</span>
    <span>}</span>


    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> name<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setName</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getNumber</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> number<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setNumber</span><span>(</span><span>int</span> number<span>)</span> <span>{</span>
        <span>this</span><span>.</span>number <span>=</span> number<span>;</span>
    <span>}</span>

    <span>public</span> <span>MyDate</span> <span>getBirthday</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> birthday<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setBirthday</span><span>(</span><span>MyDate</span> birthday<span>)</span> <span>{</span>
        <span>this</span><span>.</span>birthday <span>=</span> birthday<span>;</span>
    <span>}</span>

    <span>public</span> <span>abstract</span> <span>double</span> <span>earnings</span><span>(</span><span>)</span><span>;</span>

    <span>@Override</span>
    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>"name='"</span> <span>+</span> name <span>+</span> <span>'\''</span> <span>+</span>
                <span>", number="</span> <span>+</span> number <span>+</span>
                <span>", birthday="</span> <span>+</span> birthday<span>.</span><span>toDateString</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><div><pre><code><span>//MyDate.java</span>
<span>package</span> <span>day15<span>.</span>exer2</span><span>;</span>
<span>/*
MyDate类包含:
private成员变量year,month,day ；
toDateString()方法返回日期对应的字符串： xxxx年xx月xx日
 */</span>
<span>public</span> <span>class</span> <span>MyDate</span> <span>{</span>
    <span>private</span> <span>int</span> year<span>;</span>
    <span>private</span> <span>int</span> month<span>;</span>
    <span>private</span> <span>int</span> day<span>;</span>

    <span>public</span> <span>MyDate</span><span>(</span><span>int</span> year<span>,</span> <span>int</span> month<span>,</span> <span>int</span> day<span>)</span> <span>{</span>
        <span>this</span><span>.</span>year <span>=</span> year<span>;</span>
        <span>this</span><span>.</span>month <span>=</span> month<span>;</span>
        <span>this</span><span>.</span>day <span>=</span> day<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getYear</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> year<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setYear</span><span>(</span><span>int</span> year<span>)</span> <span>{</span>
        <span>this</span><span>.</span>year <span>=</span> year<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getMonth</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> month<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setMonth</span><span>(</span><span>int</span> month<span>)</span> <span>{</span>
        <span>this</span><span>.</span>month <span>=</span> month<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getDay</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> day<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setDay</span><span>(</span><span>int</span> day<span>)</span> <span>{</span>
        <span>this</span><span>.</span>day <span>=</span> day<span>;</span>
    <span>}</span>

    <span>public</span> <span>String</span> <span>toDateString</span><span>(</span><span>)</span><span>{</span>
        <span>return</span> year <span>+</span> <span>"年"</span> <span>+</span> month <span>+</span> <span>"月"</span> <span>+</span> day <span>+</span> <span>"日"</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><div><pre><code><span>//SalariedEmployee.java</span>
<span>package</span> <span>day15<span>.</span>exer2</span><span>;</span>
<span>/*
定义SalariedEmployee类继承Employee类，实现按月计算工资的员工处
理。该类包括： private成员变量monthlySalary；
实现父类的抽象方法earnings(),该方法返回monthlySalary值； toString()方法输
出员工类型信息及员工的name， number,birthday。
 */</span>
<span>public</span> <span>class</span> <span>SalariedEmployee</span> <span>extends</span> <span>Employee</span><span>{</span>
    <span>private</span> <span>double</span> monthlySalary<span>;</span><span>//月工资</span>


    <span>public</span> <span>SalariedEmployee</span><span>(</span><span>String</span> name<span>,</span> <span>int</span> number<span>,</span> <span>MyDate</span> birthday<span>)</span> <span>{</span>
        <span>super</span><span>(</span>name<span>,</span> number<span>,</span> birthday<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>SalariedEmployee</span><span>(</span><span>String</span> name<span>,</span> <span>int</span> number<span>,</span> <span>MyDate</span> birthday<span>,</span> <span>double</span> monthlySalary<span>)</span> <span>{</span>
        <span>super</span><span>(</span>name<span>,</span> number<span>,</span> birthday<span>)</span><span>;</span>
        <span>this</span><span>.</span>monthlySalary <span>=</span> monthlySalary<span>;</span>
    <span>}</span>

    <span>public</span> <span>double</span> <span>getMonthlySalary</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> monthlySalary<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setMonthlySalary</span><span>(</span><span>double</span> monthlySalary<span>)</span> <span>{</span>
        <span>this</span><span>.</span>monthlySalary <span>=</span> monthlySalary<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>double</span> <span>earnings</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> monthlySalary<span>;</span>
    <span>}</span>
    <span>@Override</span>
    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span><span>{</span>
        <span>return</span> <span>"SalariedEmployee["</span> <span>+</span> <span>super</span><span>.</span><span>toString</span><span>(</span><span>)</span> <span>+</span> <span>"]"</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><div><pre><code><span>//HourlyEmployee.java</span>
<span>package</span> <span>day15<span>.</span>exer2</span><span>;</span>
<span>/*
参照SalariedEmployee类定义HourlyEmployee类，实现按小时计算工资的
员工处理。该类包括：
private成员变量wage和hour；
实现父类的抽象方法earnings(),该方法返回wage*hour值；
toString()方法输出员工类型信息及员工的name， number,birthday。
 */</span>
<span>public</span> <span>class</span> <span>HourlyEmployee</span> <span>extends</span> <span>Employee</span><span>{</span>
    <span>private</span> <span>int</span> wage<span>;</span><span>//每小时的工资</span>
    <span>private</span> <span>int</span> hour<span>;</span><span>//月工作的小时数</span>


    <span>public</span> <span>HourlyEmployee</span><span>(</span><span>String</span> name<span>,</span> <span>int</span> number<span>,</span> <span>MyDate</span> birthday<span>)</span> <span>{</span>
        <span>super</span><span>(</span>name<span>,</span> number<span>,</span> birthday<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>HourlyEmployee</span><span>(</span><span>String</span> name<span>,</span> <span>int</span> number<span>,</span> <span>MyDate</span> birthday<span>,</span> <span>int</span> wage<span>,</span> <span>int</span> hour<span>)</span> <span>{</span>
        <span>super</span><span>(</span>name<span>,</span> number<span>,</span> birthday<span>)</span><span>;</span>
        <span>this</span><span>.</span>wage <span>=</span> wage<span>;</span>
        <span>this</span><span>.</span>hour <span>=</span> hour<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getWage</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> wage<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setWage</span><span>(</span><span>int</span> wage<span>)</span> <span>{</span>
        <span>this</span><span>.</span>wage <span>=</span> wage<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getHour</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> hour<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setHour</span><span>(</span><span>int</span> hour<span>)</span> <span>{</span>
        <span>this</span><span>.</span>hour <span>=</span> hour<span>;</span>
    <span>}</span>

    <span>/**
     * @description: 时薪
     * @return  double
     * @author  bit
     * @date    2021/12/22 21:57
     */</span>
    <span>@Override</span>
    <span>public</span> <span>double</span> <span>earnings</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> wage <span>*</span> hour<span>;</span>
    <span>}</span>
    <span>@Override</span>
    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span><span>{</span>
        <span>return</span> <span>"HourlyEmployee["</span> <span>+</span> <span>super</span><span>.</span><span>toString</span><span>(</span><span>)</span> <span>+</span> <span>"]"</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div><div><pre><code><span>//PayrollSystem.java</span>
<span>package</span> <span>day15<span>.</span>exer2</span><span>;</span>

<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Calendar</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Scanner</span><span>;</span>

<span>/*
定义PayrollSystem类，创建Employee变量数组并初始化，该数组存放各
类雇员对象的引用。利用循环结构遍历数组元素，输出各个对象的类
型,name,number,birthday,以及该对象生日。当键盘输入本月月份值时，如果本
月是某个Employee对象的生日，还要输出增加工资信息。
 */</span>
<span>public</span> <span>class</span> <span>PayrollSystem</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>//方式一：手动输入当前月份</span>
        <span>// Scanner scanner = new Scanner(System.in);</span>
        <span>// System.out.println("请输入当月的月份：");</span>
        <span>// int month = scanner.nextInt();</span>

        <span>//方式二：自动获取当前月份</span>
        <span>//使用Calendar（日历，获取的月是从0开始的，即0为1月，所以输出判断时记得+1</span>
        <span>Calendar</span> calendar <span>=</span> <span>Calendar</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> month <span>=</span> calendar<span>.</span><span>get</span><span>(</span><span>Calendar</span><span>.</span>MONTH<span>)</span><span>;</span>

        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"当前是"</span> <span>+</span> <span>(</span>month<span>+</span><span>1</span><span>)</span> <span>+</span> <span>"月"</span><span>)</span><span>;</span>

        <span>//new了个长度为2的数组，里面暂时声明为抽象对象</span>
        <span>Employee</span><span>[</span><span>]</span> emps <span>=</span> <span>new</span> <span>Employee</span><span>[</span><span>2</span><span>]</span><span>;</span>

        emps<span>[</span><span>0</span><span>]</span> <span>=</span> <span>new</span> <span>SalariedEmployee</span><span>(</span><span>"Mary"</span><span>,</span> <span>1002</span><span>,</span> <span>new</span> <span>MyDate</span><span>(</span><span>1992</span><span>,</span> <span>2</span><span>,</span> <span>18</span><span>)</span><span>,</span> <span>5000</span><span>)</span><span>;</span>
        emps<span>[</span><span>1</span><span>]</span> <span>=</span> <span>new</span> <span>HourlyEmployee</span><span>(</span><span>"Jan"</span><span>,</span> <span>1002</span><span>,</span> <span>new</span> <span>MyDate</span><span>(</span><span>1999</span><span>,</span> <span>5</span><span>,</span> <span>29</span><span>)</span><span>,</span><span>60</span><span>,</span> <span>240</span><span>)</span><span>;</span>

        <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span>i <span>&lt;</span> emps<span>.</span>length<span>;</span>i<span>++</span><span>)</span><span>{</span>
            <span>int</span> birMoney <span>=</span> <span>0</span><span>;</span>

            <span>if</span><span>(</span>month <span>==</span> emps<span>[</span>i<span>]</span><span>.</span><span>getBirthday</span><span>(</span><span>)</span><span>.</span><span>getMonth</span><span>(</span><span>)</span><span>)</span><span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"生日快乐！奖励100元。"</span><span>)</span><span>;</span>
                birMoney <span>+=</span> <span>100</span><span>;</span>
            <span>}</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>emps<span>[</span>i<span>]</span><span>)</span><span>;</span>
            <span>double</span> salary <span>=</span> emps<span>[</span>i<span>]</span><span>.</span><span>earnings</span><span>(</span><span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"月工资为："</span> <span>+</span> <span>(</span>salary <span>+</span> birMoney<span>)</span><span>)</span><span>;</span>


        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><h2 id="接口-interface"> 接口（interface）</h2>
<ul>
<li>
<p>接口解决了类的单继承性，得到多重继承的效果</p>
</li>
<li>
<p>一方面， 有时必须从几个类中派生出一个子类， 继承它们所有的属性和方法。 但是， Java不支持多重继承。 有了接口， 就可以得到<strong>多重继承的效果。</strong></p>
</li>
<li>
<p>另一方面， 有时必须从几个类中抽取出一些共同的行为特征，而它们之间又没有is-a的关系，仅仅是具有相同的行为特征而已。例如：鼠标、键盘、打印机、扫描仪、摄像头、充电器、 MP3机、手机、数码相机、移动硬盘等都支持USB连接。</p>
</li>
<li>
<p>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要...则必须能...”的思想。 <strong>继承是一个&quot;是不是&quot;的关系，而接口实现则是 &quot;能不能&quot;的关系。</strong></p>
</li>
<li>
<p><strong>接口的本质是契约，标准，规范</strong>，就像我们的法律一样。制定好后大家都要遵守。</p>
</li>
<li>
<p>接口的使用</p>
<ul>
<li>接口使用interface来定义</li>
</ul>
<ol start="2">
<li>java中，接口和类是并列的两个结构</li>
<li>如何定义接口，定义接口中的成员
<ol>
<li>JDK7以前，只能定义全局常量和抽象方法
<ul>
<li>全局常量：public static final;
<ul>
<li>但书写时，可以省略不写</li>
</ul>
</li>
<li>抽象方法：public abstract</li>
</ul>
</li>
<li>JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法（后面涉及）</li>
</ol>
</li>
<li>**接口中不能定义构造器！**意味着接口不可以实例化</li>
<li>java开发中，接口一般通过让类去实现(implements)的方式来使用
<ul>
<li>如果实现类覆盖了接口中的所以抽象方法，则此实现类就可以实例化</li>
<li>如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类</li>
</ul>
</li>
<li>java类可以实现多个接口（多实现）-&gt; 弥补了java单继承性的局限性问题
<ul>
<li>格式：<code>class AA extends BB implements CC[,dd,ee]{}</code></li>
</ul>
</li>
<li>接口与接口之间可以多继承，而且可以多继承
<ul>
<li>接口和类之间关系叫实现，类和类之间的关系叫继承</li>
</ul>
</li>
<li>接口的具体使用，体现多态性</li>
<li>接口，实际上可以看作是一种规范</li>
</ol>
<ul>
<li>面试题抽象类和接口有哪些异同？</li>
</ul>
</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>InterfaceTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Flyable</span><span>.</span>MAX_SPEED<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Flyable</span><span>.</span>MIN_SPEED<span>)</span><span>;</span>
        <span>// Flyable.MIN_SPEED = 2;</span>

        <span>Plane</span> plane <span>=</span> <span>new</span> <span>Plane</span><span>(</span><span>)</span><span>;</span>
        plane<span>.</span><span>fly</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

<span>}</span>
<span>interface</span> <span>Flyable</span><span>{</span>
    <span>//全局常量</span>
    <span>public</span> <span>static</span> <span>final</span> <span>int</span> MAX_SPEED <span>=</span> <span>7900</span><span>;</span><span>//第一宇宙速度</span>
    <span>//省略了public static final</span>
    <span>int</span> MIN_SPEED <span>=</span> <span>1</span><span>;</span>

    <span>//抽象方法</span>
    <span>public</span> <span>abstract</span> <span>void</span> <span>fly</span><span>(</span><span>)</span><span>;</span>
    <span>//省略了public abstract</span>
    <span>void</span> <span>stop</span><span>(</span><span>)</span><span>;</span>

    <span>//接口中不能定义构造器</span>
    <span>// public Flyable(){}</span>
<span>}</span>
<span>interface</span> <span>Attackable</span><span>{</span>
    <span>void</span> <span>attack</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
<span>class</span> <span>Plane</span> <span>implements</span> <span>Flyable</span><span>{</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>fly</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"飞机通过引擎飞起来"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>stop</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"飞机反推进或刹车停止"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>abstract</span> <span>class</span> <span>Kite</span> <span>implements</span> <span>Flyable</span><span>{</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>fly</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"风筝通过风飞起来"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
<span>class</span> <span>Bullet</span> <span>extends</span> <span>Object</span> <span>implements</span> <span>Flyable</span><span>,</span> <span>Attackable</span><span>,</span>CC<span>{</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>fly</span><span>(</span><span>)</span> <span>{</span>

    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>stop</span><span>(</span><span>)</span> <span>{</span>

    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>attack</span><span>(</span><span>)</span> <span>{</span>

    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>method1</span><span>(</span><span>)</span> <span>{</span>

    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>method2</span><span>(</span><span>)</span> <span>{</span>

    <span>}</span>
<span>}</span>
<span>//------------------------</span>

<span>interface</span> AA<span>{</span>
    <span>void</span> <span>method1</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
<span>interface</span> BB<span>{</span>
    <span>void</span> <span>method2</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
<span>interface</span> CC <span>extends</span> AA<span>,</span>BB<span>{</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br></div></div><h3 id="接口的举例"> 接口的举例</h3>
<ol>
<li>接口使用上也满足多态性</li>
<li>接口，实际上就是定义了一种规范</li>
<li>开发中，体会面向接口编程</li>
</ol>
<div><pre><code><span>public</span> <span>class</span> <span>USBTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Computer</span> com <span>=</span> <span>new</span> <span>Computer</span><span>(</span><span>)</span><span>;</span>
        <span>//1. 创建了接口的非匿名实现类的非匿名对象</span>
        <span>Flash</span> flash <span>=</span> <span>new</span> <span>Flash</span><span>(</span><span>)</span><span>;</span>
        com<span>.</span><span>transferData</span><span>(</span>flash<span>)</span><span>;</span>

        <span>//2. 创建接口的非匿名实现类的匿名对象</span>
        com<span>.</span><span>transferData</span><span>(</span><span>new</span> <span>Printer</span><span>(</span><span>)</span><span>)</span><span>;</span>

        <span>//3. 创建接口的匿名实现类的非匿名对象</span>
        <span>USB</span> phone <span>=</span> <span>new</span> <span>USB</span><span>(</span><span>)</span><span>{</span>

            <span>@Override</span>
            <span>public</span> <span>void</span> <span>start</span><span>(</span><span>)</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"手机开始"</span><span>)</span><span>;</span>
            <span>}</span>

            <span>@Override</span>
            <span>public</span> <span>void</span> <span>stop</span><span>(</span><span>)</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"手机结束"</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span><span>;</span>
        com<span>.</span><span>transferData</span><span>(</span>phone<span>)</span><span>;</span>

        <span>//4. 创建接口的匿名实现类的匿名对象</span>
        com<span>.</span><span>transferData</span><span>(</span><span>new</span> <span>USB</span><span>(</span><span>)</span><span>{</span>
            <span>@Override</span>
            <span>public</span> <span>void</span> <span>start</span><span>(</span><span>)</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"mp3开始"</span><span>)</span><span>;</span>
            <span>}</span>

            <span>@Override</span>
            <span>public</span> <span>void</span> <span>stop</span><span>(</span><span>)</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"mp3结束"</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
<span>class</span> <span>Computer</span><span>{</span>
    <span>//体现了接口的多态性</span>
    <span>public</span> <span>void</span> <span>transferData</span><span>(</span><span>USB</span> usb<span>)</span><span>{</span><span>//USB usb = new Flash();</span>
        usb<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>

        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"设备传输..."</span><span>)</span><span>;</span>

        usb<span>.</span><span>stop</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
<span>interface</span> USB<span>{</span>
    <span>//常量：长宽高、最小传输速度等</span>

    <span>void</span> <span>start</span><span>(</span><span>)</span><span>;</span>
    <span>void</span> <span>stop</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
<span>class</span> <span>Flash</span> <span>implements</span> USB<span>{</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>start</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"U盘开启工作"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>stop</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"U盘结束工作"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
<span>class</span> <span>Printer</span> <span>implements</span> USB<span>{</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>start</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"打印机开始工作"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>stop</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"打印机结束工作"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br></div></div><h2 id="代理模式-proxy-接口的应用"> 代理模式(Proxy) - 接口的应用</h2>
<ul>
<li>
<p>概念</p>
<ul>
<li>
<p>代理模式是java开发中使用较多的一种设计模式代理设计就是为其他对象提供一种代理以控制对这个对象的访问。</p>
<p><img src="./images/04类与面向对象/image-20211228204545213.png" alt="image-20211228204545213" /></p>
</li>
</ul>
</li>
</ul>
<h3 id="应用场景"> 应用场景：</h3>
<ul>
<li>
<p>安全代理： 屏蔽对真实角色的直接访问。</p>
</li>
<li>
<p>远程代理： 通过代理类处理远程方法调用（RMI）</p>
</li>
<li>
<p>延迟加载： 先加载轻量级的代理对象， 真正需要再加载真实对象</p>
</li>
<li>
<p>比如你要开发一个大文档查看软件， 大文档中有大的图片， 有可能一个图片有100MB， 在打开文件时， 不可能将所有的图片都显示出来， 这样就可以使用代理模式， 当需要查看图片时， 用proxy来进行大图片的打开。</p>
</li>
<li>
<p>分类</p>
<ul>
<li>静态代理（静态定义代理类）</li>
<li>动态代理（动态生成代理类）
<ul>
<li>JDK自带的动态代理， 需要反射等知识</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="面试题-排错-父类与接口的变量重名问题"> 面试题：排错（父类与接口的变量重名问题）</h3>
<div><pre><code><span>interface</span> <span>A</span><span>{</span>
    <span>int</span> x <span>=</span> <span>0</span><span>;</span>
    <span>int</span> x1 <span>=</span> <span>0</span><span>;</span>
<span>}</span>
<span>class</span> <span>B</span><span>{</span>
    <span>int</span> x <span>=</span> <span>1</span><span>;</span>
    <span>int</span> x2 <span>=</span> <span>1</span><span>;</span>
<span>}</span>
<span>class</span> <span>C</span> <span>extends</span> <span>B</span> <span>implements</span> <span>A</span><span>{</span>
    <span>//由于extends继承和implement实现的等级处于同一级别，会导致输出x不知道输出谁，会报错</span>
    <span>public</span> <span>void</span> <span>pX</span><span>(</span><span>)</span><span>{</span>
        <span>//编译不通过，因为x的值是不明确的，父类与接口变量名重名了</span>
        <span>//System.out.println(x);</span>
        <span>//如果需要调用父类的x</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>super</span><span>.</span>x<span>)</span><span>;</span><span>//1</span>
        <span>//如果需要调用父类的x</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>A</span><span>.</span>x<span>)</span><span>;</span><span>//0</span>
        <span>//如果是不同的情况</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>x1<span>)</span><span>;</span><span>//0</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>x2<span>)</span><span>;</span><span>//1</span>
    <span>}</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span><span>{</span>
        <span>new</span> <span>C</span><span>(</span><span>)</span><span>.</span><span>pX</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h3 id="面试题-排错-对于接口中定义的常量"> 面试题：排错（对于接口中定义的常量）</h3>
<div><pre><code><span>interface</span> <span>Playable</span><span>{</span>
    <span>void</span> <span>play</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
<span>interface</span> <span>Bounceable</span><span>{</span>
    <span>void</span> <span>play</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
<span>interface</span> <span>Rollable</span> <span>extends</span> <span>Playable</span><span>,</span> <span>Bounceable</span><span>{</span>
    <span>//ball的声明这里其实省略了</span>
    <span>//public static final Ball ball = new Ball("PingPang");</span>
    <span>Ball</span> ball <span>=</span> <span>new</span> <span>Ball</span><span>(</span><span>"PingPang"</span><span>)</span><span>;</span>
<span>}</span>
<span>class</span> <span>Ball</span> <span>implements</span> <span>Rollable</span><span>{</span>
    <span>private</span> <span>String</span> name<span>;</span>
    
    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span><span>{</span>
        <span>return</span> name<span>;</span>
    <span>}</span>
    <span>public</span> <span>Ball</span><span>(</span><span>String</span> name<span>)</span><span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>play</span><span>(</span><span>)</span><span>{</span>
        <span>//这里会报错，因为ball是常量(final)，而非变量</span>
        <span>//ball = new Ball("Football");</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>ball<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h3 id="练习-11"> 练习</h3>
<h2 id="工厂设计模式-接口的应用"> 工厂设计模式  - 接口的应用</h2>
<p>工厂模式： <strong>实现了创建者与调用者的分离， 即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。</strong></p>
<ul>
<li>工厂模式的设计原则</li>
<li>工厂模式的分类
<ul>
<li><strong>简单工厂模式</strong>： 用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码）
<ul>
<li>简单工厂模式的缺点是对于增加新产品，不修改代码的话，是无法扩展的。 违反了开闭原则（ 对扩展开放；对修改封闭）。</li>
</ul>
</li>
<li><strong>工厂方法模式</strong>： 用来生产同一等级结构中的固定产品。（支持增加任意产品）</li>
<li><strong>抽象工厂模式</strong>： 用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）</li>
</ul>
</li>
<li><strong>核心本质：</strong>
<ul>
<li><strong>实例化对象，用工厂方法代替 new 操作。将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。</strong></li>
</ul>
</li>
<li>一般来说，xxxFactory是xxx的工厂模式</li>
</ul>
<h3 id="工厂方法模式"> 工厂方法模式</h3>
<p>用来生产同一等级结构中的固定产品。（支持增加任意产品）</p>
<h3 id="抽象工厂模式"> 抽象工厂模式</h3>
<p>用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）</p>
<h3 id="java8中关于接口的改进"> Java8中关于接口的改进</h3>
<ol>
<li>接口中定义的静态方法，只能通过接口来调用</li>
<li>通过实现类的对象，可以调用接口中的默认方法</li>
<li>如果子类（或实现类）继承的父类和实现的接口中声明了同名同参数的默认方法，那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法。<strong>【类优先原则】</strong></li>
<li>如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认，那么在实现类没有重写此方法的情况下，就会报错。<strong>【接口冲突】</strong></li>
<li>如何在子类（或实现类）的方法中调用父类、接口中被重写的方法</li>
</ol>
<div><pre><code><span>package</span> <span>day15<span>.</span>java8</span><span>;</span>

<span>public</span> <span>class</span> <span>SubClassTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>SubClass</span> s <span>=</span> <span>new</span> <span>SubClass</span><span>(</span><span>)</span><span>;</span>
        <span>// s.method1();</span>
        <span>// SubClass.method1();</span>
        <span>//知识点1：接口中定义的静态方法，只能通过接口来调用</span>
        <span>CompareA</span><span>.</span><span>method1</span><span>(</span><span>)</span><span>;</span>

        <span>//知识点2：通过实现类的对象，可以调用接口中的默认方法</span>
        <span>//如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法</span>
        s<span>.</span><span>method2</span><span>(</span><span>)</span><span>;</span>
        <span>//知识点3：如果子类（或实现类）继承的父类和实现的接口中声明了同名同参数的默认方法，那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法。**【类优先原则】**</span>
        <span>// SubClass.method2()</span>
        <span>//知识点4：如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认，那么在实现类没有重写此方法的情况下，就会报错。**【接口冲突】**</span>
        <span>//所以这需要我们必须在实现类中重写此方法</span>
        s<span>.</span><span>method3</span><span>(</span><span>)</span><span>;</span>


    <span>}</span>
<span>}</span>
<span>class</span> <span>SubClass</span> <span>extends</span> <span>SuperClass</span> <span>implements</span> <span>CompareA</span><span>,</span> <span>CompareB</span><span>{</span>
<span>// class SubClass implements CompareA, CompareB{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>method2</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"SubClass:上海"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>method3</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"SubClass:深圳"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>//知识点5：如何在子类（或实现类）的方法中调用父类、接口中被重写的方法</span>
    <span>public</span> <span>void</span> <span>myMethod</span><span>(</span><span>)</span><span>{</span>
        <span>method3</span><span>(</span><span>)</span><span>;</span><span>//自己定义的重写方法</span>
        <span>super</span><span>.</span><span>method3</span><span>(</span><span>)</span><span>;</span><span>//调用的是父类中声明的重写方法</span>
        <span>//调用接口中的默认方法</span>
        <span>CompareA</span><span>.</span><span>super</span><span>.</span><span>method3</span><span>(</span><span>)</span><span>;</span>
        <span>CompareB</span><span>.</span><span>super</span><span>.</span><span>method3</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><ul>
<li>
<p>练习</p>
<div><pre><code><span>package</span> <span>day15<span>.</span>java8</span><span>;</span>

<span>interface</span> <span>Filial</span> <span>{</span><span>// 孝顺的</span>
    <span>default</span> <span>void</span> <span>help</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"老妈，我来救你了"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
<span>interface</span> <span>Spoony</span> <span>{</span><span>// 痴情的</span>
    <span>default</span> <span>void</span> <span>help</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"媳妇， 别怕，我来了"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
<span>class</span> <span>Father</span><span>{</span>
    <span>public</span> <span>void</span> <span>help</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"儿子，救我媳妇！"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>class</span> <span>Man</span> <span>extends</span> <span>Father</span> <span>implements</span> <span>Filial</span><span>,</span> <span>Spoony</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>help</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"只能按顺序救人"</span><span>)</span><span>;</span>
        <span>Filial</span><span>.</span><span>super</span><span>.</span><span>help</span><span>(</span><span>)</span><span>;</span>
        <span>Spoony</span><span>.</span><span>super</span><span>.</span><span>help</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div></li>
</ul>
<h2 id="类的成员之五-内部类"> 类的成员之五：内部类</h2>
<p>在开发中整体不多，大多数出现在趴源码的时候</p>
<ol>
<li>java允许将一个类A声明在另一个类B中：则类A就是内部类，类B称为外部类</li>
<li>内部类的分类：成员内部类（静态、非静态）与局部内部类（方法内、代码块内、构造器内）</li>
<li>成员内部类：
<ul>
<li>一方面，作为外部类的成员
<ul>
<li>调用外部类的结构</li>
<li>可以被static修饰</li>
<li>可以被4种不同的权限修饰</li>
</ul>
</li>
<li>另一方面，作为一个类出现
<ul>
<li>类内可以定义属性、方法、构造器等，你也可以无限嵌套内部类，但一般不会这样做</li>
<li>可以被final修饰表示此类不能被继承。反之，不使用final即表示可以被继承</li>
<li>可以被abstract修饰</li>
</ul>
</li>
</ul>
</li>
<li>关注如下的3个问题
<ol>
<li>如何实例化成员内部类的对象</li>
<li>如何在成员内部类中区分调用外部类的结构</li>
<li>开发中局部内部类的使用</li>
</ol>
</li>
</ol>
<div><pre><code><span>public</span> <span>class</span> <span>InnerClassTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>//1. 如何实例化成员内部类的对象</span>
        <span>//创建Dog实例(静态的成员内部类)</span>
        <span>Person<span>.</span>Dog</span> dog <span>=</span> <span>new</span> <span>Person<span>.</span>Dog</span><span>(</span><span>)</span><span>;</span>
        dog<span>.</span><span>show</span><span>(</span><span>)</span><span>;</span>

        <span>//创建Bird实例(静态的成员内部类)</span>
        <span>// Person.Bird bird = new Person.Bird();//错误的</span>
        <span>Person</span> p <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span>
        <span>//有了对象之后用对象去调内部的结构</span>
        <span>// Person.Bird bird = p.new Person.Bird();//一样的</span>
        <span>Person<span>.</span>Bird</span> bird <span>=</span> p<span>.</span><span>new</span> <span>Bird</span><span>(</span><span>)</span><span>;</span>
        bird<span>.</span><span>sing</span><span>(</span><span>)</span><span>;</span>

        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"---------"</span><span>)</span><span>;</span>
        bird<span>.</span><span>display</span><span>(</span><span>"黄鹂"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
<span>class</span> <span>Person</span><span>{</span>
    <span>String</span> name <span>=</span> <span>"小米"</span><span>;</span>
    <span>int</span> age<span>;</span>

    <span>public</span> <span>void</span> <span>eat</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"person eating food"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>static</span> <span>void</span> <span>run</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"running"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>//静态成员内部类</span>
    <span>// abstract static class Dog{</span>
    <span>static</span> <span>class</span> <span>Dog</span><span>{</span>
        <span>String</span> name<span>;</span>
        <span>int</span> age<span>;</span>
        <span>public</span> <span>void</span> <span>show</span><span>(</span><span>)</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"卡拉是条狗"</span><span>)</span><span>;</span>
            <span>//静态会早于非静态的声明，所以不能调用</span>
            <span>// eat();</span>
            <span>run</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>//非静态成员内部类</span>
    <span>// final class Bird{</span>
    <span>class</span> <span>Bird</span><span>{</span>
        <span>String</span> name <span>=</span> <span>"杜鹃"</span><span>;</span>
        <span>public</span> <span>Bird</span><span>(</span><span>)</span><span>{</span>

        <span>}</span>
        <span>public</span> <span>void</span> <span>sing</span><span>(</span><span>)</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"我是一只小鸟"</span><span>)</span><span>;</span>
            <span>//调用外部类的非静态属性</span>
            <span>Person</span><span>.</span><span>this</span><span>.</span><span>eat</span><span>(</span><span>)</span><span>;</span>
            <span>eat</span><span>(</span><span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>age<span>)</span><span>;</span>
        <span>}</span>
  <span>// 2. 如何在成员内部类中区分调用外部类的结构</span>
        <span>//如果出现重名的情况</span>
        <span>public</span> <span>void</span> <span>display</span><span>(</span><span>String</span> name<span>)</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>name<span>)</span><span>;</span><span>//方法的形参</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>this</span><span>.</span>name<span>)</span><span>;</span><span>//内部类的属性</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Person</span><span>.</span><span>this</span><span>.</span>name<span>)</span><span>;</span><span>//外部类的属性</span>
        <span>}</span>
    <span>}</span>
    <span>public</span> <span>void</span> <span>method</span><span>(</span><span>)</span><span>{</span>
        <span>//局部内部类</span>
        <span>class</span> AA<span>{</span>

        <span>}</span>
    <span>}</span>
    <span>//代码块</span>
    <span>{</span>
        <span>//局部内部类</span>
        <span>class</span> BB<span>{</span>

        <span>}</span>
    <span>}</span>

    <span>//构造器</span>
    <span>public</span> <span>Person</span><span>(</span><span>)</span><span>{</span>
        <span>//局部内部类</span>
        <span>class</span> CC<span>{</span>

        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br></div></div><h3 id="开发中局部内部类的使用"> 开发中局部内部类的使用</h3>
<div><pre><code><span>package</span> <span>day15<span>.</span>java2</span><span>;</span>

<span>public</span> <span>class</span> <span>InnerClassTest1</span> <span>{</span>

    <span>//开发中比较少写这种结构</span>
    <span>public</span> <span>void</span> <span>method</span><span>(</span><span>)</span><span>{</span>
        <span>//局部内部类</span>
        <span>class</span> AA<span>{</span>

        <span>}</span>
    <span>}</span>
    <span>//返回一个实现Comparable接口的类的对象</span>
    <span>public</span> <span>Comparable</span> <span>getComparable</span><span>(</span><span>)</span><span>{</span>
        <span>//创建一个实现了Comparable接口的类（局部内部类）</span>
        <span>//方式一：标准方式：创建了一个实现接口的有名实现类的匿名对象</span>
        <span>// class MyComparable implements Comparable{</span>
        <span>//</span>
        <span>//     @Override</span>
        <span>//     public int compareTo(Object o) {</span>
        <span>//         return 0;</span>
        <span>//     }</span>
        <span>// }</span>
        <span>// //由于方法得返回对象，调用方法，方法是接口实现的类，并返回这个实现的类</span>
        <span>// return new MyComparable();</span>

        <span>//方式二：创建了一个实现接口的匿名实现类的匿名对象</span>
        <span>return</span> <span>new</span> <span>Comparable</span><span>(</span><span>)</span><span>{</span>

            <span>@Override</span>
            <span>public</span> <span>int</span> <span>compareTo</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>
                <span>return</span> <span>0</span><span>;</span>
            <span>}</span>
        <span>}</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><h3 id="考察-7"> 考察</h3>
<p>static、final、abstract分别能修饰什么东西？</p>
<ol>
<li>
<p>abstract能修饰哪些结构？修饰以后有什么特点</p>
<ul>
<li>可以修饰：类、方法</li>
<li>类不能实例化，需要提供子类，让子类去实例化（依赖继承性）</li>
<li>方法必须要被实现，抽象方法只定义了一种功能的标准，具体的执行需要子类去实现</li>
</ul>
</li>
<li>
<p>接口是否能继承接口？抽象类是否能实现(implements)接口？抽象类是否能继承非抽象的类？</p>
<ul>
<li>接口可以继承接口</li>
<li>抽象类能实现接口</li>
<li>抽象类可以继承非抽象类</li>
<li>非抽象的类可以继承抽象类</li>
</ul>
</li>
<li>
<p>声明抽象类，并包含抽象方法，测试类中创建一个继承抽象类的匿名子类的对象</p>
<div><pre><code><span>abstract</span> AA<span>{</span>
    <span>public</span> <span>abstract</span> <span>void</span> <span>m</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>//创建匿名子类的对象</span>
    <span>AA</span> a <span>=</span> <span>new</span> <span>AA</span><span>(</span><span>)</span><span>{</span>
        <span>public</span> <span>void</span> <span>m</span><span>(</span><span>)</span><span>{</span>
            
        <span>}</span>
    <span>}</span><span>;</span>
    <span>//执行重写的方法</span>
    a<span>.</span><span>m</span><span>(</span><span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><pre><code><span>class</span> <span>Person</span><span>{</span>
    <span>String</span> name<span>;</span>
    <span>public</span> <span>void</span> <span>eat</span><span>(</span><span>)</span><span>{</span><span>}</span>
<span>}</span>
<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>//匿名子类的对象</span>
	<span>Person</span> p <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>{</span>
        <span>public</span> <span>void</span> <span>eat</span><span>(</span><span>)</span><span>{</span><span>}</span>
    <span>}</span><span>;</span>
    <span>//执行重写的方法</span>
    p<span>.</span><span>eat</span><span>(</span><span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div></li>
<li>
<p>抽象类和接口有哪些共同点和区别</p>
<ul>
<li>相同点：
<ul>
<li>抽象类和接口都不能被实例化</li>
<li>都可以被继承</li>
</ul>
</li>
<li>不同点：
<ul>
<li>抽象类可以有构造器，接口不能声明构造器</li>
<li>抽象类只有单继承，接口可以被多继承</li>
<li>抽象类是两个并列的结构，一个是类体系，一个是接口体系</li>
<li>定义的方式不一样</li>
</ul>
</li>
</ul>
</li>
<li>
<p>如何创建静态成员内部类和非静态成员内部类的对象</p>
<div><pre><code><span>Person<span>.</span>Dog</span> dog <span>=</span> <span>new</span> <span>Person<span>.</span>Dog</span><span>(</span><span>)</span><span>;</span>
<span>Person</span> p <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span>
<span><span>person<span>.</span></span>Bird</span> bird <span>=</span> p<span>.</span><span>new</span> <span>Bird</span>
<span>//person.Bird bird = p.new Person.Bird();//一样的</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>C语言运算符优先级和结合性一览表</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/C%E8%AF%AD%E8%A8%80%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E7%BB%93%E5%90%88%E6%80%A7%E4%B8%80%E8%A7%88%E8%A1%A8/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/C%E8%AF%AD%E8%A8%80%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E7%BB%93%E5%90%88%E6%80%A7%E4%B8%80%E8%A7%88%E8%A1%A8/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">C语言运算符优先级和结合性一览表</source>
      <category>杂物间</category>
      <pubDate>Tue, 16 Mar 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<ul>
<li>参考:
<a href="http://c.biancheng.net/view/161.html" target="_blank" rel="noopener noreferrer">C语言运算符优先级和结合性一览表</a></li>
</ul>
<p><img src="./images/C语言运算符优先级和结合性一览表.assets/table.png" alt="img" /></p>
]]></content:encoded>
    </item>
    <item>
      <title>C语言多文件调用问题</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/C%E8%AF%AD%E8%A8%80%E5%A4%9A%E6%96%87%E4%BB%B6%E8%B0%83%E7%94%A8%E9%97%AE%E9%A2%98/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/C%E8%AF%AD%E8%A8%80%E5%A4%9A%E6%96%87%E4%BB%B6%E8%B0%83%E7%94%A8%E9%97%AE%E9%A2%98/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">C语言多文件调用问题</source>
      <category>杂物间</category>
      <pubDate>Sat, 20 Mar 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>网络上标准答案貌似很杂所以自己尝试按照C语言程序设计P227的例子修改了，原书的是使用不了的！！！下面只是一个示例文件</p>
<div><pre><code><span><span>#</span><span>ifndef</span> <span>__FILE_H__</span></span>
<span><span>#</span><span>define</span> <span>__FILE_H__</span></span>

<span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>
<span><span>#</span><span>include</span> <span>"file2.c"</span></span>
<span><span>#</span><span>include</span> <span>"file3.c"</span></span>
<span><span>#</span><span>include</span> <span>"file4.c"</span></span>
<span>void</span> <span>enter_string</span><span>(</span><span>char</span> str<span>[</span><span>]</span><span>)</span><span>;</span>
<span>void</span> <span>delete_string</span><span>(</span><span>char</span> str<span>[</span><span>]</span><span>,</span> <span>char</span> ch<span>)</span><span>;</span>
<span>void</span> <span>print_string</span><span>(</span><span>char</span> str<span>[</span><span>]</span><span>)</span><span>;</span>

<span><span>#</span><span>endif</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><pre><code><span><span>#</span><span>include</span> <span>"file.h"</span></span>
<span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>
<span>int</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
    <span>extern</span> <span>void</span> <span>enter_string</span><span>(</span><span>char</span> str<span>[</span><span>]</span><span>)</span><span>;</span>
    <span>extern</span> <span>void</span> <span>delete_string</span><span>(</span><span>char</span> str<span>[</span><span>]</span><span>,</span><span>char</span> ch<span>)</span><span>;</span>
    <span>extern</span> <span>void</span> <span>print_string</span><span>(</span><span>char</span> str<span>[</span><span>]</span><span>)</span><span>;</span>
    <span>char</span> c<span>;</span>
    <span>char</span> str<span>[</span><span>80</span><span>]</span><span>;</span>
    <span>enter_string</span><span>(</span>str<span>)</span><span>;</span>
    <span>scanf</span><span>(</span><span>"%c"</span><span>,</span><span>&amp;</span>c<span>)</span><span>;</span>
    <span>delete_string</span><span>(</span>str<span>,</span>c<span>)</span><span>;</span>
    <span>print_string</span><span>(</span>str<span>)</span><span>;</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><div><pre><code><span><span>#</span><span>include</span> <span>"file.h"</span></span>
<span>void</span> <span>enter_string</span><span>(</span><span>char</span> str<span>[</span><span>80</span><span>]</span><span>)</span>
<span>{</span>
    <span>gets</span><span>(</span>str<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span><span>#</span><span>include</span> <span>"file.h"</span></span>
<span>void</span> <span>delete_string</span><span>(</span><span>char</span> str<span>[</span><span>]</span><span>,</span> <span>char</span> ch<span>)</span>
<span>{</span>
    <span>int</span> i<span>,</span>j<span>;</span>
    <span>for</span><span>(</span>i<span>=</span>j<span>=</span><span>0</span><span>;</span>str<span>[</span>i<span>]</span><span>!=</span><span>'\0'</span><span>;</span>i<span>++</span><span>)</span><span>{</span>
        <span>if</span><span>(</span>str<span>[</span>i<span>]</span><span>!=</span>ch<span>)</span>
            str<span>[</span>j<span>++</span><span>]</span><span>=</span>str<span>[</span>i<span>]</span><span>;</span>
    str<span>[</span>j<span>]</span><span>=</span><span>'\0'</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code><span><span>#</span><span>include</span> <span>"file.h"</span></span>
<span>void</span> <span>print_string</span><span>(</span><span>char</span> str<span>[</span><span>]</span><span>)</span>
<span>{</span>
    <span>printf</span><span>(</span><span>"%s\n"</span><span>,</span>str<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h1 id="额外-函数的调用"> 额外 - 函数的调用</h1>
<ul>
<li>当再一个函数的运行期间调用另一个函数时，再运行被调函数之前，系统需要完成三件事
<ol>
<li>将所有的实际参数，返回地址等信息传递给被调函数保存</li>
<li>为被调函数的局部变量（也包括形参）分配存储空间</li>
<li>将控制转移到被调函数的入口</li>
</ol>
</li>
<li>从被调函数返回主调函数之前，系统也要完成三件事
<ol>
<li>保存被调函数的返回结果</li>
<li>释放被调函数所占的存储空间</li>
<li>依照被调函数保存的返回地址将控制转移到调用函数</li>
</ol>
</li>
<li>当有多个函数相互调用时，按照“后调用先返回”的原则，上述函数之间信息传递和控制转移必须借助”栈”来实现，即系统将整个程序运行时所需的数据空间安排在一个中，每当调用一个函数时，就在栈顶分配一个存储区，进行压機操作，每当一个函数退出时，就释放它的存储区，就行出栈操作，当前运行的函数永远都在栈顶位置</li>
<li><strong>A函数调用A函数和A函数调用B函数在计算机看来是没有任何区别的，只不过用我们日常的思维方式理解比较怪异而己！</strong></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>CSS标签透明化</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/CSS_label_transparency/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/CSS_label_transparency/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">CSS标签透明化</source>
      <category>杂物间</category>
      <pubDate>Mon, 24 Feb 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>这里主要是<code>opacity：0.5；</code>和<code>background-color:rgba(255,255,255,0.5);</code>这两种</p>
<h1 id="详细"> 详细</h1>
<p>如果想让一整个div标签透明化，只需要再css样式里面添加<code>opacity：0.5；</code>：</p>
<div><pre><code>&lt;div style=<span>"opacity: 0.5;display: inline-block;"</span>>
	&lt;div style=<span>"background-color: red;width: 100px;height:100px;"</span>>
		我是透明的DIV
	&lt;/div>
&lt;/div>
&lt;div style=<span>"display: inline-block;"</span>>
	&lt;div style=<span>"background-color: red;width: 100px;height:100px;"</span>>
		我是不透明的DIV
	&lt;/div>
&lt;/div>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><img src="./images/css_Label_transparency/1.png" alt="哦豁图片被吃了" /></p>
<hr>
<p>当然也可以将背景颜色透明，注意请与一种方法进行比较，这种方法智慧让背景透明而不是整体<code>background-color:rgba(255,255,255,0.5);</code>：</p>
<div><pre><code>&lt;div style=<span>"display: inline-block;"</span>>
	&lt;div style=<span>"background-color: rgba(255,0,0,0.3);width: 100px;height:100px;"</span>>
		我是透明的background-color
	&lt;/div>
&lt;/div>
&lt;div style=<span>"display: inline-block;"</span>>
	&lt;div style=<span>"background-color: red;width: 100px;height:100px;"</span>>
		我是不透明的background-color
	&lt;/div>
&lt;/div>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><img src="./images/css_Label_transparency/2.png" alt="哦豁图片被吃了" /></p>
<h1 id="写在后面"> 写在后面</h1>
<p>至此，多加练习吧！</p>
]]></content:encoded>
    </item>
    <item>
      <title>gcc的boolean问题</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%85%88free%E5%86%8DNULL/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%85%88free%E5%86%8DNULL/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">gcc的boolean问题</source>
      <category>杂物间</category>
      <pubDate>Mon, 15 Mar 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>因为当指针<code>free</code>后，<code>free</code>函数指向将指针指向的内存空间释放了（内存中存储的值），但并没有将指针指向的值释放，指针仍然指向被释放的内存中，此时指针可以被称为“野指针”</p>
<ul>
<li>为了避免出现问题所以最好先<code>free</code> 了之后，再将NULL赋值给指针，</li>
<li>野指针：“野指针”与空指针不同，“野指针”有指向的内存地址，对野指针操作很容易造成不确定的问题。
<ul>
<li>因为对于程序来说这个地址已经释放掉了，但倘若系统正在使用这个内存时程序同时调用了那就会造成不确定的问题了。</li>
<li>所以为了保险起见，最后建议将NULL赋值给野指针</li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>GET获取页面内容</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/GET_page_content/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/GET_page_content/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">GET获取页面内容</source>
      <category>杂物间</category>
      <pubDate>Mon, 03 Feb 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="动手"> 动手</h1>
<p>这里使用requests模块进行get网页内容，先试试百度</p>
<div><pre><code><span>import</span> requests
<span># 发送get请求，获取到一个Response对象，如果打印html这个变量则为当前的状态码</span>
html <span>=</span> requests<span>.</span>get<span>(</span><span>'https://www.baidu.com'</span><span>)</span>
<span># 显示bytes型页面的源代码</span>
html_bytes <span>=</span> html<span>.</span>content
<span># 获取到的代码为流btyes，要转为字符串则要将获取到的代码进行decode解码</span>
html_str <span>=</span> html_bytes<span>.</span>decode<span>(</span><span>)</span>
<span>print</span><span>(</span>html_str<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>这里将返回类似这样的网页源代码
<img src="https://user-gold-cdn.xitu.io/2020/2/3/170070576184de3e?w=574&h=405&f=png&s=27385" alt="哦豁图片被吃了" /></p>
<h3 id="将api页面的json转为dict"> 将API页面的json转为dict</h3>
<p>结合上面的操作，下面将对https://hitokoto.cn/ 的 <a href="https://v1.hitokoto.cn/" target="_blank" rel="noopener noreferrer">API</a> 进行操作</p>
<div><pre><code><span>import</span> requests<span>,</span> json
html <span>=</span> requests<span>.</span>get<span>(</span><span>'https://v1.hitokoto.cn/'</span><span>)</span><span>.</span>content<span>.</span>decode<span>(</span><span>)</span>
<span># 将页面html转换为字典dict</span>
html_dict <span>=</span> json<span>.</span>loads<span>(</span>html<span>)</span>
<span># 将其格式化输出</span>
show_txt <span>=</span> <span>'%s\n--%s'</span><span>%</span><span>(</span>html_dict<span>[</span><span>'hitokoto'</span><span>]</span><span>,</span>html_dict<span>[</span><span>'from'</span><span>]</span><span>)</span>
<span>print</span><span>(</span>show_txt<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h1 id="写在后面"> 写在后面</h1>
<p>多结合其他的工具一起使用，将会受益匪浅！</p>
]]></content:encoded>
      <enclosure url="https://user-gold-cdn.xitu.io/2020/2/3/170070576184de3e?w=574&h=405&f=png&s=27385" type="image/"/>
    </item>
    <item>
      <title>批量新建文件夹</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/batch_create_folder/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/batch_create_folder/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">批量新建文件夹</source>
      <category>杂物间</category>
      <pubDate>Wed, 04 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h3 id="按指定的内容添加"> 按指定的内容添加</h3>
<div><pre><code><span>import</span> os
os<span>.</span>chdir<span>(</span><span>r'D:\文件夹1'</span><span>)</span>	<span>#更改当前工作目录为`D:\文件夹1`</span>
font <span>=</span> <span>[</span><span>'t1'</span><span>,</span><span>'t2'</span><span>,</span><span>'tc'</span><span>,</span><span>'t4'</span><span>,</span><span>'ta'</span><span>,</span><span>'tt'</span><span>]</span>

<span>for</span> i <span>in</span> font<span>:</span>
	os<span>.</span>makedirs<span>(</span>i<span>)</span>   <span># 如果路径不存在则新建文件夹</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="按顺序添加"> 按顺序添加</h3>
<div><pre><code><span>import</span> os
os<span>.</span>chdir<span>(</span><span>r'D:\文件夹1'</span><span>)</span>	<span>#更改当前工作目录为`D:\文件夹1`</span>
<span>for</span> i <span>in</span> <span>range</span><span>(</span><span>10</span><span>)</span><span>:</span>
	os<span>.</span>makedirs<span>(</span>i<span>)</span>   <span># 如果路径不存在则新建文件夹</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>python使用命令行</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/python_command/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/python_command/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">python使用命令行</source>
      <category>杂物间</category>
      <pubDate>Tue, 24 Dec 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="前言"> 前言</h2>
<p>虽然在使用python的时候对命令行的使用很少，但也不可避免的会有需要的场景</p>
<h3 id="os-system"> os.system()</h3>
<ul>
<li>只有这个方法是边执行边输出，其他方法是最后一次性输出</li>
<li>可以返回运行shell命令状态，同时会在终端输出运行结果</li>
</ul>
<h3 id="os-popen"> os.popen()</h3>
<ul>
<li>需要等待命令执行完毕后，一次性输出</li>
<li>可以对返回运行结果进行操作</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>gcc的boolean问题</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/gcc%E7%9A%84boolean%E9%97%AE%E9%A2%98/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/gcc%E7%9A%84boolean%E9%97%AE%E9%A2%98/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">gcc的boolean问题</source>
      <category>杂物间</category>
      <pubDate>Tue, 16 Mar 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>在学习数据结构过程中，使用vscode+gcc方案实现c语言运行的时候发现使用bool类型的时候会报错，即使<code>#include &lt;stdbool.h&gt;</code> vscode貌似运行没问题，但是也会将代码识别为错误，于网上查找后发现是gcc自身的问题，一般的解决办法是添加#define</p>
<p>所以这里列出两种解决方案</p>
<ol>
<li>
<p>使用 <code>#include &lt;stdiobool.h</code> ，即使vscode报错也无视，就是不太好看</p>
</li>
<li>
<p>在 main() 前提前定义 bool</p>
<div><pre><code><span><span>#</span><span>define</span> <span>bool</span> <span><span>char</span></span></span>
<span><span>#</span><span>define</span> <span>true</span> <span><span>1</span></span></span>
<span><span>#</span><span>define</span> <span>false</span> <span><span>0</span></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>clone仓库到本地</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/clone_repository/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/clone_repository/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">clone仓库到本地</source>
      <category>杂物间</category>
      <pubDate>Fri, 13 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="前言"> 前言</h2>
<p>你需要准备这些：</p>
<ul>
<li>一个下载的目标</li>
<li>充足的空间</li>
</ul>
<h2 id="过程"> 过程</h2>
<h3 id="_1-在本地创建一个文件夹"> 1 在本地创建一个文件夹</h3>
<p>在本地中创建一个文件夹，用他来装我们下载下来的仓库，如<code>demo</code><br>首先先进入Git的命令行</p>
<p><img src="./images/克隆git仓库到本地/1.png" alt="图片被吃掉了" />
然后输入<code>cd</code>命令切换到demo文件夹的目录下，如图：</p>
<div><pre><code>cd /c/Users/Administrator/Desktop/demo
</code></pre>
<div><span>1</span><br></div></div><p><img src="./images/克隆git仓库到本地/2.png" alt="图片被吃掉了" /></p>
<h3 id="_2-将本地仓库初始化"> 2 将本地仓库初始化</h3>
<p>进入路径之后需要将这个仓库初始化，输入命令<code>git init</code> ，如图：</p>
<p><img src="./images/克隆git仓库到本地/3.png" alt="图片被吃掉了" /></p>
<h3 id="_3-将github的项目下载"> 3 将github的项目下载</h3>
<p>使用<code>git clone https://github.com/**</code>即可将github上的项目克隆下载，如图</p>
<p><img src="./images/克隆git仓库到本地/4.png" alt="图片被吃掉了" /></p>
<h3 id="_4-成功"> 4 成功！</h3>
<p>直到git bash上显示100%了，那就说明你已经成功克隆下来了，打开你刚刚输入的路径就可以看到你想要的文件啦！</p>
<p><img src="./images/克隆git仓库到本地/5.png" alt="图片被吃掉了" /></p>
<h2 id="更多"> 更多</h2>
<p>更多关于git的内容可以看这里：<a href="https://www.bootcss.com/p/git-guide/" target="_blank" rel="noopener noreferrer">传送门</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>python模块下载到本地安装</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/python_module_local_setup/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/python_module_local_setup/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">python模块下载到本地安装</source>
      <category>杂物间</category>
      <pubDate>Tue, 24 Dec 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="动手"> 动手</h1>
<ul>
<li>使用方法：<code>pip download 库名</code></li>
<li>比如：<code>pip download scrapy</code></li>
</ul>
<h1 id="写在后面"> 写在后面</h1>
<p>如果你下载下来的文件是*.whl的话使用<code>pip install xxx.whl</code>安装
如果是*.tar的话使用<code>python setup.py install</code></p>
]]></content:encoded>
    </item>
    <item>
      <title>python判断本地文件</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/python_judge_file_exist/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/python_judge_file_exist/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">python判断本地文件</source>
      <category>杂物间</category>
      <pubDate>Tue, 12 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="快速"> 快速</h1>
<div><pre><code><span>import</span> os
<span># 假设当前目录下有个叫做'box'的文件夹</span>
os<span>.</span>path<span>.</span>exists<span>(</span><span>'box'</span><span>)</span>
<span># 如果本地文件存在则返回True否则False</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="扩展"> 扩展</h3>
<p>那既然知道了基本的原理你就可以利用这一点做个判断文件是否存在，不存在则创建文件夹的过程</p>
<div><pre><code><span>import</span> os
<span>if</span> <span>not</span> os<span>.</span>path<span>.</span>exists<span>(</span><span>'box'</span><span>)</span><span>:</span>
	<span>print</span><span>(</span><span>'文件夹不存在，正在为你创建中...'</span><span>)</span>
	os<span>.</span>makedirs<span>(</span><span>'box'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>python复制粘贴剪贴板</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/python_use_clipboard/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/python_use_clipboard/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">python复制粘贴剪贴板</source>
      <category>杂物间</category>
      <pubDate>Mon, 03 Feb 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="动手"> 动手</h1>
<div><pre><code><span>import</span> pyperclip
<span># 复制文字到系统剪贴板中</span>
pyperclip<span>.</span>copy<span>(</span><span>'我是文字'</span><span>)</span>
<span># 复制系统剪贴板的文字到变量中</span>
txt <span>=</span> pyperclip<span>.</span>paste<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h1 id="写在后面"> 写在后面</h1>
<p>记得copy()和paste()别搞混咯！</p>
]]></content:encoded>
    </item>
    <item>
      <title>python命令行参数</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/python_command_parameters/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/python_command_parameters/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">python命令行参数</source>
      <category>杂物间</category>
      <pubDate>Fri, 05 Jun 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="前言"> 前言</h1>
<p>可以用<code>win+R</code>然后输入文字快速打开程序真的方便，<a href="https://www.runoob.com/python/python-command-line-arguments.html" target="_blank" rel="noopener noreferrer">参考</a></p>
<h1 id="快速"> 快速</h1>
<p>记得配置好系统环境再食用</p>
<div><pre><code><span># test.py</span>
<span># 带参数输入“test.py hello world”</span>
<span>import</span> sys
<span>print</span><span>(</span><span>'参数个数为：'</span><span>,</span> <span>len</span><span>(</span>sys<span>.</span>argv<span>)</span><span>,</span> <span>'个'</span><span>)</span>
<span>print</span><span>(</span><span><span>f'参数列表</span><span><span>{</span>sys<span>.</span>argv<span>}</span></span><span>'</span></span><span>)</span>
<span>print</span><span>(</span><span><span>f'参数1为</span><span><span>{</span>sys<span>.</span>argv<span>[</span><span>1</span><span>]</span><span>}</span></span><span>'</span></span><span>)</span>
<span>input</span><span>(</span><span>'回车以结束'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>输出结果：</p>
<div><pre><code>参数个数为： 3 个
参数列表[&#39;test.py&#39;, &#39;hello&#39;, &#39;world&#39;]
参数1为hello
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h1 id="说明"> 说明</h1>
<h2 id="win键"> win键</h2>
<p>估计会有小朋友问win键是什么...这里请出百度 <a href="https://baike.baidu.com/item/Windows%E9%94%AE/7124478?fromtitle=Win%E9%94%AE&amp;fromid=3393055&amp;fr=aladdin" target="_blank" rel="noopener noreferrer">点我跳转</a></p>
<h2 id="配置系统环境变量"> 配置系统环境变量</h2>
<ul>
<li>打开<code>我的电脑\高级系统设置\环境变量</code>，在系统变量中找到<code>Path</code>的变量，双击打开选择新建，</li>
<li>假设我的<code>test.py</code>文件在<code>E:\helloworld</code>这个文件夹下，则在新建的空白处输入<code>E:\helloworld</code></li>
<li>使用快捷键<code>win+R</code>打开运行输入<code>test.py hello world</code>即可（若失败请重启一次电脑）</li>
<li>可能你会觉得打后缀名太麻烦了？可以试试右键<code>创建快捷方式</code>，将它改名为<code>test</code>，此时你只需要在运行中输入<code>test hello world</code>即可！</li>
</ul>
<h1 id="后言"> 后言</h1>
<p>炎热的夏季，蝉鸣的夜晚；迫切的焦虑，无奈的等待。</p>
]]></content:encoded>
    </item>
    <item>
      <title>socket获取本地ip</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/socket_get_ip/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/socket_get_ip/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">socket获取本地ip</source>
      <category>杂物间</category>
      <pubDate>Mon, 16 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="快速"> 快速</h1>
<div><pre><code><span>import</span> socket
<span># 获取当前主机的所有IP地址</span>
addrs <span>=</span> socket<span>.</span>getaddrinfo<span>(</span>socket<span>.</span>gethostname<span>(</span><span>)</span><span>,</span> <span>None</span><span>)</span>
<span># 获取当前IPV4地址</span>
<span>for</span> item <span>in</span> addrs<span>:</span>
	<span>if</span> <span>':'</span> <span>not</span> <span>in</span> item<span>[</span><span>4</span><span>]</span><span>[</span><span>0</span><span>]</span><span>:</span>
		<span>print</span><span>(</span><span>'ip.addr:'</span> <span>+</span> item<span>[</span><span>4</span><span>]</span><span>[</span><span>0</span><span>]</span><span>)</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>torrent不能下载的解决方法</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/torrent_cannot_download/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/torrent_cannot_download/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">torrent不能下载的解决方法</source>
      <category>杂物间</category>
      <pubDate>Thu, 05 Mar 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="快速解决"> 快速解决</h1>
<p>不能下载的解决方法:
主要是因为tracker太少或者被屏蔽了。</p>
<p>解决方法很简单，补充tracker!
可以去github上更新一下tracker。
比如<a href="https://github.com/ngosang/trackerslist" target="_blank" rel="noopener noreferrer">https://github.com/ngosang/trackerslist</a>
这里的tracker每日会更新</p>
<p>点击打开网页里提供的trackers_all.txt</p>
]]></content:encoded>
    </item>
    <item>
      <title>python文件操作</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/python_file/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/python_file/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">python文件操作</source>
      <category>杂物间</category>
      <pubDate>Wed, 04 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="使用python读写文本文件"> 使用python读写文本文件</h1>
<ul>
<li>第一种：</li>
</ul>
<div><pre><code>a <span>=</span> <span>open</span><span>(</span><span>r'文件路径'</span><span>,</span>encoding<span>=</span><span>'utf-8'</span><span>)</span>
<span>.</span><span>.</span><span>.</span>读写文件<span>.</span><span>.</span><span>.</span>
a<span>.</span>close<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>切记第一种一定要记得关闭文件<code>*.close()</code>，不然会出现文件被占用或文件未保存等等的错误！！</p>
<ul>
<li>第二种：</li>
</ul>
<div><pre><code><span>with</span> <span>open</span><span>(</span><span>r'文件路径'</span><span>,</span>encoding<span>=</span><span>'utf-8'</span><span>)</span> <span>as</span> b<span>:</span>
	<span>.</span><span>.</span><span>.</span>读写文件<span>.</span><span>.</span><span>.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这是第二种写法，他会执行完缩进到里面的读写文件操作之后就会自动将文件保存并关闭，也就是帮你省去了<code>*.close()</code>这一步，所以最好使用<strong>第二种方式来对文件操作</strong></p>
<h3 id="读取文件"> 读取文件</h3>
<p>打开文件的时候记得文件是在当前路径的，读取文件的时候会使用 <code>'r'</code> (read - 读)参数表示读取文件，但是如果你不写那默认就是使用度的方式进行文件操作</p>
<div><pre><code><span>with</span> <span>open</span><span>(</span><span>r'文件路径'</span><span>,</span><span>'r'</span><span>,</span>encoding<span>=</span><span>'utf-8'</span><span>)</span> <span>as</span> b<span>:</span>
	<span>.</span><span>.</span><span>.</span>读写文件<span>.</span><span>.</span><span>.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="编码"> 编码</h3>
<p>后面的encoding是为了防止乱码的出现，建议在打开文件的使用这种方法来避免乱码的出现，<code>utf-8</code>是最常用的一种编码，除此之外还有<code>GB2312</code>、<code>GBK</code>、<code>ascii</code>等等...</p>
]]></content:encoded>
    </item>
    <item>
      <title>python打开文件&amp;程序</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/python_open_file_program/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/python_open_file_program/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">python打开文件&amp;程序</source>
      <category>杂物间</category>
      <pubDate>Tue, 12 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="动手"> 动手</h1>
<p>这里就简单示范下吧，差不多的是用了类似cmd的start命令</p>
<div><pre><code><span>import</span> subprocess
<span># 使用notepad打开txt</span>
subprocess<span>.</span>Popen<span>(</span><span>[</span><span>'C:\\Windows\\notepad.exe'</span><span>,</span> <span>'C:\\hello.txt'</span><span>]</span><span>)</span>
<span># 或者直接打开</span>
subprocess<span>.</span>Popen<span>(</span><span>[</span><span>'start'</span><span>,</span><span>'C:\\hello.txt'</span><span>]</span><span>,</span>shell<span>=</span><span>True</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h1 id="后续"> 后续</h1>
<p>除了上面所描述的方法，你也可以结合上一篇文章结合使用</p>
]]></content:encoded>
    </item>
    <item>
      <title>windows10通知</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/win10_notice/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/win10_notice/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">windows10通知</source>
      <category>杂物间</category>
      <pubDate>Mon, 03 Feb 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="前言"> 前言</h1>
<p>利用python可以发送一条通知，如果只是单纯的通知比起弹窗会好很多！</p>
<h1 id="动手"> 动手</h1>
<div><pre><code><span>from</span> win10toast <span>import</span> ToastNotifier <span>as</span> Tn
Tn <span>=</span> Tn<span>(</span><span>)</span>
<span>while</span> Tn<span>.</span>notification_active<span>(</span><span>)</span><span>:</span> sleep<span>(</span><span>0.5</span><span>)</span>
<span># show_toast()中第一个参数为标题，第二个参数为正文，第三个参数为弹窗显示的时间</span>
Tn<span>.</span>show_toast<span>(</span><span>'我是标题'</span><span>,</span> <span>'我是正文'</span><span>,</span> duration<span>=</span><span>2</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h1 id="写在后面"> 写在后面</h1>
<p>弹窗可以使用TK，但如果只是通知还是建议使用这个</p>
]]></content:encoded>
    </item>
    <item>
      <title>Windows10图标修复</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/win10_icon_repair/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/win10_icon_repair/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">Windows10图标修复</source>
      <category>杂物间</category>
      <pubDate>Mon, 24 Feb 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="前言"> 前言</h1>
<p>有的时候软件开着开着图标就不见了虽然不影响打开但是看着不舒服...在 Windows 10系统中，为了加速图标的显示，当第一次对图标进行显示时，系统会对文件或程序的图标进行缓存。</p>
<h1 id="动手"> 动手</h1>
<p>所以原理就是将这个缓存文件删掉再重启刷新一次桌面即可刷新缓存文件，所以首先我们将打开缓存文件的文件夹</p>
<ol>
<li>按快捷键<code>win+r</code>打开运行</li>
<li>然后输入<code>%localappdata%</code>回车
<img src="./images/windows10_fix_icon/1.png" alt="哦豁图片被吃掉了" /></li>
</ol>
<p>由于图标缓存文件是隐藏文件，我们需要在资源管理器中将设置改为“显示所有文件”，如果打开了就跳过这一步</p>
<ol>
<li>
<p>随便打开一个文件夹</p>
</li>
<li>
<p>然后点击查看隐藏的项目
<img src="./images/windows10_fix_icon/2.png" alt="哦豁图片被吃掉了" /></p>
</li>
<li>
<p>接着上一步打开的文件夹中找到一个叫<code>Iconcache.db</code>的文件，将其删除（要滑一下鼠标可能在最下面）
<img src="./images/windows10_fix_icon/3.png" alt="哦豁图片被吃掉了" /></p>
</li>
<li>
<p>之后打开<code>任务管理器</code>，在任务管理器中找到<code>Windows资源管理器</code></p>
</li>
<li>
<p>右击鼠标，选择<code>重新启动</code>即可重建图标缓存
<img src="./images/windows10_fix_icon/4.png" alt="哦豁图片被吃掉了" /></p>
</li>
</ol>
<h1 id="写在后面"> 写在后面</h1>
<p>祭一根萝卜希望win11不会有这些bug….</p>
]]></content:encoded>
    </item>
    <item>
      <title>Windows中杀掉某个占用端口的进程</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/windows_pid_kill/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/windows_pid_kill/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">Windows中杀掉某个占用端口的进程</source>
      <category>杂物间</category>
      <pubDate>Tue, 24 Dec 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="动手"> 动手</h1>
<p>这里我们以关闭4000这个端口为例</p>
<p>1.打开cmd</p>
<p>使用快捷键<code>win+R</code>然后输入<code>cmd</code></p>
<p><img src="./images/windows_kill_port/1.png" alt="win端口_1" /></p>
<p>2.查看PID</p>
<p>首先你需要先扫描指定端口的PID，在cmd里面输入<code>netstat -aon|findstr &quot;4000&quot;</code></p>
<p><img src="./images/windows_kill_port/2.png" alt="win端口_1" /></p>
<p>3.强行关闭</p>
<p>可以看到PID为13556，此时把13556这个PID的进程强行关闭即可，在cmd的窗口中输入<code>taskkill /f /pid 13556</code></p>
<p><img src="./images/windows_kill_port/3.png" alt="win端口_1" /></p>
<h1 id="写在后面"> 写在后面</h1>
<p>正所谓强行关闭，如果没有保存当前状况再去强行关闭必然会出事，记得看清楚进程再关闭哦！你也可以在任务管理器中查看PID找到对应的进程进行关闭</p>
]]></content:encoded>
    </item>
    <item>
      <title>关于C语言的声明</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/%E5%85%B3%E4%BA%8EC%E8%AF%AD%E8%A8%80%E5%A3%B0%E6%98%8E/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/%E5%85%B3%E4%BA%8EC%E8%AF%AD%E8%A8%80%E5%A3%B0%E6%98%8E/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">关于C语言的声明</source>
      <category>杂物间</category>
      <pubDate>Sat, 20 Mar 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="关于c语言-ifndef-define-endif-ifdef"> 关于C语言 #ifndef #define #endif #ifdef</h1>
<ul>
<li>
<p>参考：<a href="https://www.cnblogs.com/challenger-vip/p/3386819.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/challenger-vip/p/3386819.html</a></p>
</li>
<li>
<p>关于 <code>#ifndef</code> <code>#define</code> <code>#endif</code> <code>#ifdef</code></p>
</li>
<li>
<p>诠释</p>
<ul>
<li>
<p>一般这是用于多文件编译避免大量声明冲突</p>
</li>
<li>
<p>一般格式</p>
<div><pre><code>#ifndef <span>&lt;</span>标识<span>></span> 
#define <span>&lt;</span>标识<span>></span> 

········
········

#endif
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>
<li>
<p><code>&lt;标识&gt;</code> 在理论上来说是自由命名的，作用是标识不同的文件，标准的标识是头文件名的全大写, <code>.</code>替换为 <code>_</code></p>
<div><pre><code><span>/*若文件名为study,h*/</span>
#ifndef _STUDY_H_ 
#define _STUDY_H_

········
········

#endif
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>ifndef</code> &amp; <code>#endif</code></p>
<ul>
<li>
<p>他是 if not define 的简写，是宏地呢一的一种，确切的说是预处理功能三种（宏定义、文件包含、条件编译）中的一种条件编译</p>
</li>
<li>
<p>在c语言中，对同一个变量或者函数进行多次声明是不会报错的。所以如果h文件里只是进行了声明工作，即使不使用# ifndef宏定义，多个c文件包含同一个h文件也不会报错。</p>
</li>
<li>
<p>但是在c++语言中，#ifdef的作用域只是在单个文件中。所以如果h文件里定义了全局变量，即使采用#ifdef宏定义，多个c文件包含同一个h文件还是会出现全局变量重定义的错误。</p>
</li>
<li>
<p>使用#ifndef可以避免下面这种错误：如果在h文件中定义了全局变量，一个c文件包含同一个h文件多次，如果不加#ifndef宏定义，会出现变量重复定义的错误；如果加了#ifndef，则不会出现这种错误。</p>
</li>
<li>
<p>#ifndef 和 #endif 要一起使用，如果丢失#endif，可能会报错。</p>
</li>
<li>
<p>示例</p>
<div><pre><code>#ifndef x            <span>//先测试x是否被宏定义过</span>
#define x
   程序段<span>1</span>blabla<span>~</span>    <span>//如果x没有被宏定义过，定义x，并编译程序段 1</span>
#endif   
　　程序段<span>2</span>blabla<span>~</span>　　 <span>//如果x已经定义过了则编译程序段2的语句，“忽视”程序段 1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
</ul>
</li>
<li>
<p><code>#ifdef</code></p>
<ul>
<li>
<p>简写：if define</p>
</li>
<li>
<p>示例</p>
<div><pre><code>#ifndef  x 
#define x   <span>//如果宏定义了x，则执行程序1.</span>
    程序段 <span>1</span>
#<span>else</span>       <span>//否则执行陈旭2</span>
    程序段 <span>2</span>
#endif
<span>/*****************
你也可以这样
它的作用是 当“表达式”值为真时。编译程序段1。
否则则编译程序段2。
当没有程序段2时，直接是#if---#endif
*****************/</span>
#<span>if</span> 表达式
    程序段 <span>1</span>
#<span>else</span>
    程序段 <span>2</span>
#endif
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div></li>
</ul>
</li>
<li>
<p><code>#define</code></p>
<ul>
<li>在C或C++语言源程序中允许用一个标识符来表示一个字符串，称为“宏”。“define”为宏定义命令。</li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>python安装模块失败</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/python_setup_module_failed/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/python_setup_module_failed/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">python安装模块失败</source>
      <category>杂物间</category>
      <pubDate>Tue, 24 Dec 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="动手"> 动手</h1>
<p>首先绝大部分是可能因为网速的问题，或者超时了所以我们使用国内的镜像源就好啦！</p>
<ul>
<li>使用方法：<code>pip install -i 镜像源网址 库名</code></li>
<li>比如：<code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple scrapy</code></li>
<li>其他国内源
<ul>
<li>清华：https://pypi.tuna.tsinghua.edu.cn/simple</li>
<li>阿里云：http://mirrors.aliyun.com/pypi/simple/</li>
<li>中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/</li>
<li>华中理工大学：http://pypi.hustunique.com/</li>
<li>山东理工大学：http://pypi.sdutlinux.org/</li>
<li>豆瓣：http://pypi.douban.com/simple/</li>
</ul>
</li>
</ul>
<h1 id="写在后面"> 写在后面</h1>
<p>其实有的时候安装失败也有其他的原因。这里大概罗列下</p>
<ol>
<li>系统问题，有的时候win和linux的包是不兼容的</li>
<li>pip版本问题，或许是pip版本不行？试试更新下你的pip<code>python -m pip install --upgrade pip</code></li>
<li>内存问题，或许有可能是内存不够了清理下电脑试试？</li>
<li>环境问题，有可能是你的环境配置出了问题，卸载掉装一个新的环境试试看？</li>
<li>还是不行？百度吧..</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>二/八/十/十六进制之间的转换</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">二/八/十/十六进制之间的转换</source>
      <category>杂物间</category>
      <pubDate>Wed, 13 Jan 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>二进制-八进制-十进制-十六进制</p>
<h1 id="二进制转十进制"> 二进制转十进制</h1>
<div><pre><code>- 使用加减法，对一个二进制的数进行换算加减
- 二进制的 `11111111` 其实对应着十进制的 `128 64 32 16 8 4 2 1 0` 只需要按这个顺序依次加减去即可
- `11000001` =128+64+1即十进制193
</code></pre>
</div><h1 id="十进制转二进制"> 十进制转二进制</h1>
<div><pre><code>- 使用加减法，对一个十进制的数进行递减
    - 二进制的 `11111111` 其实对应着十进制的 `128 64 32 16 8 4 2 1 0` 只需要按这个顺序依次加减去即可
    - 129=128+1即二进制 `10000001`
</code></pre>
</div><h1 id="二进制转八进制"> 二进制转八进制</h1>
<div><pre><code>- 从右往左，3个一组，不足3个补0，使用加减法，对一个二进制的数换算进行加减，然后将每组的数连接组合在一起
- 三个一组的二进制的 `111` 其实对应着八进制的 `4 2 1` 只需要按照这个顺序依次加减法即可
- `10111`
    - `010` = $0*2^2+1*2^1+0*2^0$ = 2
    - `111` = $1*2^2+1*2^1+1*2^0$ = 7
    - 将两连接组组合在一起即 `10111` =27
- 【方法2】计算方法
    - 从右往左，3个一组，不足3个补0，将每组里的数的位置当作次方（从0开始），让每个数与2的次方相乘，然后将每个组得到的数将其合在一起即可（建议看示例）注意合起来的数，而不是相加
    - `1011`
        - `001` = $0*2^2+0*2^1+1*2^0$=0+0+1=1
        - `011` = $0*2^2+1*2^1+1*2^0$=0+2+1=3
        - 将两连接组组合在一起=13，即 `1011` =13
</code></pre>
</div><h1 id="八进制转二进制"> 八进制转二进制</h1>
<div><pre><code>- 先将八进制拆分为每个数字，然后使用加减法，对八进制的数进行递减，然后连接组合起来
- 三个一组的二进制的 `111` 其实对应着八进制的 `4 2 1` 只需要按照这个顺序依次加减法即可
- 27
    - 2 = $0*2^2+1*2^1+0*2^0$ = `010`
    - 7 =4+2+1 = $1*2^2+1*2^1+1*2^0$ = `111`
    - 将两连接组组合在一起即27= `10111`
</code></pre>
</div><h1 id="二进制转十六进制"> 二进制转十六进制</h1>
<div><pre><code>- 从右往左，4个一组，不足4个补0，使用加减法，对一个二进制的数换算进行加减，然后将每组的数连接组合在一起
- 四个一组的二进制的 `1111` 其实对应着十六进制的 `8 4 2 1` 只需要按照这个顺序依次加减法即可
- 9F
    - 9 = 8+1 = $1*2^3+0*2^2+0*2^1+1*2^0$ = `1001`
    - F = 8+4+2+1 = $1*2^3+1*2^2+1*2^1+1*2^0$ = `1111`
    - 将两连接组组合在一起即 9F= `1001 1111`
</code></pre>
</div><h1 id="十六进制转二进制"> 十六进制转二进制</h1>
<div><pre><code>- 先将十六进制拆分为每个数字，然后使用加减法，对十六进制的数进行递减，然后连接组合起来
- 四个一组的二进制的 `1111` 其实对应着十六进制的 `8 4 2 1` 只需要按照这个顺序依次加减法即可
- `1001 1111`
    - `1001` = 8+1 = $1*2^3+0*2^2+0*2^1+1*2^0$ = 9
    - `1111` = 8+4+2+1 = $1*2^3+1*2^2+1*2^1+1*2^0$ =F
    - 将两连接组组合在一起即 `1001 1111` = 9F
</code></pre>
</div><h1 id="二进制、八进制、十六进制在赋值时的表示"> 二进制、八进制、十六进制在赋值时的表示</h1>
<div><pre><code>```c
#include &lt;stdio.h&gt;
int main()
{
    short a = 0b1010110;  //二进制数字
    int b = 02713;  //八进制数字
    long c = 0X1DAB83;  //十六进制数字
   
    printf(&quot;a=%ho, b=%o, c=%lo\n&quot;, a, b, c);  //以八进制形似输出
    printf(&quot;a=%hd, b=%d, c=%ld\n&quot;, a, b, c);  //以十进制形式输出
    printf(&quot;a=%hx, b=%x, c=%lx\n&quot;, a, b, c);  //以十六进制形式输出（字母小写）
    printf(&quot;a=%hX, b=%X, c=%lX\n&quot;, a, b, c);  //以十六进制形式输出（字母大写）
    return 0;
}
```</code></pre>
</div>]]></content:encoded>
    </item>
    <item>
      <title>枚举wifi密码</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/%E6%9E%9A%E4%B8%BEwifi%E5%AF%86%E7%A0%81/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/%E6%9E%9A%E4%B8%BEwifi%E5%AF%86%E7%A0%81/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">枚举wifi密码</source>
      <category>杂物间</category>
      <pubDate>Mon, 16 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="前言"> 前言</h2>
<p>首先你得需要安装好VMware，其次你需要安装好kali，还需要一个USB网卡(●'◡'●)，故名思意，枚举就是一个一个从字典中暴力破解，这全靠你字典里有啥了，如果对方把密码设置的非常奇特，那你也莫得办法这里就不讲安装的过程了，让我们直入话题！！</p>
<h2 id="思路"> 思路</h2>
<ol>
<li>
<p>基础建立</p>
</li>
<li>
<p><code>ifconfig -a</code>
查看无线网卡是否安装成功，如果成功了你会看到下面出现wlan0的出现
<img src="./images/枚举wifi密码/01.png" alt="pic" /></p>
</li>
<li>
<p><code>airmon-ng kill</code>
杀死干扰无线网卡监听热点的信号
<img src="./images/枚举wifi密码/02.png" alt="pic" /></p>
</li>
<li>
<p><code>airmon-ng start wlan0</code>
这里的wlan0默认是无线网卡的名称，此操作是载入自己的网卡名
<img src="./images/枚举wifi密码/03.png" alt="pic" /></p>
</li>
<li>
<p><code>ifconfig -a</code>
结合上面的操作，这里是激活无线网卡，此时无线网卡的名称将会变为wlan0mon，与之前的wlan0不同
<img src="./images/枚举wifi密码/04.png" alt="pic" /></p>
</li>
<li>
<p>监听</p>
<ol>
<li><code>airodump-ng wlan0mon</code>
开始监听走位wifi热i但，并显示给个热点的信息（ctrl+c停止监听），这里ESSID为wifi的名字，CH为频道，BSSID为wifi的MAC地址，下面的STATION为连接设备的MAC地址
这里需要用到BSSID
<img src="./images/枚举wifi密码/05.png" alt="pic" /></li>
</ol>
</li>
<li>
<p>攻击</p>
<ol>
<li>
<p><code>airodump-ng -c 频道(CH) --bssid 热点的MAC地址 -w /root/桌面 网卡名(默认wlan0mon)</code>
这里是抓取制定热点的包(指定监听)，当建立一个终端去攻击连接wifi的设备掉线之后，将抓取的TCP包存储在<code>/root/桌面</code>这个路径
<img src="./images/枚举wifi密码/06.png" alt="pic" /></p>
</li>
<li>
<p>新建一个终端 <code>airepaly-ng -0 0 -c 2.1中STATION设备的MAC地址 -a 热点的MAC地址 网卡名(默认wlan0mon)</code>
这里用洪水攻击连接WIFI的设备，-0 0为无限，-0 5则攻击5次
攻击原理：通过洪水攻击让连接的设备掉线，设备掉线则会再次自动连接，自动连接过程中会进行三次握手，会发送tcp包（里面包含加密的密码数据），kali则伪装成wifi热点去窃取该数据包。当窃取到之后就可以用字典暴力破解加密的wifi密码了！这里你或许会问为什么不直接从数据包里拿呢？因为数据包里的密码哈希加密过了，所以不能使用
好了，ctrl+c停止泛洪攻击，我们回到前一个抓包的终端，你能看到抓到的TCP包
<img src="./images/枚举wifi密码/07.png" alt="pic" /></p>
</li>
</ol>
</li>
<li>
<p>枚举暴力破解</p>
<ol>
<li>
<p><code>gzip -d /usr/share/wordlists/rockyou.txt.gz</code>
kali有提供自带的字典，你可以通过gzip命令解压出来</p>
</li>
<li>
<p><code>aircrack-ng -w 字典的路径 抓取的TCP包</code>
如果是上面的例子，那就是<code>aircrack-ng -w /usr/share/wordlists/rockyou.txt /root/桌面-0.1.cap</code>
过一会你就能得到密码了！
<img src="./images/枚举wifi密码/07.png" alt="pic" /></p>
</li>
</ol>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>Windows中杀掉某个占用端口的进程</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/windows_server2012_setup/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/windows_server2012_setup/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">Windows中杀掉某个占用端口的进程</source>
      <category>杂物间</category>
      <pubDate>Fri, 06 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="前言"> 前言</h1>
<ul>
<li>首先你需要有一个server2012的ISO文件，可以装这里下载</li>
<li>然后你需要有安装虚拟机软件，推荐内存8G以上，100G的硬盘</li>
</ul>
<h1 id="基础"> 基础</h1>
<h2 id="iso文件下载"> ISO文件下载</h2>
<p>先去https://msdn.itellyou.cn/中下载ISO文件：
操作系统&gt;windows server 2012 R2 with update&gt;选择第一个下载即可
当然如果你懒，你也可以复制文件到迅雷下载</p>
<div><pre><code>ed2k://|file|cn_windows_server_2012_r2_vl_with_update_x64_dvd_6052729.iso|5545527296|BD499EBCABF406AB82293DD8A5803493|/
</code></pre>
<div><span>1</span><br></div></div><h2 id="虚拟机下载"> 虚拟机下载</h2>
<p>虚拟机目前大部分分为两种：vmware workstation(收费)和virtualbox(开源免费)
，而且vmware会好用一点，所以本次我们使用vmware workstation来安装，本篇就不说安装过程来，看<a href="https://www.nocmd.com/740.html" target="_blank" rel="noopener noreferrer">传送门</a></p>
<h1 id="动手"> 动手</h1>
<p>这里就假设你已经安装调试好了虚拟机了</p>
<ol>
<li>首先选择创建虚拟机
<img src="./images/server_2012/server02_1.png" alt="upload successful" /><br></li>
<li>选择典型的安装方式，然后下一步
<img src="./images/server_2012/server02_2.png" alt="upload successful" /><br></li>
<li>选择下载好的server 2012 R2
<img src="./images/server_2012/server02_3.png" alt="upload successful" /><br></li>
<li>此刻选择密码就好，然后选择下一步
<img src="./images/server_2012/server02_4.png" alt="upload successful" /><br></li>
<li>接下来我们给这个虚拟机命个名字，并选择一个安装位置
<img src="./images/server_2012/server02_5.png" alt="upload successful" /><br></li>
<li>由于这里硬盘内存不够，所以只放了30g，建议按情况配置
<img src="./images/server_2012/server02_6.png" alt="upload successful" /><br></li>
<li>配置完成！
<br>如果你不需要更改运存就不需要自定义硬件
<img src="./images/server_2012/server02_7.png" alt="upload successful" /><br></li>
<li>然后我们设置好配置之后就开机</li>
<li>接下来虚拟机会自动安装，后面会让你选择一个版本来安装
<img src="./images/server_2012/server02_8.png" alt="upload successful" /><br>
接下来等待即可，期间会重启几次<br>
<img src="./images/server_2012/server02_9.png" alt="upload successful" /><br></li>
<li>安装完成！
<img src="./images/server_2012/server02_10.png" alt="upload successful" /><br></li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>结构体变量赋值 (p).或p-&amp;gt;*</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/miscellaneous/%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">结构体变量赋值 (p).或p-&gt;*</source>
      <category>杂物间</category>
      <pubDate>Sat, 03 Apr 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>这里需要涉及到结构体的知识，结构体变量赋值一共三种方法</p>
<ul>
<li><code>结构体变量.成员名</code></li>
<li><code>(*p).成员名</code></li>
<li><code>p-&gt;成员名</code></li>
</ul>
<p>正常结构体赋值是</p>
<div><pre><code><span>int</span> <span>main</span><span>(</span><span>)</span><span>{</span>
<span>struct</span> <span>person</span><span>{</span>
    <span>char</span> name<span>[</span><span>20</span><span>]</span><span>;</span>
		<span>char</span> address<span>[</span><span>20</span><span>]</span><span>;</span>
    <span>int</span> count<span>;</span>
<span>}</span>person1<span>;</span>
<span>// 结构体变量.成员名</span>
person1<span>.</span>name<span>=</span><span>"acc"</span><span>;</span>
<span>struct</span> <span>person</span> person2<span>;</span>
<span>char</span> <span>*</span>p<span>;</span>
p<span>=</span><span>&amp;</span>person2<span>;</span>
<span>// (*p).成员名</span>
<span>(</span><span>*</span>p<span>)</span><span>.</span>name<span>=</span><span>"abb"</span><span>;</span>
<span>// p->成员名</span>
p<span>-></span>address<span>=</span><span>"add"</span><span>;</span>
<span>// name is abb, address is add</span>
<span>printf</span><span>(</span><span>"name is %s, address is %s"</span><span>,</span>p<span>-></span>name<span>,</span>p<span>-></span>address<span>)</span><span>;</span>
<span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h1 id="额外"> 额外</h1>
<div><pre><code><span>// 注意上例中p++和++p的区别</span>
<span>// 例如：</span>
<span>(</span><span>++</span>p<span>)</span><span>-></span>num<span>;</span> <span>// p先+1，然后得到+1后的p指向的num成员的值(stu[2])</span>
<span>(</span>p<span>++</span><span>)</span><span>-></span>num<span>;</span> <span>// 先得到p指向num成员的值，然后再使p+1 (stu[1])</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>数据结构课记</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/notes/data_structure/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/notes/data_structure/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">数据结构课记</source>
      <category>笔记</category>
      <pubDate>Mon, 07 Dec 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="导论"> 导论</h1>
<ul>
<li>本笔记由郝斌老师的视频而写出
<ul>
<li><a href="https://www.bilibili.com/video/BV11s41167h6" target="_blank" rel="noopener noreferrer">（郝斌老师）视频地址</a></li>
</ul>
</li>
</ul>
<h2 id="总结"> 总结</h2>
<ul>
<li>数据结构
<ul>
<li>狭义的讲：
<ul>
<li>数据存储是专门研究数据存储的问题</li>
<li>数据结构=个体的存储+个体关系的存储</li>
</ul>
</li>
<li>广义的讲
<ul>
<li>数据结构即包含数据的存储也包含数据的操作</li>
<li>对存储数据的操作就是算法</li>
</ul>
</li>
</ul>
</li>
<li>算法：
<ul>
<li>狭义的讲
<ul>
<li>算法是和数据的存储方式密切相关</li>
<li>算法=对存储数据的操作</li>
</ul>
</li>
<li>广义的讲
<ul>
<li>算法和数据的存储方式无关</li>
<li>这就是泛型思想</li>
</ul>
</li>
</ul>
</li>
<li>数据的存储结构（常见的几种）
<ul>
<li>线性
<ul>
<li>连续存储【<strong>数组</strong>】
<ul>
<li>优点
<ul>
<li>存取（读取）速度很快</li>
</ul>
</li>
<li>缺点
<ul>
<li>事先必须知道数组的长度</li>
<li>插入删除元素很慢</li>
<li>空间通常是有闲置</li>
<li>需要大块连续的内存块</li>
</ul>
</li>
</ul>
</li>
<li>离散存储【<strong>链表</strong>】
<ul>
<li>优点
<ul>
<li>空间没有限制</li>
<li>插入删除元素很快</li>
</ul>
</li>
<li>缺点
<ul>
<li>存取速度很慢</li>
</ul>
</li>
<li>链表总的说有三种
<ul>
<li>单链表（尾指针指向后一节点）</li>
<li>双链表（除头/尾节点，其中的每个节点的头/尾指针都指向了前/后个节点，注意其尾节点不指向头节点，头节点也不指向尾节点）</li>
<li>循环链表（与单链表类似，但最后一个节点的尾指向头节点）
<ul>
<li>双循环链表（融合了双链表和循环链表，每个节点都的头/尾指针都指向了前/后个节点，包括头尾节点）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>线性结构的应用——<strong>栈</strong>
<ul>
<li>定义：
<ul>
<li>一种进而与实现**“先进后出”**的数据存储结构</li>
</ul>
</li>
<li>分类
<ul>
<li>静态栈</li>
<li>动态栈（常用）</li>
</ul>
</li>
<li>从实现来说就是数组与链表，从内存莱说就是连续与随机</li>
</ul>
</li>
<li>线性结构的应用——<strong>队列</strong>
<ul>
<li>定义
<ul>
<li>一种可以实现<strong>先进先出</strong>的存储结构</li>
</ul>
</li>
<li>分类
<ul>
<li>链式队列</li>
<li>静态队列
<ul>
<li>用数组实现，静态队列一般时循环队列
<ul>
<li>如果不用循环队列，会造成浪费</li>
<li>具体：<a href="https://www.notion.so/4c20ffc3adb4494caf0276be226ea6b4" target="_blank" rel="noopener noreferrer">理论</a></li>
</ul>
</li>
<li>循环队列用两个元素来确定
<ul>
<li>front（对头）</li>
<li>rear（队尾）</li>
</ul>
</li>
<li>伪算法：<a href="https://www.notion.so/4c20ffc3adb4494caf0276be226ea6b4" target="_blank" rel="noopener noreferrer">理论</a></li>
</ul>
</li>
</ul>
</li>
<li>队列的具体应用
<ul>
<li>所有和时间有关的操作都与队列有关</li>
</ul>
</li>
</ul>
</li>
<li><strong>递归</strong>
<ul>
<li>定义
<ul>
<li>一个函数自己直接或间接调用自己</li>
</ul>
</li>
<li>递归和循环的优缺点
<ul>
<li>递归：
<ul>
<li>易于理解</li>
<li>速度慢</li>
<li>存储空间大</li>
</ul>
</li>
<li>循环
<ul>
<li>不易理解</li>
<li>速度快</li>
<li>存储空间小</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>非线性
<ul>
<li><strong>树</strong>
<ul>
<li>树定义
<ul>
<li>有且只有一个称为根的节点</li>
<li>有若干个互不相交的子树，这些子树本身也是一棵树</li>
<li>树是由节点和边组成</li>
<li>每个节点只有一个父节点，但可以有多个子节点</li>
<li><a href="https://www.notion.so/4c20ffc3adb4494caf0276be226ea6b4" target="_blank" rel="noopener noreferrer">术语</a></li>
</ul>
</li>
<li>树分类
<ul>
<li>一般树</li>
<li>二叉树
<ul>
<li>任意一个子节点的个数最多两个，且子节点的左右位置不可更改</li>
<li>二叉树的分类
<ul>
<li>一般二叉树</li>
<li>满二叉树</li>
<li>完全二叉树
<ul>
<li>完全二叉树是路径最短的二叉树，但路径最短的二叉树不一定是完全二叉树</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>森林</li>
</ul>
</li>
<li>树的存储
<ul>
<li>二叉树的存储
<ul>
<li>连续存储（完全二叉树）
<ul>
<li>查找节点的父节点和子节点速度很快，但耗用内存空间过大</li>
</ul>
</li>
<li>链式存储</li>
</ul>
</li>
<li>一般树的存储
<ul>
<li>双亲表示法</li>
<li>孩子表示法</li>
<li>双亲孩子表示法</li>
<li>二叉树表示法
<ul>
<li>左指针域指向它的第一个孩子</li>
<li>右指针域指向它的堂兄弟</li>
</ul>
</li>
</ul>
</li>
<li>森林的存储</li>
</ul>
</li>
<li>树的操作
<ul>
<li>树的遍历
<ul>
<li>先序遍历
<ul>
<li>先访问根节点</li>
<li>再先序访问左子树</li>
<li>再先序访问右子树</li>
</ul>
</li>
<li>中序遍历
<ul>
<li>中序遍历左子树</li>
<li>再访问根节点</li>
<li>再中序遍历右子树</li>
</ul>
</li>
<li>后序遍历
<ul>
<li>后序遍历左子树</li>
<li>再后序遍历右子树</li>
<li>再访问根节点</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>已知两种遍历求原始二叉树
<ul>
<li>已知<strong>先序和中序</strong>求后序</li>
<li>已知<strong>中序和后序</strong>求先序</li>
<li>extra
<ul>
<li>知道先序和后序求二叉树虽然很难，但通过枚举还是可以实现</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>图</strong></li>
</ul>
</li>
</ul>
</li>
<li>逻辑结构
<ul>
<li>线性（线性结构都比较成熟）
<ul>
<li>数组</li>
<li>链表</li>
</ul>
</li>
<li>栈和队列是一种特殊的线性结构
<ul>
<li>栈和队列都是线性结构，也是一种逻辑结构，他们既可以用顺序存储（顺序栈，顺序队列），也可以链式存储（链栈和链式队列）</li>
<li>栈只允许在栈头操作与删除</li>
<li>队列允许在一端删除在另一端插入</li>
</ul>
</li>
<li>非线性（非线性结构还在发展）</li>
</ul>
</li>
<li>后结
<ul>
<li>什么是数据结构？
<ul>
<li>数据结构研究的是数据的存储和数据的操作的一门学问</li>
<li>数据的存储分两部分
<ul>
<li>个体的存储</li>
<li>个体关系的存储</li>
<li><strong>从某个角度而言，数据的存储最核心的时个体关系的存储，个体的存储可以忽略不记</strong></li>
</ul>
</li>
</ul>
</li>
<li>什么是泛型
<ul>
<li>同一种逻辑结构，无论改逻辑结构物理存储时什么样子的，我们都可以对他执行相同的操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="衡量算法的标准"> 衡量算法的标准</h1>
<ol>
<li><strong>时间复杂度</strong>
<ul>
<li>大概<strong>程序要执行的次数</strong>，而非执行的时间</li>
</ul>
</li>
<li><strong>空间复杂度</strong>
<ul>
<li>算法执行过程中大概所占用的最大内存</li>
</ul>
</li>
<li>难易程度</li>
<li>健壮性
<img src="./images/data_structure/Untitled_50.png" alt="./images/data_structure/Untitled_50.png" /></li>
</ol>
<h1 id="线性结构"> 线性结构</h1>
<h2 id="连续存储-数组"> 连续存储 [数组]</h2>
<ul>
<li>参数需求
<ul>
<li>首地址</li>
<li>长度</li>
<li>有效的个数</li>
</ul>
</li>
</ul>
<h3 id="实现"> 实现</h3>
<p>数组和指针可以说是数据结构的基石，也可以说是链表、队列、栈的基础了</p>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>
<span><span>#</span><span>include</span> <span>&lt;malloc.h></span></span>
<span><span>#</span><span>include</span> <span>&lt;stdlib.h></span></span>
<span>//#include &lt;stdbool.h></span>
<span>// 要么引入stdbool.h要么自己定义bool两种方法</span>
<span>// 以下的define由于gcc不支持bool所以要自己定义bool的值</span>
<span><span>#</span><span>define</span> <span>bool</span> <span><span>char</span></span></span>
<span><span>#</span><span>define</span> <span>true</span> <span><span>1</span></span></span>
<span><span>#</span><span>define</span> <span>false</span> <span><span>0</span></span></span>
<span>// bool定义结束</span>

<span>struct</span> <span>Arr</span>
<span>{</span>
    <span>int</span> <span>*</span> pBase<span>;</span> <span>//存储的时数组第一个元素的地址</span>
    <span>int</span> len<span>;</span> <span>//数组所能容纳的最大元素的个数</span>
    <span>int</span> cnt<span>;</span> <span>//当前数组有效元素的个数</span>
<span>}</span><span>;</span>

<span>void</span> <span>init_arr</span><span>(</span><span>struct</span> <span>Arr</span> <span>*</span>arr<span>,</span> <span>int</span> length<span>)</span><span>;</span>
bool <span>append_arr</span><span>(</span><span>struct</span> <span>Arr</span> <span>*</span> pArr<span>,</span><span>int</span> val<span>)</span><span>;</span><span>//追加</span>
bool <span>insert_arr</span><span>(</span><span>struct</span> <span>Arr</span> <span>*</span> pArr<span>,</span><span>int</span> pos<span>,</span><span>int</span> val<span>)</span><span>;</span>
bool <span>delete_arr</span><span>(</span><span>struct</span> <span>Arr</span> <span>*</span> pArr<span>,</span><span>int</span> pos<span>,</span><span>int</span> <span>*</span> pVal<span>)</span><span>;</span>
bool <span>is_empty</span><span>(</span><span>struct</span> <span>Arr</span> <span>*</span>pArr<span>)</span><span>;</span>
bool <span>is_full</span><span>(</span><span>struct</span> <span>Arr</span> <span>*</span> pArr<span>)</span><span>;</span>
<span>void</span> <span>sort_arr</span><span>(</span><span>struct</span> <span>Arr</span> <span>*</span> pArr<span>)</span><span>;</span>
<span>void</span> <span>show_arr</span><span>(</span><span>struct</span> <span>Arr</span> <span>*</span>pArr<span>)</span><span>;</span>
<span>void</span> <span>inversion_arr</span><span>(</span><span>struct</span> <span>Arr</span> <span>*</span> pArr<span>)</span><span>;</span> <span>//倒置</span>

<span>int</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
    <span>struct</span> <span>Arr</span> arr<span>;</span>
    <span>int</span> val<span>;</span>
    <span>init_arr</span><span>(</span><span>&amp;</span>arr<span>,</span> <span>6</span><span>)</span><span>;</span>
    <span>show_arr</span><span>(</span><span>&amp;</span>arr<span>)</span><span>;</span>
    <span>append_arr</span><span>(</span><span>&amp;</span>arr<span>,</span> <span>1</span><span>)</span><span>;</span>
    <span>append_arr</span><span>(</span><span>&amp;</span>arr<span>,</span> <span>2</span><span>)</span><span>;</span>
    <span>append_arr</span><span>(</span><span>&amp;</span>arr<span>,</span> <span>3</span><span>)</span><span>;</span>
    <span>append_arr</span><span>(</span><span>&amp;</span>arr<span>,</span> <span>4</span><span>)</span><span>;</span>
    <span>append_arr</span><span>(</span><span>&amp;</span>arr<span>,</span> <span>5</span><span>)</span><span>;</span>
    <span>append_arr</span><span>(</span><span>&amp;</span>arr<span>,</span> <span>6</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span><span>delete_arr</span><span>(</span><span>&amp;</span>arr<span>,</span> <span>5</span><span>,</span><span>&amp;</span>val<span>)</span><span>)</span>
    <span>{</span>
        <span>printf</span><span>(</span><span>"delete success! You delete num is %d\n"</span><span>,</span>val<span>)</span><span>;</span>
    <span>}</span>
    <span>else</span>
        <span>printf</span><span>(</span><span>"delete false!\n"</span><span>)</span><span>;</span>
    <span>show_arr</span><span>(</span><span>&amp;</span>arr<span>)</span><span>;</span>
    <span>insert_arr</span><span>(</span><span>&amp;</span>arr<span>,</span><span>3</span><span>,</span><span>-</span><span>5</span><span>)</span><span>;</span>
    <span>show_arr</span><span>(</span><span>&amp;</span>arr<span>)</span><span>;</span>
    <span>printf</span><span>(</span><span>"inversion the list is:\n"</span><span>)</span><span>;</span>
    <span>inversion_arr</span><span>(</span><span>&amp;</span>arr<span>)</span><span>;</span>
    <span>show_arr</span><span>(</span><span>&amp;</span>arr<span>)</span><span>;</span>
    <span>printf</span><span>(</span><span>"sort the list is:\n"</span><span>)</span><span>;</span>
    <span>sort_arr</span><span>(</span><span>&amp;</span>arr<span>)</span><span>;</span>
    <span>show_arr</span><span>(</span><span>&amp;</span>arr<span>)</span><span>;</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
<span>void</span> <span>init_arr</span><span>(</span><span>struct</span> <span>Arr</span> <span>*</span>pArr<span>,</span> <span>int</span> length<span>)</span>
<span>{</span>
    pArr<span>-></span>pBase <span>=</span><span>(</span><span>int</span> <span>*</span><span>)</span><span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>int</span><span>)</span> <span>*</span> length<span>)</span><span>;</span>
    <span>if</span><span>(</span><span>NULL</span><span>==</span>pArr<span>-></span>pBase<span>)</span>
    <span>{</span>
        <span>printf</span><span>(</span><span>"create pBase false!\n"</span><span>)</span><span>;</span>
        <span>exit</span><span>(</span><span>-</span><span>1</span><span>)</span><span>;</span>
    <span>}</span>
    <span>else</span>
    <span>{</span>
        pArr<span>-></span>len <span>=</span> length<span>;</span>
        pArr<span>-></span>cnt <span>=</span> <span>0</span><span>;</span>
    <span>}</span>
<span>}</span>
bool <span>is_empty</span><span>(</span><span>struct</span> <span>Arr</span> <span>*</span>pArr<span>)</span>
<span>{</span>
    <span>if</span> <span>(</span>pArr<span>-></span>cnt<span>==</span><span>0</span><span>)</span>
        <span>return</span> true<span>;</span>
    <span>else</span>
        <span>return</span> false<span>;</span>
<span>}</span>
bool <span>is_full</span><span>(</span><span>struct</span> <span>Arr</span> <span>*</span>pArr<span>)</span>
<span>{</span>
    <span>if</span><span>(</span>pArr<span>-></span>cnt <span>==</span>pArr<span>-></span>len<span>)</span>
        <span>return</span> true<span>;</span>
    <span>else</span>
        <span>return</span> false<span>;</span>
<span>}</span>
<span>void</span> <span>show_arr</span><span>(</span><span>struct</span> <span>Arr</span> <span>*</span>pArr<span>)</span>
<span>{</span>
    <span>if</span> <span>(</span><span>is_empty</span><span>(</span>pArr<span>)</span><span>)</span>
    <span>{</span>
        <span>printf</span><span>(</span><span>"arr is empty!\n"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>else</span>
    <span>{</span>
        <span>for</span><span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span>i<span>&lt;</span>pArr<span>-></span>cnt<span>;</span><span>++</span>i<span>)</span>
            <span>printf</span><span>(</span><span>"%d "</span><span>,</span>pArr<span>-></span>pBase<span>[</span>i<span>]</span><span>)</span><span>;</span>
        <span>printf</span><span>(</span><span>"\n"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>return</span><span>;</span>
<span>}</span>
bool <span>append_arr</span><span>(</span><span>struct</span> <span>Arr</span> <span>*</span>pArr<span>,</span> <span>int</span> val<span>)</span>
<span>{</span>
    <span>if</span> <span>(</span><span>is_full</span><span>(</span>pArr<span>)</span><span>)</span>
        <span>return</span> false<span>;</span>
    pArr<span>-></span>pBase<span>[</span>pArr<span>-></span>cnt<span>]</span><span>=</span>val<span>;</span>
    <span>(</span>pArr<span>-></span>cnt<span>)</span> <span>++</span><span>;</span>
    <span>return</span> true<span>;</span>
<span>}</span>
bool <span>insert_arr</span><span>(</span><span>struct</span> <span>Arr</span> <span>*</span>pArr<span>,</span> <span>int</span> pos<span>,</span> <span>int</span> val<span>)</span>
<span>{</span>
    <span>if</span><span>(</span><span>is_full</span><span>(</span>pArr<span>)</span><span>)</span>
        <span>return</span> false<span>;</span>
    <span>if</span><span>(</span>pos<span>&lt;</span><span>1</span> <span>||</span> pos<span>></span>pArr<span>-></span>cnt<span>+</span><span>1</span><span>)</span>
        <span>return</span> false<span>;</span>
    <span>for</span><span>(</span><span>int</span> i<span>=</span>pArr<span>-></span>cnt<span>-</span><span>1</span><span>;</span>i<span>&lt;</span>pos<span>-</span><span>1</span><span>;</span><span>--</span>i<span>)</span>
    <span>{</span>
        pArr<span>-></span>pBase<span>[</span>i<span>+</span><span>1</span><span>]</span><span>=</span>pArr<span>-></span>pBase<span>[</span>i<span>]</span><span>;</span>
    <span>}</span>
    pArr<span>-></span>pBase<span>[</span>pos<span>-</span><span>1</span><span>]</span> <span>=</span> val<span>;</span>
    <span>return</span> true<span>;</span>
<span>}</span>
bool <span>delete_arr</span><span>(</span><span>struct</span> <span>Arr</span> <span>*</span>pArr<span>,</span> <span>int</span> pos<span>,</span> <span>int</span> <span>*</span>pVal<span>)</span>
<span>{</span>
    <span>if</span><span>(</span><span>is_empty</span><span>(</span>pArr<span>)</span><span>)</span>
        <span>return</span> false<span>;</span>
    <span>if</span><span>(</span>pos<span>&lt;</span><span>1</span><span>||</span>pos<span>></span>pArr<span>-></span>cnt<span>)</span>
        <span>return</span> false<span>;</span>
    <span>*</span>pVal <span>=</span> pArr<span>-></span>pBase<span>[</span>pos<span>-</span><span>1</span><span>]</span><span>;</span>
    <span>for</span><span>(</span><span>int</span> i<span>=</span>pos<span>;</span>i<span>&lt;</span>pArr<span>-></span>cnt<span>;</span><span>++</span>i<span>)</span><span>{</span>
        pArr<span>-></span>pBase<span>[</span>i<span>-</span><span>1</span><span>]</span><span>=</span>pArr<span>-></span>pBase<span>[</span>i<span>]</span><span>;</span>
    <span>}</span>
    <span>(</span>pArr<span>-></span>cnt<span>)</span><span>--</span><span>;</span>
    <span>return</span> true<span>;</span>
<span>}</span>
<span>void</span> <span>inversion_arr</span><span>(</span><span>struct</span> <span>Arr</span> <span>*</span>pArr<span>)</span>
<span>{</span> <span>//倒置整个数组</span>
    <span>int</span> i<span>=</span><span>0</span><span>;</span>
    <span>int</span> j<span>=</span>pArr<span>-></span>cnt<span>-</span><span>1</span><span>;</span>
    <span>int</span> n<span>;</span>
    <span>while</span> <span>(</span>i<span>&lt;</span>j<span>)</span>
    <span>{</span>
        n<span>=</span>pArr<span>-></span>pBase<span>[</span>i<span>]</span><span>;</span>
        pArr<span>-></span>pBase<span>[</span>i<span>]</span><span>=</span>pArr<span>-></span>pBase<span>[</span>j<span>]</span><span>;</span>
        pArr<span>-></span>pBase<span>[</span>j<span>]</span><span>=</span>n<span>;</span>
        <span>++</span>i<span>;</span><span>--</span>j<span>;</span>
    <span>}</span>
<span>}</span>
<span>void</span> <span>sort_arr</span><span>(</span><span>struct</span> <span>Arr</span> <span>*</span>pArr<span>)</span><span>{</span>
    <span>int</span> n<span>;</span>
    <span>for</span><span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span>i<span>&lt;</span>pArr<span>-></span>cnt<span>;</span><span>++</span>i<span>)</span>
    <span>{</span>
        <span>for</span><span>(</span><span>int</span> j<span>=</span>i<span>+</span><span>1</span><span>;</span>j<span>&lt;</span>pArr<span>-></span>cnt<span>;</span><span>++</span>j<span>)</span>
        <span>{</span>
            <span>if</span> <span>(</span>pArr<span>-></span>pBase<span>[</span>i<span>]</span> <span>></span> pArr<span>-></span>pBase<span>[</span>j<span>]</span><span>)</span>
            <span>{</span>
                n<span>=</span>pArr<span>-></span>pBase<span>[</span>i<span>]</span><span>;</span>
                pArr<span>-></span>pBase<span>[</span>i<span>]</span> <span>=</span> pArr<span>-></span>pBase<span>[</span>j<span>]</span><span>;</span>
                pArr<span>-></span>pBase<span>[</span>j<span>]</span><span>=</span>n<span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br></div></div><h2 id="离散存储-链表"> 离散存储 [链表]</h2>
<h3 id="定义"> 定义</h3>
<ul>
<li>
<p>n个节点离散分配</p>
</li>
<li>
<p>彼此通过指针相连</p>
</li>
<li>
<p>每个节点只有一个前驱节点，每个节点只有一个后续节点</p>
</li>
<li>
<p>首节点没有前驱节点，尾节点没有后续节点</p>
</li>
<li>
<p>专业术语</p>
<ul>
<li>首节点
<ul>
<li>第一个有效节点</li>
</ul>
</li>
<li>尾节点
<ul>
<li>最后一个有效节点</li>
<li>尾节点也可以看成NULL</li>
</ul>
</li>
<li>头节点
<ul>
<li><strong>头节点的数据类型和首节点类型一样</strong></li>
<li><strong>第一个有效节点的前一个节点</strong></li>
<li><strong>头节点并不存放有效数据</strong></li>
<li><strong>加头节点的目的是为了方便我们对列表的操作（增删改查）</strong></li>
</ul>
</li>
<li>头指针
<ul>
<li>指向头节点的指针变量</li>
</ul>
</li>
<li>尾指针
<ul>
<li>指向尾节点的指针</li>
</ul>
</li>
</ul>
<p><img src="./images/data_structure/Untitled.png" alt="./images/data_structure/Untitled.png" /></p>
</li>
<li>
<p>参数需求（如果要通过一个函数来对链表进行处理，我们至少需要接受链表的那些参数</p>
<ul>
<li>头指针
<ul>
<li>因为我们通过一个头指针就可以推算出其他的所有信息</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="分类"> 分类</h3>
<ul>
<li>
<p>单链表</p>
<ul>
<li><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.68333em;vertical-align:0em;"></span><span>A</span><span style="margin-right:0.2777777777777778em;"></span><span>⇒</span><span style="margin-right:0.2777777777777778em;"></span></span><span><span style="height:0.68333em;vertical-align:0em;"></span><span style="margin-right:0.05017em;">B</span><span style="margin-right:0.2777777777777778em;"></span><span>⇒</span><span style="margin-right:0.2777777777777778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.07153em;">C</span><span>(</span><span>⇒</span><span style="margin-right:0.2777777777777778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.10903em;">N</span><span>ULL</span><span>)</span></span></span></span></li>
</ul>
</li>
<li>
<p>双链表</p>
<ul>
<li>每一个节点有两个指针域</li>
<li><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.68333em;vertical-align:0em;"></span><span>A</span><span style="margin-right:0.2777777777777778em;"></span><span>⇔</span><span style="margin-right:0.2777777777777778em;"></span></span><span><span style="height:0.68333em;vertical-align:0em;"></span><span style="margin-right:0.05017em;">B</span><span style="margin-right:0.2777777777777778em;"></span><span>⇔</span><span style="margin-right:0.2777777777777778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.07153em;">C</span><span>(</span><span>⇒</span><span style="margin-right:0.2777777777777778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.10903em;">N</span><span>ULL</span><span>)</span></span></span></span></li>
</ul>
</li>
<li>
<p>循环链表</p>
<ul>
<li>能通过任何一个节点找到其他所有的节点</li>
<li><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.68333em;vertical-align:0em;"></span><span>A</span><span style="margin-right:0.2777777777777778em;"></span><span>⇒</span><span style="margin-right:0.2777777777777778em;"></span></span><span><span style="height:0.68333em;vertical-align:0em;"></span><span style="margin-right:0.05017em;">B</span><span style="margin-right:0.2777777777777778em;"></span><span>⇒</span><span style="margin-right:0.2777777777777778em;"></span></span><span><span style="height:0.68333em;vertical-align:0em;"></span><span style="margin-right:0.05017em;">B</span><span style="margin-right:0.2777777777777778em;"></span><span>⇒</span><span style="margin-right:0.2777777777777778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.07153em;">C</span><span>(</span><span>⇒</span><span style="margin-right:0.2777777777777778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>A</span><span>)</span></span></span></span></li>
</ul>
</li>
<li>
<p>非循环链表</p>
</li>
<li>
<p>结构体定义</p>
<div><pre><code><span>typedef</span> <span>struct</span> <span>Node</span>
<span>{</span>
    <span>int</span> data<span>;</span> <span>// 数据域</span>
    <span>struct</span> <span>Node</span> <span>*</span> pNext<span>;</span> <span>//指针域</span>
<span>}</span>NODE<span>,</span> <span>*</span>PNODE<span>;</span> 
<span>//NODE等价于struct Node</span>
<span>//PNODE等价于struct Node *</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
</ul>
<h3 id="实现原理"> 实现原理</h3>
<ul>
<li>
<p>遍历</p>
</li>
<li>
<p>查找</p>
</li>
<li>
<p>清空</p>
</li>
<li>
<p>销毁</p>
</li>
<li>
<p>求长度</p>
</li>
<li>
<p>排序</p>
</li>
<li>
<p>删除节点</p>
<p><img src="./images/data_structure/Untitled_1.png" alt="./images/data_structure/Untitled_1.png" /></p>
<div><pre><code><span>// 注意这是伪算法，并没有真正的实现</span>
r <span>=</span> p<span>-></span>pNext<span>;</span><span>//p->pNext表示p所指向结构体变量中pNExt成员本身</span>
p<span>-></span>pNext <span>=</span> p<span>-></span>pNext<span>-></span>pNext
free r<span>;</span> <span>//删除r指向节点所占的内存，不是删除r本身所占内存</span>

<span>// ----错误示例----START</span>
<span>/*注意不能单纯这样这样写，因为这样会导致内存泄露！
由于p->pNext变量已经改变所以指向
中间值的地址已经没有了，但其在内存中还是存在的*/</span>
p<span>-></span>pNext <span>=</span> p<span>-></span>pNext<span>-></span>pNext
<span>// ----错误示例----END</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></li>
<li>
<p>插入节点</p>
<p><img src="./images/data_structure/Untitled_2.png" alt="./images/data_structure/Untitled_2.png" /></p>
<div><pre><code><span>// 注意这是伪算法，并没有真正的实现</span>
<span>// pNext表示指向下一节点</span>
<span>// 假设有链表A->B->C</span>
<span>// 先有D要插入到AB之间</span>
<span>// 方法1【推荐】</span>
D<span>-></span>pNext <span>=</span> A<span>-></span>pNext<span>;</span>
A<span>-></span>pNext <span>=</span> D<span>;</span>
<span>// 方法2，与方法1一样</span>
r <span>=</span> A<span>-></span>pNext<span>;</span>
A<span>-></span>pNext <span>=</span> D<span>;</span>
D<span>-></span>pNext <span>=</span> r<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></li>
<li>
<p>算法</p>
<ul>
<li>狭义的算法是与数据的存储方式密切相关</li>
<li>广义的算法是与数据的存储方式无关</li>
<li>泛型
<ul>
<li>利用某种技术达到的效果就是：不同的存储方式，执行的操作时是一样的</li>
</ul>
</li>
</ul>
</li>
<li>
<p>链表的优缺点（见下面总结）</p>
</li>
<li>
<p>链表总的说有三种</p>
<ul>
<li><strong>单链表</strong>（尾指针指向后一节点）</li>
<li>双链表（除头/尾节点，其中的每个节点的头/尾指针都指向了前/后个节点，注意其尾节点不指向头节点，头节点也不指向尾节点）</li>
<li>循环链表（与单链表类似，但最后一个节点的尾指向头节点）
<ul>
<li>双循环链表（融合了双链表和循环链表，每个节点都的头/尾指针都指向了前/后个节点，包括头尾节点）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="实现代码"> 实现代码</h3>
<ul>
<li>视频上只演示了单链表的方法，所以这里只有单链表的代码，然后<strong>指针</strong>真的很重要，记得要学习好</li>
<li>这里还涉及到一个 <code>typedef</code> ，这个可以理解为自定义类型</li>
<li>比如说 <code>typedef struct Node{···} NODE, *PNODE</code>
<ul>
<li>NODE其实就是<code>struct Node{···}</code></li>
<li>*PNODE其实就是<code>struct Node{···} *</code></li>
<li>本来定义一个结构体Node变量Q需要
<ul>
<li><code>struct Node Q;</code></li>
</ul>
</li>
<li>现在只需要（很方便呢😆
<ul>
<li><code>NODE Q</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>
<span><span>#</span><span>include</span> <span>&lt;stdlib.h></span></span>
<span><span>#</span><span>include</span> <span>&lt;malloc.h></span></span>

<span><span>#</span><span>define</span> <span>bool</span> <span><span>char</span></span></span>
<span><span>#</span><span>define</span> <span>true</span> <span><span>1</span></span></span>
<span><span>#</span><span>define</span> <span>false</span> <span><span>0</span></span></span>

<span>typedef</span> <span>struct</span> <span>Node</span>
<span>{</span>
    <span>int</span> data<span>;</span> <span>// 数据域</span>
    <span>struct</span> <span>Node</span> <span>*</span> pNext<span>;</span> <span>//指针域</span>
<span>}</span>NODE<span>,</span> <span>*</span>PNODE<span>;</span> <span>//NODE等价于struct Node  PNODE等价于struct Node *</span>
<span>//函数声明</span>
<span>//创建链表</span>
PNODE <span>create_list</span><span>(</span><span>void</span><span>)</span><span>;</span>
<span>//遍历并输出链表的data</span>
<span>void</span> <span>traverse_list</span><span>(</span>PNODE pHead<span>)</span><span>;</span>
<span>//判断链表是否为空</span>
bool <span>is_empty</span><span>(</span>PNODE pHead<span>)</span><span>;</span>
<span>//求链表长度</span>
<span>int</span> <span>length_list</span><span>(</span>PNODE<span>)</span><span>;</span> 
<span>//在pHead所指向链表的第pos个节点的前面插入一个新的节点，该节点的值是val，pos的值是从1开始</span>
bool <span>insert_list</span><span>(</span>PNODE pHead<span>,</span> <span>int</span> pos<span>,</span> <span>int</span> val<span>)</span><span>;</span>
<span>//删除链表第pos个节点，并将删除的节点的值存入pVal所指向的变量中，pos的值是从1开始</span>
bool <span>delete_list</span><span>(</span>PNODE pHead<span>,</span> <span>int</span> pos<span>,</span> <span>int</span> <span>*</span>pVal<span>)</span><span>;</span>
<span>//对链表进行排序</span>
<span>void</span> <span>sort_list</span><span>(</span>PNODE<span>)</span><span>;</span> 

<span>int</span> <span>main</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
    PNODE pHead <span>=</span> <span>NULL</span><span>;</span> <span>//等价于 struct Node * pHead=NULL;</span>
    <span>int</span> val<span>;</span>

    <span>//create_list()功能是创建一个非循环单练表，并将量表的头节点的地址赋予给pHead</span>
    pHead <span>=</span> <span>create_list</span><span>(</span><span>)</span><span>;</span>
    <span>insert_list</span><span>(</span>pHead<span>,</span> <span>2</span><span>,</span> <span>33</span><span>)</span><span>;</span>
    <span>sort_list</span><span>(</span>pHead<span>)</span><span>;</span>
    <span>traverse_list</span><span>(</span>pHead<span>)</span><span>;</span>
    <span>if</span><span>(</span><span>delete_list</span><span>(</span>pHead<span>,</span><span>4</span><span>,</span><span>&amp;</span>val<span>)</span><span>)</span>
    <span>{</span>
        <span>printf</span><span>(</span><span>"delete success,del num is %d\n"</span><span>,</span>val<span>)</span><span>;</span>
    <span>}</span>
    <span>else</span>
    <span>{</span>
        <span>printf</span><span>(</span><span>"delete faled! choice position unexist!\n"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>traverse_list</span><span>(</span>pHead<span>)</span><span>;</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
<span>//初始化链表</span>
PNODE <span>create_list</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
    <span>int</span> len<span>;</span> <span>//存放有效节点的个数</span>
    <span>int</span> val<span>;</span> <span>//临时存放用户输入的节点的值</span>
    <span>int</span> i<span>;</span>
    PNODE pHead <span>=</span> <span>(</span>PNODE<span>)</span><span>malloc</span><span>(</span><span>sizeof</span><span>(</span>NODE<span>)</span><span>)</span><span>;</span>
    <span>if</span><span>(</span><span>NULL</span> <span>==</span> pHead<span>)</span>
    <span>{</span>
        <span>printf</span><span>(</span><span>"create false!\n"</span><span>)</span><span>;</span>
        <span>exit</span><span>(</span><span>-</span><span>1</span><span>)</span><span>;</span>
    <span>}</span>
    <span>//创建一个尾节点，将头节点的尾指针指向NULL，当len为1时，即指向NULL</span>
    PNODE pTail <span>=</span> pHead<span>;</span>
    pTail<span>-></span>pNext<span>=</span><span>NULL</span><span>;</span>
    <span>printf</span><span>(</span><span>"please input list length:"</span><span>)</span><span>;</span>
    <span>scanf</span><span>(</span><span>"%d"</span><span>,</span><span>&amp;</span>len<span>)</span><span>;</span>
    <span>for</span><span>(</span>i<span>=</span><span>0</span><span>;</span>i<span>&lt;</span>len<span>;</span><span>++</span>i<span>)</span>
    <span>{</span>
        <span>printf</span><span>(</span><span>"please input the %d value:"</span><span>,</span>i<span>+</span><span>1</span><span>)</span><span>;</span>
        <span>scanf</span><span>(</span><span>"%d"</span><span>,</span><span>&amp;</span>val<span>)</span><span>;</span>
        PNODE pNew<span>=</span><span>(</span>PNODE<span>)</span><span>malloc</span><span>(</span><span>sizeof</span><span>(</span>NODE<span>)</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span><span>NULL</span> <span>==</span> pNew<span>)</span>
        <span>{</span>
            <span>printf</span><span>(</span><span>"create false!\n"</span><span>)</span><span>;</span>
            <span>exit</span><span>(</span><span>-</span><span>1</span><span>)</span><span>;</span>
        <span>}</span>
        <span>//若len>1则指向循环，创建一个pNew作为新的节点</span>
        <span>//【第1次】将val存入pNew的data，并将pTail代表的pHead的尾指针指向pNew，并将pNew的尾指针设为NULL，然后再将pTail指向pNew</span>
        pNew<span>-></span>data<span>=</span>val<span>;</span>
        pTail<span>-></span>pNext<span>=</span>pNew<span>;</span>
        pNew<span>-></span>pNext<span>=</span><span>NULL</span><span>;</span>
        pTail<span>=</span>pNew<span>;</span>
    <span>}</span>
    <span>// 循环执行完毕就完成了A->B->C···，然后将头指针pHead作为函数返回即可</span>
    <span>return</span> pHead<span>;</span>
<span>}</span>
<span>//遍历链表，并输出链表中所有的值，用p来relay指向头节点的下一节点然后循环[将data域输出; 再指向下一节点]</span>
<span>void</span> <span>traverse_list</span><span>(</span>PNODE pHead<span>)</span>
<span>{</span>
    PNODE p<span>=</span>pHead<span>-></span>pNext<span>;</span>
    <span>while</span><span>(</span><span>NULL</span><span>!=</span>p<span>)</span>
    <span>{</span>
        <span>printf</span><span>(</span><span>"%d "</span><span>,</span>p<span>-></span>data<span>)</span><span>;</span>
        p<span>=</span>p<span>-></span>pNext<span>;</span>
    <span>}</span>
    <span>printf</span><span>(</span><span>"\n"</span><span>)</span><span>;</span>
<span>}</span>
<span>//判断头节点的下一节点是否为空即可判断链表是否为空，注意链表是不存在满的情况，因为链表可以有无限个，但是内存会有满的时候！</span>
bool <span>is_empty</span><span>(</span>PNODE pHead<span>)</span>
<span>{</span>
    <span>if</span><span>(</span><span>NULL</span><span>==</span>pHead<span>-></span>pNext<span>)</span>
        <span>return</span> true<span>;</span>
    <span>else</span>
        <span>return</span> false<span>;</span>
<span>}</span>
<span>//计算链表长度,并返回整数的长度值</span>
<span>int</span> <span>length_list</span><span>(</span>PNODE pHead<span>)</span>
<span>{</span>
    PNODE p<span>=</span>pHead<span>-></span>pNext<span>;</span>
    <span>int</span> len<span>=</span><span>0</span><span>;</span>
    <span>while</span><span>(</span><span>NULL</span><span>!=</span>p<span>)</span>
    <span>{</span>
        <span>++</span>len<span>;</span>
        p<span>=</span>p<span>-></span>pNext<span>;</span>
    <span>}</span>
    <span>return</span> len<span>;</span>
<span>}</span>
<span>//对指针的data域数据进行比较，然后将data域互换排序</span>
<span>void</span> <span>sort_list</span><span>(</span>PNODE pHead<span>)</span>
<span>{</span>
    <span>int</span> i<span>,</span>j<span>,</span>k<span>;</span>
    <span>int</span> len<span>=</span><span>length_list</span><span>(</span>pHead<span>)</span><span>;</span>
    PNODE p<span>,</span>q<span>;</span>
    <span>//for循环来循环需要排序的次数，并在其中嵌套指向下一个链表的逻辑</span>
    <span>for</span><span>(</span>i<span>=</span><span>0</span><span>,</span>p<span>=</span>pHead<span>-></span>pNext<span>;</span>i<span>&lt;</span>len<span>-</span><span>1</span><span>;</span>i<span>++</span><span>,</span>p<span>=</span>p<span>-></span>pNext<span>)</span>
    <span>{</span>
        <span>for</span><span>(</span>j<span>=</span>i<span>+</span><span>1</span><span>,</span>q<span>=</span>p<span>-></span>pNext<span>;</span>j<span>&lt;</span>len<span>;</span><span>++</span>j<span>,</span>q<span>=</span>q<span>-></span>pNext<span>)</span>
        <span>{</span>
            <span>if</span><span>(</span>p<span>-></span>data<span>></span>q<span>-></span>data<span>)</span>
            <span>{</span>
                <span>//创建relay接收p的data</span>
                k<span>=</span>p<span>-></span>data<span>;</span>
                <span>//将p的data与q的data互换</span>
                p<span>-></span>data<span>=</span>q<span>-></span>data<span>;</span>
                <span>//将q的data改为relay的值</span>
                q<span>-></span>data<span>=</span>k<span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>    
<span>}</span>
<span>//插入链表，需要先</span>
bool <span>insert_list</span><span>(</span>PNODE pHead<span>,</span> <span>int</span> pos<span>,</span> <span>int</span> val<span>)</span><span>{</span>
    <span>//用于判断链表是否为空、参数是否有误，</span>
    <span>int</span> i<span>=</span><span>0</span><span>;</span>
    PNODE p<span>=</span>pHead<span>;</span>
    <span>//因为插入时p的位置要在pos的前面，所以判断p即可</span>
    <span>while</span><span>(</span><span>NULL</span><span>!=</span>p<span>&amp;&amp;</span>i<span>&lt;</span>pos<span>-</span><span>1</span><span>)</span>
    <span>{</span>
        p<span>=</span>p<span>-></span>pNext<span>;</span>
        <span>++</span>i<span>;</span>
    <span>}</span>
    <span>//若输入有误，pos-1会&lt;i</span>
    <span>//若链表为空则p会尾NULL</span>
    <span>if</span> <span>(</span>i<span>></span>pos<span>-</span><span>1</span><span>||</span><span>NULL</span><span>==</span>p<span>)</span>
        <span>return</span> false<span>;</span>
    <span>//执行到这里的时候，p已经指向第pos-1个节点，pos-1是否存在无所谓</span>
    <span>//若输入无误，pos-1会>i而且p会指向到pos-1的位置，即需要插入的位置</span>
    <span>//新建节点作relay</span>
    PNODE pNew <span>=</span> <span>(</span>PNODE<span>)</span><span>malloc</span><span>(</span><span>sizeof</span><span>(</span>NODE<span>)</span><span>)</span><span>;</span>
    <span>if</span><span>(</span><span>NULL</span><span>==</span>pNew<span>)</span><span>{</span>
        <span>printf</span><span>(</span><span>"create false\n"</span><span>)</span><span>;</span>
        <span>exit</span><span>(</span><span>-</span><span>1</span><span>)</span><span>;</span>
    <span>}</span>
    <span>//A->B->C，要插入D到bc之间，先将数据放入D，然后将B指向D，D指向C，即A->B->D->C</span>
    <span>//作插入的新节点先放入数据</span>
    pNew<span>-></span>data<span>=</span>val<span>;</span>

    <span>//新建q节点指向插入节点的后一个节点</span>
    PNODE q<span>=</span>p<span>-></span>pNext<span>;</span>
    <span>//将插入节点的前一个节点的尾节点指向新节点</span>
    p<span>-></span>pNext<span>=</span>pNew<span>;</span>
    <span>//再将新节点指向插入节点的后一个节点</span>
    pNew<span>-></span>pNext<span>=</span>q<span>;</span>
    <span>return</span> true<span>;</span>
<span>}</span>
bool <span>delete_list</span><span>(</span>PNODE pHead<span>,</span> <span>int</span> pos<span>,</span> <span>int</span> <span>*</span>pVal<span>)</span>
<span>{</span>
    <span>int</span> i<span>=</span><span>0</span><span>;</span>
    PNODE p<span>=</span>pHead<span>;</span>
    <span>//因为删除操作是删除pos位置的值，所以判断p->pNext</span>
    <span>while</span><span>(</span><span>NULL</span><span>!=</span>p<span>-></span>pNext<span>&amp;&amp;</span>i<span>&lt;</span>pos<span>-</span><span>1</span><span>)</span>
    <span>{</span>
        p<span>=</span>p<span>-></span>pNext<span>;</span>
        <span>++</span>i<span>;</span>
    <span>}</span>
    <span>if</span><span>(</span>i<span>></span>pos<span>-</span><span>1</span><span>||</span><span>NULL</span><span>==</span>p<span>-></span>pNext<span>)</span>
        <span>return</span> false<span>;</span>
    <span>// 执行到这里的时候说明p的值已经指向第pos-1个节点，并且pos-1存在</span>
    <span>//ABCD,要删除C，此时p指向B，新建q指向C以free，将C的data存放以输出，将B指向D，然后free掉c，并将C=NULL（防止复活）</span>
    <span>//p指向要删除的节点</span>
    PNODE q<span>=</span>p<span>-></span>pNext<span>;</span>
    <span>//将pVal等于要删除的链表的数据</span>
    <span>*</span>pVal<span>=</span>q<span>-></span>data<span>;</span>
    <span>//将p指向要删除节点的下一个节点</span>
    p<span>-></span>pNext<span>=</span>p<span>-></span>pNext<span>-></span>pNext<span>;</span>
    <span>//释放内存</span>
    <span>free</span><span>(</span>q<span>)</span><span>;</span>
    q<span>=</span><span>NULL</span><span>;</span>
    <span>return</span> true<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br><span>170</span><br><span>171</span><br><span>172</span><br><span>173</span><br><span>174</span><br><span>175</span><br><span>176</span><br><span>177</span><br><span>178</span><br><span>179</span><br><span>180</span><br><span>181</span><br><span>182</span><br><span>183</span><br><span>184</span><br><span>185</span><br><span>186</span><br><span>187</span><br><span>188</span><br><span>189</span><br><span>190</span><br><span>191</span><br><span>192</span><br><span>193</span><br><span>194</span><br><span>195</span><br><span>196</span><br><span>197</span><br><span>198</span><br><span>199</span><br><span>200</span><br><span>201</span><br></div></div><h2 id="栈-线性结构的两种常用应用"> 栈 - 线性结构的两种常用应用</h2>
<h3 id="定义-2"> 定义</h3>
<ul>
<li>一种进而与实现“先进后出”的数据存储结构</li>
<li>栈类似于箱子</li>
</ul>
<h3 id="分类-2"> 分类</h3>
<ul>
<li>静态栈</li>
<li>动态栈（常用）</li>
</ul>
<h3 id="算法"> 算法</h3>
<ul>
<li>出栈（删除一个节点）
<ul>
<li>pop，pTop</li>
<li>出栈则将最上面的节点删除并将pTop指向下一个节点</li>
</ul>
</li>
<li>压栈（添加一个节点）
<ul>
<li>push，pTop</li>
<li>压栈则添加一个节点，并将pTop指向新的节点</li>
</ul>
</li>
</ul>
<h3 id="实现-2"> 实现</h3>
<p><img src="./images/data_structure/Untitled_3.png" alt="./images/data_structure/Untitled_3.png" /></p>
<ul>
<li>栈是“先进后出”</li>
<li>栈按内存有静态栈和<strong>动态栈（常用）</strong>，从实现来说就是数组与链表，从内存莱说就是连续与随机</li>
</ul>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>
<span><span>#</span><span>include</span> <span>&lt;stdlib.h></span></span>
<span><span>#</span><span>include</span> <span>&lt;malloc.h></span></span>
<span><span>#</span><span>define</span> <span>bool</span> <span><span>char</span></span></span>
<span><span>#</span><span>define</span> <span>true</span> <span><span>1</span></span></span>
<span><span>#</span><span>define</span> <span>false</span> <span><span>0</span></span></span>

<span>typedef</span> <span>struct</span> <span>node</span><span>{</span>
    <span>int</span> data<span>;</span>
    <span>struct</span> <span>node</span> <span>*</span> pNext<span>;</span>
<span>}</span>NODE<span>,</span> <span>*</span>PNODE<span>;</span>
<span>typedef</span> <span>struct</span> <span>stack</span><span>{</span>
    PNODE pTop<span>;</span>
    PNODE pBottom<span>;</span>
<span>}</span>STACK<span>,</span><span>*</span> PSTACK<span>;</span>

<span>// 函数初始化</span>
<span>// 函数的元素声明可以不写函数名只写类型</span>
<span>// 初始化栈</span>
<span>void</span> <span>init</span><span>(</span>PSTACK<span>)</span><span>;</span>
<span>// 入栈，将int元素入栈</span>
<span>void</span> <span>push</span><span>(</span>PSTACK<span>,</span><span>int</span><span>)</span><span>;</span>
<span>// 判断栈是否为空，注意栈的空间没有限制</span>
bool <span>empty</span><span>(</span>PSTACK<span>)</span><span>;</span>
<span>// 遍历，将栈从pTOP至pBottom遍历并输出</span>
bool <span>traverse</span><span>(</span>PSTACK<span>)</span><span>;</span>
<span>// 出栈，由于只将最上面的元素输出并清除，所以不需要position</span>
bool <span>pop</span><span>(</span>PSTACK<span>,</span><span>int</span> <span>*</span><span>)</span><span>;</span>
<span>// 清除，将栈内的所以PNODE都清除并free掉</span>
<span>void</span> <span>clear</span><span>(</span>PSTACK<span>)</span><span>;</span>
<span>int</span> <span>main</span><span>(</span><span>)</span><span>{</span>
    STACK S<span>;</span>
    <span>int</span> val<span>;</span>
    <span>init</span><span>(</span><span>&amp;</span>S<span>)</span><span>;</span>
    <span>push</span><span>(</span><span>&amp;</span>S<span>,</span> <span>1</span><span>)</span><span>;</span>
    <span>push</span><span>(</span><span>&amp;</span>S<span>,</span> <span>2</span><span>)</span><span>;</span>
    <span>push</span><span>(</span><span>&amp;</span>S<span>,</span> <span>3</span><span>)</span><span>;</span>
    <span>push</span><span>(</span><span>&amp;</span>S<span>,</span> <span>4</span><span>)</span><span>;</span>
    <span>traverse</span><span>(</span><span>&amp;</span>S<span>)</span><span>;</span>
    <span>//出栈，val用来接收出栈的值</span>
    <span>if</span> <span>(</span><span>pop</span><span>(</span><span>&amp;</span>S<span>,</span> <span>&amp;</span>val<span>)</span><span>)</span>
        <span>printf</span><span>(</span><span>"stack output is %d\n"</span><span>,</span>val<span>)</span><span>;</span>
    <span>else</span>
        <span>printf</span><span>(</span><span>"stack output faled!\n"</span><span>)</span><span>;</span>
    <span>traverse</span><span>(</span><span>&amp;</span>S<span>)</span><span>;</span>
    <span>//清除</span>
    <span>clear</span><span>(</span><span>&amp;</span>S<span>)</span><span>;</span>
    <span>traverse</span><span>(</span><span>&amp;</span>S<span>)</span><span>;</span>
<span>}</span>
<span>void</span> <span>init</span><span>(</span>PSTACK pS<span>)</span>
<span>{</span>
    pS<span>-></span>pTop<span>=</span><span>(</span>PNODE<span>)</span><span>malloc</span><span>(</span><span>sizeof</span><span>(</span>NODE<span>)</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>pS<span>-></span>pTop<span>==</span><span>NULL</span><span>)</span><span>{</span>
        <span>printf</span><span>(</span><span>"malloc create faled!\n"</span><span>)</span><span>;</span>
        <span>exit</span><span>(</span><span>-</span><span>1</span><span>)</span><span>;</span>
    <span>}</span>
    <span>// 将pBottom和pTop都指向一个空的PNODE</span>
    pS<span>-></span>pBottom <span>=</span> pS<span>-></span>pTop<span>;</span>
    <span>// 将头指针设为NULL</span>
    pS<span>-></span>pTop<span>-></span>pNext <span>=</span> <span>NULL</span><span>;</span> <span>//也可以pS->pTop->pBottom=NULL; </span>
<span>}</span>
<span>void</span> <span>push</span><span>(</span>PSTACK pS<span>,</span> <span>int</span> val<span>)</span>
<span>{</span> <span>// 将新的pNew的data赋值并将pTop指向pNew</span>
    PNODE pNew<span>=</span><span>(</span>PNODE<span>)</span><span>malloc</span><span>(</span><span>sizeof</span><span>(</span>NODE<span>)</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>pNew<span>==</span><span>NULL</span><span>)</span>
    <span>{</span>
        <span>printf</span><span>(</span><span>"malloc crate faled!\n"</span><span>)</span><span>;</span>
        <span>exit</span><span>(</span><span>-</span><span>1</span><span>)</span><span>;</span>
    <span>}</span>
    pNew<span>-></span>data <span>=</span> val<span>;</span>
    pNew<span>-></span>pNext <span>=</span> pS<span>-></span>pTop<span>;</span>
    pS<span>-></span>pTop <span>=</span> pNew<span>;</span>
<span>}</span>
bool <span>empty</span><span>(</span>PSTACK pS<span>)</span>
<span>{</span>
    <span>if</span> <span>(</span>pS<span>-></span>pTop<span>==</span>pS<span>-></span>pBottom<span>)</span>
        <span>return</span> true<span>;</span>
    <span>else</span>
        <span>return</span> false<span>;</span>
<span>}</span>
bool <span>traverse</span><span>(</span>PSTACK pS<span>)</span>
<span>{</span><span>// 将p作为临时PNODE，当pNext不为NULL则输出data并指向下一指针</span>
    <span>if</span><span>(</span><span>empty</span><span>(</span>pS<span>)</span><span>)</span>
    <span>{</span>
        <span>printf</span><span>(</span><span>"stack is empty!\n"</span><span>)</span><span>;</span>
        <span>return</span> false<span>;</span>
    <span>}</span>
    <span>else</span>
    <span>{</span>
        PNODE p<span>=</span>pS<span>-></span>pTop<span>;</span>
        <span>while</span><span>(</span>p<span>-></span>pNext<span>!=</span><span>NULL</span><span>)</span>
        <span>{</span>
            <span>printf</span><span>(</span><span>"%d "</span><span>,</span>p<span>-></span>data<span>)</span><span>;</span>
            p<span>=</span>p<span>-></span>pNext<span>;</span>
        <span>}</span>
        <span>printf</span><span>(</span><span>"\n"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
bool <span>pop</span><span>(</span>PSTACK pS<span>,</span><span>int</span> <span>*</span> val<span>)</span>
<span>{</span><span>// 将p作为临时PNODE，将pTop给p，然后将pTop指向下一PNODE，再将p的data放入val，最后清空p</span>
    <span>if</span> <span>(</span><span>empty</span><span>(</span>pS<span>)</span><span>)</span>
    <span>{</span>
        <span>printf</span><span>(</span><span>"stack is empty!\n"</span><span>)</span><span>;</span>
        <span>return</span> false<span>;</span>
    <span>}</span>
    <span>else</span>
    <span>{</span>
        PNODE p<span>=</span>pS<span>-></span>pTop<span>;</span>
        pS<span>-></span>pTop <span>=</span> pS<span>-></span>pTop<span>-></span>pNext<span>;</span>
        <span>*</span>val <span>=</span> p<span>-></span>data<span>;</span>
        <span>// 先将内存地址free掉，再将指针设为NULL避免出现问题</span>
        <span>free</span><span>(</span>p<span>)</span><span>;</span>
        p<span>=</span><span>NULL</span><span>;</span>
    <span>}</span>
<span>}</span>
<span>void</span> <span>clear</span><span>(</span>PSTACK pS<span>)</span>
<span>{</span> <span>//将栈内所有的PNODE清除，并将pTop指向pBottom即NULL</span>
    <span>if</span> <span>(</span><span>empty</span><span>(</span>pS<span>)</span><span>)</span><span>{</span>
        <span>return</span><span>;</span>
    <span>}</span>
    <span>else</span>
    <span>{</span>
        PNODE p <span>=</span> pS<span>-></span>pTop<span>;</span>
        PNODE q<span>=</span><span>NULL</span><span>;</span>
        <span>while</span><span>(</span>p<span>!=</span>pS<span>-></span>pBottom<span>)</span>
        <span>{</span>
            q<span>=</span>p<span>-></span>pNext<span>;</span>
            <span>free</span><span>(</span>p<span>)</span><span>;</span>
            p<span>=</span>q<span>;</span>
        <span>}</span>
        pS<span>-></span>pTop<span>=</span>pS<span>-></span>pBottom<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br></div></div><h2 id="队列-线性结构的两种常用应用"> 队列 - 线性结构的两种常用应用</h2>
<h3 id="定义-3"> 定义：</h3>
<ul>
<li>一种可以实现“先进先出”的存储结构</li>
</ul>
<h3 id="分类-3"> 分类</h3>
<ul>
<li>链式队列
<ul>
<li>用链表实现</li>
</ul>
</li>
<li>静态队列
<ul>
<li>用数组实现</li>
<li>静态队列通常都必须是循环队列
<ol>
<li>
<p>静态队列为什么都是循环队列</p>
<ul>
<li>如果不使用循环队列，删除元素的就会造成浪费，前面的元素会用不了</li>
</ul>
</li>
<li>
<p>循环队列需要几个参数来确定</p>
<ul>
<li>两个参数
<ul>
<li>front（队头）</li>
<li>rear（队尾）</li>
</ul>
</li>
<li>存放元素的数组</li>
</ul>
</li>
<li>
<p>循环队列各个参数的含义</p>
<ul>
<li>两个参数再不同场合有不同的含义，可以先这样记
<ol>
<li>队列初始化
<ul>
<li>front和rear的值都是零</li>
</ul>
</li>
<li>队列非空
<ul>
<li>front代表的是队列的第一个元素</li>
<li>rear代表的是队列的最后一个有效雨啊素的下一个元素</li>
</ul>
</li>
<li>队列空
<ul>
<li>front和rear的值相等，但不一定是零</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p>循环队列入队伪算法</p>
<ul>
<li>
<p>两步完成</p>
<p><img src="./images/data_structure/Untitled_4.png" alt="./images/data_structure/Untitled_4.png" /></p>
</li>
</ul>
<ol>
<li>将值存入r所指向的位置</li>
<li>rear=(rear+1)%数组的长度
<ul>
<li>rear+1是因为循环队列正在入队（添加）所以需要+1</li>
<li>注意这里所用的取余方式
<ul>
<li>1%3=1</li>
<li>2%3=2</li>
<li>3%3=0</li>
<li>n-1%n=n</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p>循环队列出队伪算法</p>
<ul>
<li>front=(front+1)%数组的长度</li>
</ul>
</li>
<li>
<p>如何判断循环队列是否为空</p>
<ul>
<li>如果front与rear的值相等，则该队列就一定为空</li>
</ul>
</li>
<li>
<p>如何判断循环队列是否已满</p>
<ul>
<li>由于front与rear在队列中的位置不确定，可大可小可相等，所以不能用比大小的方式判断</li>
<li>两种方式
<ol>
<li>多增加一个标表志参数
<ul>
<li>独立设置一个标志，队列满为1，不满则为0</li>
</ul>
</li>
<li>少用一个元素**（常用）**
<ul>
<li>
<p>如果rear和front的值紧挨着，则队列已满</p>
</li>
<li>
<p>用C语言伪算法表示就是</p>
<div><pre><code><span>if</span> <span>(</span><span>(</span>r<span>+</span><span>1</span><span>)</span><span>%</span>数组长度 <span>==</span> f<span>)</span>
	已满
<span>else</span>
	不满
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>
<li>设定空出一个节点，当队列满时，rear则指向空的那个节点，当<code>(r+1)%数组长度</code>时，即等于front的位置</li>
</ul>
<p><img src="./images/data_structure/Untitled_5.png" alt="./images/data_structure/Untitled_5.png" /></p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="算法-2"> 算法</h3>
<ul>
<li>出队（删除一个节点）
<ul>
<li>front
<ul>
<li>front永远指向队列的头，出队则将front向上移</li>
</ul>
</li>
</ul>
</li>
<li>入队（添加一个节点）
<ul>
<li>rear
<ul>
<li>rear永远指向当前队列的下一个位置，入队则将rear向上移</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="实现-3"> 实现</h3>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>
<span><span>#</span><span>include</span> <span>&lt;malloc.h></span></span>
<span><span>#</span><span>include</span> <span>&lt;stdlib.h></span></span>
<span>// #include &lt;stdbool.h></span>
<span><span>#</span><span>define</span> <span>bool</span> <span><span>char</span></span></span>
<span><span>#</span><span>define</span> <span>true</span> <span><span>1</span></span></span>
<span><span>#</span><span>define</span> <span>false</span> <span><span>0</span></span></span>

<span>typedef</span> <span>struct</span> <span>Queue</span>
<span>{</span>
    <span>int</span> <span>*</span>pBase<span>;</span>
    <span>int</span> front<span>;</span>
    <span>int</span> rear<span>;</span>
<span>}</span>QUEUE<span>;</span>

<span>void</span> <span>init</span><span>(</span>QUEUE <span>*</span><span>)</span><span>;</span>
<span>// 入队</span>
bool <span>en_queue</span><span>(</span>QUEUE <span>*</span><span>,</span><span>int</span><span>)</span><span>;</span>
<span>// 遍历</span>
<span>void</span> <span>traverse_queue</span><span>(</span>QUEUE <span>*</span><span>)</span><span>;</span>
bool <span>full_queue</span><span>(</span>QUEUE <span>*</span><span>)</span><span>;</span>
<span>// 出队</span>
bool <span>out_queue</span><span>(</span>QUEUE <span>*</span><span>,</span><span>int</span> <span>*</span><span>)</span><span>;</span>
bool <span>empty_queue</span><span>(</span>QUEUE <span>*</span><span>)</span><span>;</span>
<span>int</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
    QUEUE Q<span>;</span>
    <span>int</span> val<span>;</span>
    <span>init</span><span>(</span><span>&amp;</span>Q<span>)</span><span>;</span>
    <span>en_queue</span><span>(</span><span>&amp;</span>Q<span>,</span> <span>1</span><span>)</span><span>;</span>
    <span>en_queue</span><span>(</span><span>&amp;</span>Q<span>,</span> <span>2</span><span>)</span><span>;</span>
    <span>en_queue</span><span>(</span><span>&amp;</span>Q<span>,</span> <span>3</span><span>)</span><span>;</span>
    <span>en_queue</span><span>(</span><span>&amp;</span>Q<span>,</span> <span>4</span><span>)</span><span>;</span>
    <span>en_queue</span><span>(</span><span>&amp;</span>Q<span>,</span> <span>5</span><span>)</span><span>;</span>
    <span>en_queue</span><span>(</span><span>&amp;</span>Q<span>,</span> <span>6</span><span>)</span><span>;</span>
    <span>traverse_queue</span><span>(</span><span>&amp;</span>Q<span>)</span><span>;</span>
    <span>if</span> <span>(</span><span>out_queue</span><span>(</span><span>&amp;</span>Q<span>,</span> <span>&amp;</span>val<span>)</span><span>)</span>
        <span>printf</span><span>(</span><span>"out queue success, value is:%d\n"</span><span>,</span>val<span>)</span><span>;</span>
    <span>else</span>
    <span>{</span>
        <span>printf</span><span>(</span><span>"out queue faled!\n"</span><span>)</span><span>;</span>
        <span>exit</span><span>(</span><span>-</span><span>1</span><span>)</span><span>;</span>
    <span>}</span>
    <span>traverse_queue</span><span>(</span><span>&amp;</span>Q<span>)</span><span>;</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
<span>void</span> <span>init</span><span>(</span>QUEUE <span>*</span>pQ<span>)</span>
<span>{</span><span>// 初始化6个空间大小的整数型数组,front和rear初始都为0</span>
    pQ<span>-></span>pBase<span>=</span><span>(</span><span>int</span><span>*</span><span>)</span><span>malloc</span><span>(</span><span>sizeof</span><span>(</span>QUEUE<span>)</span><span>*</span><span>6</span><span>)</span><span>;</span>
    pQ<span>-></span>front<span>=</span><span>0</span><span>;</span>
    pQ<span>-></span>rear<span>=</span><span>0</span><span>;</span>
<span>}</span>
bool <span>full_queue</span><span>(</span>QUEUE <span>*</span>pQ<span>)</span>
<span>{</span>
    <span>if</span> <span>(</span><span>(</span>pQ<span>-></span>rear<span>+</span><span>1</span><span>)</span><span>%</span><span>6</span><span>==</span>pQ<span>-></span>front<span>)</span>
        <span>return</span> true<span>;</span>
    <span>else</span>
        <span>return</span> false<span>;</span>
<span>}</span>
bool <span>en_queue</span><span>(</span>QUEUE <span>*</span>pQ<span>,</span><span>int</span> val<span>)</span>
<span>{</span><span>// 入队，若队满则false，否则先将val存入下标为rear的pBase，再将(rear+1)%6指向下一元素</span>
    <span>if</span><span>(</span><span>full_queue</span><span>(</span>pQ<span>)</span><span>)</span>
    <span>{</span>
        <span>return</span> false<span>;</span>
    <span>}</span>
    <span>else</span>
    <span>{</span>
        <span>// (rear+1)%6，若rear+1&lt;6则为其原本+1的数，否则rear+1=6则6%6=0</span>
        pQ<span>-></span>pBase<span>[</span>pQ<span>-></span>rear<span>]</span><span>=</span>val<span>;</span>
        pQ<span>-></span>rear <span>=</span> <span>(</span>pQ<span>-></span>rear <span>+</span> <span>1</span><span>)</span><span>%</span><span>6</span><span>;</span>
        <span>return</span> true<span>;</span>
    <span>}</span>
<span>}</span>
<span>void</span> <span>traverse_queue</span><span>(</span>QUEUE <span>*</span>pQ<span>)</span>
<span>{</span><span>// 遍历队列，用i获取队头front的下标，当i的下标不等于队尾的下标则一直循环输出pBase内的值</span>
    <span>int</span> i<span>=</span>pQ<span>-></span>front<span>;</span>
    <span>while</span><span>(</span>i<span>!=</span>pQ<span>-></span>rear<span>)</span>
    <span>{</span>
        <span>printf</span><span>(</span><span>"%d "</span><span>,</span>pQ<span>-></span>pBase<span>[</span>i<span>]</span><span>)</span><span>;</span>
        i <span>=</span> <span>(</span>i <span>+</span> <span>1</span><span>)</span><span>%</span><span>6</span><span>;</span>
    <span>}</span>
    <span>printf</span><span>(</span><span>"\n"</span><span>)</span><span>;</span>
<span>}</span>
bool <span>empty_queue</span><span>(</span>QUEUE<span>*</span>pQ<span>)</span>
<span>{</span>
    <span>if</span><span>(</span>pQ<span>-></span>rear<span>==</span>pQ<span>-></span>front<span>)</span>
        <span>return</span> true<span>;</span>
    <span>else</span>
        <span>return</span> false<span>;</span>
<span>}</span>
bool <span>out_queue</span><span>(</span>QUEUE <span>*</span> pQ<span>,</span> <span>int</span> <span>*</span>pVal<span>)</span>
<span>{</span>
    <span>if</span><span>(</span><span>empty_queue</span><span>(</span>pQ<span>)</span><span>)</span>
        <span>return</span> false<span>;</span>
    <span>else</span>
    <span>{</span>
        <span>*</span>pVal <span>=</span> pQ<span>-></span>pBase<span>[</span>pQ<span>-></span>front<span>]</span><span>;</span>
        pQ<span>-></span>front <span>=</span> <span>(</span>pQ<span>-></span>front <span>+</span> <span>1</span><span>)</span><span>%</span><span>6</span><span>;</span>
        <span>return</span> true<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br></div></div><ul>
<li>
<p>分析</p>
<ul>
<li>
<p>循环队列</p>
<ul>
<li>当前情况：front指向<code>4</code>，rear指向<code>5</code>，此时这个队列只有一个元素<code>A</code> ，因为rear是指向当前队列的下一个位置</li>
</ul>
<p><img src="./images/data_structure/Untitled_6.png" alt="./images/data_structure/Untitled_6.png" /></p>
<ul>
<li>
<p>入队：若此时入队的话，'中'字进入队列，则会将rear指向<code>0</code>，<code>5</code>的位置会变成中，此时这个循环队列有两个元素</p>
<p><img src="./images/data_structure/Untitled_7.png" alt="./images/data_structure/Untitled_7.png" /></p>
</li>
<li>
<p>出队：若此时出队的话，front会向上移，此时这个循环队列有一个元素</p>
<p><img src="./images/data_structure/Untitled_8.png" alt="./images/data_structure/Untitled_8.png" /></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>队列的具体应用</p>
<ul>
<li>所有和时间有关的操作都与队列有关</li>
</ul>
</li>
</ul>
<h2 id="递归"> 递归</h2>
<h3 id="定义-4"> 定义</h3>
<ul>
<li>
<p>一个函数自己直接或间接调用自己</p>
</li>
<li>
<p>递归要满足的三个条件</p>
<ol>
<li>递归必须得有一个明确的中止条件</li>
<li>该函数所处理的数据规模必须在递减
<ul>
<li>一般递归是在递减的，但递归的值也可以递增，但处理的规模实际上是在递减的</li>
</ul>
</li>
<li>这个转化必须是可解的</li>
</ol>
</li>
<li>
<p>循环和递归</p>
<ul>
<li>一般来说所有的递归都可以用递归实现，但递归不一定可以用循环来实现</li>
<li>递归和循环的优缺点
<ul>
<li>递归：
<ul>
<li>易于理解</li>
<li>速度慢</li>
<li>存储空间大
<ul>
<li>因为函数调用需要一直发送地址与分配地址</li>
</ul>
</li>
</ul>
</li>
<li>循环
<ul>
<li>不易理解</li>
<li>速度快</li>
<li>存储空间小</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="举例-求阶乘"> 举例 - 求阶乘</h3>
<ul>
<li>阶乘的核心就是递归用n*(n-1)，不断循环调用n-1其实就是将问题不断的缩减直至为1</li>
<li>使用循环实现递归，但由于使用int型所以不能输出大数字的递归,因为c语言没有定义长整型的长度，他只是定义长整型必须比整形大,而整形再这里只占4个字节</li>
</ul>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>

<span>int</span> <span>main</span><span>(</span><span>)</span><span>{</span>
    <span>int</span> val<span>;</span>
    <span>int</span> i<span>,</span>mult<span>=</span><span>1</span><span>;</span>
    <span>printf</span><span>(</span><span>"please input a number: val= "</span><span>)</span><span>;</span>
    <span>scanf</span><span>(</span><span>"%d"</span><span>,</span><span>&amp;</span>val<span>)</span><span>;</span>
    <span>for</span><span>(</span>i<span>=</span><span>1</span><span>;</span>i<span>&lt;</span>val<span>;</span><span>++</span>i<span>)</span>
    <span>{</span>
        mult<span>=</span>mult<span>*</span>i<span>;</span>
    <span>}</span>
    <span>printf</span><span>(</span><span>"%d! is: %d\n"</span><span>,</span>val<span>,</span>mult<span>)</span><span>;</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="举例-1-2-3-4-···-100的和-多个数字的相加"> 举例 - 1+2+3+4+···+100的和（多个数字的相加）</h3>
<ul>
<li>与阶乘一样，核心就是递归用n+(n-1)，不断循环调用n-1其实就是将问题不断的缩减直至为1</li>
</ul>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>

<span>// sum(n)，实现n个数相加</span>
<span>int</span> <span>sum</span><span>(</span><span>int</span> n<span>)</span>
<span>{</span>
    <span>if</span> <span>(</span><span>1</span><span>==</span>n<span>)</span>
        <span>return</span> <span>1</span><span>;</span>
    <span>else</span>
        <span>return</span> <span>f</span><span>(</span>n<span>-</span><span>1</span><span>)</span><span>+</span>n<span>;</span>
<span>}</span>
<span>int</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
    <span>printf</span><span>(</span><span>"%d"</span><span>,</span><span>sum</span><span>(</span><span>100</span><span>)</span><span>)</span><span>;</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="举例-汉诺塔"> 举例 - 汉诺塔</h3>
<p><a href="https://blog.csdn.net/nvd11/article/details/8865683" target="_blank" rel="noopener noreferrer">汉诺塔递归的c语言实现(递归)</a></p>
<ul>
<li>ABC三个柱子可以看为栈，因为每次只能移动一个，而且是顶上的，就像是栈顶那样</li>
<li>汉诺塔的实现主要核心是伪代码的部分，就像是核心一样</li>
</ul>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>

<span>int</span> <span>hannuota</span><span>(</span><span>int</span> n<span>,</span><span>char</span> A<span>,</span><span>char</span> B<span>,</span><span>char</span> C<span>)</span>
<span>{</span>
    <span>/*伪算法部分【盘分为`n`与`n-1`两个】
    如果是1个盘子
        将A柱的盘从A移动到C
    否则
        先将A柱上的n-1个盘从A借助C移动到B
        将A柱上的n盘从A移动到C
        最后将B柱上的n-1个盘从B借助A移动到C
    */</span>
    <span>if</span><span>(</span><span>1</span><span>==</span>n<span>)</span>
        <span>printf</span><span>(</span><span>"move %d: %c -> %c\n"</span><span>,</span>n<span>,</span>A<span>,</span>C<span>)</span><span>;</span>
    <span>else</span>
    <span>{</span>
        <span>// n=1，从A借助C移动到B上</span>
        <span>hannuota</span><span>(</span>n<span>-</span><span>1</span><span>,</span>A<span>,</span>C<span>,</span>B<span>)</span><span>;</span>
        <span>// 将n从A移动到C上</span>
        <span>printf</span><span>(</span><span>"move %d: %c -> %c\n"</span><span>,</span>n<span>,</span>A<span>,</span>C<span>)</span><span>;</span>
        <span>// 将n-1从B借助A移动到C上</span>
        <span>hannuota</span><span>(</span>n<span>-</span><span>1</span><span>,</span>B<span>,</span>A<span>,</span>C<span>)</span><span>;</span>

    <span>}</span>
<span>}</span>
<span>int</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
    <span>int</span> n<span>;</span>
    <span>printf</span><span>(</span><span>"please input number:"</span><span>)</span><span>;</span>
    <span>scanf</span><span>(</span><span>"%d"</span><span>,</span><span>&amp;</span>n<span>)</span><span>;</span>
    <span>printf</span><span>(</span><span>"\n"</span><span>)</span><span>;</span>
    <span>hannuota</span><span>(</span>n<span>,</span><span>'A'</span><span>,</span><span>'B'</span><span>,</span><span>'C'</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><h3 id="举例-走迷宫"> 举例 - 走迷宫</h3>
<h3 id="递归的应用"> 递归的应用</h3>
<ul>
<li>树和森林就是以递归的方式定义的</li>
<li>数和图的很多算法都是以递归来实现的</li>
<li>很多数学公式就是以递归的方式定义的</li>
</ul>
<h3 id="应用-斐波那契数列"> 应用 - 斐波那契数列</h3>
<ul>
<li>核心的公式是：当<code>n≤2时{n=1}，n&gt;2时{F(n-1)+F(n-2)}</code>
<ul>
<li>后一项是前n项的和</li>
</ul>
</li>
</ul>
<p><a href="https://blog.csdn.net/cherrydreamsover/article/details/80026343" target="_blank" rel="noopener noreferrer">斐波那契数列的四种实现方式cherrydreamsover的博客</a></p>
<ul>
<li>
<p>递归</p>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>

<span>// 递归实现斐波那契数列，核心公式是F(n-1)+F(n-2)</span>
<span>int</span> <span>fibon</span><span>(</span><span>int</span> n<span>)</span>
<span>{</span>
    <span>// 也可以是if(n&lt;=2)</span>
		<span>// 当n为3，f(2)+f(1)=1+1=2</span>
		<span>// 当n为4,f(3)+f(2)=[f(2)+f(1)]+f(2)=2+1=3</span>
    <span>if</span><span>(</span>n<span>&lt;=</span><span>2</span><span>)</span>
    <span>{</span>
        <span>return</span> <span>1</span><span>;</span>
    <span>}</span>
    <span>else</span>
    <span>{</span>
        <span>return</span> <span>fibon</span><span>(</span>n<span>-</span><span>1</span><span>)</span><span>+</span><span>fibon</span><span>(</span>n<span>-</span><span>2</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>int</span> <span>main</span><span>(</span><span>)</span><span>{</span>
    <span>int</span> n<span>,</span> result<span>;</span>
    <span>printf</span><span>(</span><span>"please input number:"</span><span>)</span><span>;</span>
    <span>scanf</span><span>(</span><span>"%d"</span><span>,</span><span>&amp;</span>n<span>)</span><span>;</span>
    <span>printf</span><span>(</span><span>"\n"</span><span>)</span><span>;</span>
    result <span>=</span> <span>fibon</span><span>(</span>n<span>)</span><span>;</span>
    <span>printf</span><span>(</span><span>"fibon result is :%d"</span><span>,</span>result<span>)</span><span>;</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div></li>
</ul>
<h1 id="非线性结构"> 非线性结构</h1>
<h2 id="树"> 树</h2>
<h3 id="树定义"> 树定义</h3>
<ul>
<li>专业定义
<ol>
<li>有且只有一个称为根的节点</li>
<li>有若干个互不相交的子树，这些子树本身也是一棵树</li>
</ol>
</li>
<li>通俗的定义
<ol>
<li>树是由节点和边组成</li>
<li>每个节点只有一个父节点，但可以有多个子节点</li>
<li>但有一个节点例外，该节点没有父节点，此节点称为根节点</li>
</ol>
</li>
</ul>
<h3 id="术语"> 术语</h3>
<ul>
<li>节点
<ul>
<li>严格可表示为哪一个具体的树</li>
</ul>
</li>
<li>父节点
<ul>
<li>最上面与其紧挨着的（父）节点</li>
</ul>
</li>
<li>子节点
<ul>
<li>其下面所有的节点（子孙）</li>
</ul>
</li>
<li>深度
<ul>
<li>从根节点到最底层节点的层数称之为深度</li>
<li>根节点是第一层</li>
</ul>
</li>
<li>叶子节点
<ul>
<li>没有子节点的节点</li>
</ul>
</li>
<li>非终端节点
<ul>
<li>实际就是非叶子节点（有子节点的节点）</li>
<li>根节点既可以是叶子节点也可以是非叶子节点</li>
</ul>
</li>
<li>度
<ul>
<li>子节点的个数称之为度</li>
<li>若一子节点下有三个子节点，就称这个节点有3个度</li>
<li>树的度是整个树含有最大子节点的度数为整个树的度</li>
</ul>
</li>
</ul>
<h3 id="树分类"> 树分类</h3>
<h4 id="一般树"> 一般树</h4>
<ul>
<li>任意一个子节点的个数都不受限制，一般的树都是无序的</li>
<li>一般的树可以是有序的树也可以是无序的，但二叉树一定是有序的树</li>
</ul>
<h4 id="二叉树"> 二叉树</h4>
<ul>
<li>
<p>任意一个子节点的个数最多两个，且子节点的位置不可更改</p>
<ul>
<li>任一子节点可以有一个也可以有两个，节点的顺序不能改变.二叉树是有序的树</li>
</ul>
<p><img src="./images/data_structure/Untitled_9.png" alt="./images/data_structure/Untitled_9.png" /></p>
</li>
<li>
<p>二叉树的分类</p>
<ul>
<li>
<p>一般二叉树</p>
</li>
<li>
<p>满二叉树</p>
<ul>
<li>每一层都是最大的；在不增加层数的前提下，无法再多添加一个节点的二叉树就是满二叉树</li>
</ul>
<p><img src="./images/data_structure/Untitled_10.png" alt="./images/data_structure/Untitled_10.png" /></p>
</li>
<li>
<p>完全二叉树⛳</p>
<ul>
<li>完全二叉树是路径最短的二叉树，但路径最短的二叉树不一定是完全二叉树</li>
<li>如果只是删除了满二叉树最底层最右边的连续若干个节点，这样形成的二叉树就是完全二叉树
<ul>
<li>用数组实现二叉树必须是完全二叉树，在删除节点的时候必须从最地层从右往左删</li>
<li>满二叉树是完全二叉树的一个特例，完全二叉树包含了满二叉树</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="森林"> 森林</h4>
<ul>
<li>n个互不相交的树的集合，将下图的三个树叫做一个整体的话就是一个森林</li>
</ul>
<p><img src="./images/data_structure/Untitled_11.png" alt="./images/data_structure/Untitled_11.png" /></p>
<h3 id="树的存储"> 树的存储</h3>
<h4 id="二叉树的存储"> <strong>二叉树的存储</strong></h4>
<ul>
<li>
<p>存储问题 详细</p>
<p>由于二叉树不是线性结构，由于计算机是线性的存储结构，所以要其以线性结构的方式保存，首先将其转换为完全二叉树，补完完全二叉树的节点，还原其完整的样子，得到其框架后保存，使用时再将补齐的部分删除（绿色为有效数据，蓝色为补充的框架）</p>
<p><img src="./images/data_structure/Untitled_12.png" alt="./images/data_structure/Untitled_12.png" /></p>
</li>
</ul>
<p>最核心的是以二叉树来存储，一般树与二叉树都是转换为二叉树来存储，因为二叉树的算法比较成熟</p>
<ul>
<li><strong>连续存储（完全二叉树）</strong>
<ul>
<li>优点
<ul>
<li>查找某个节点的父节点和子节点（也包括判断有没有子节点）速度很快</li>
</ul>
</li>
<li>缺点
<ul>
<li>耗用内存空间过大</li>
</ul>
</li>
</ul>
</li>
<li>链式存储</li>
</ul>
<h3 id="一般树的存储"> 一般树的存储</h3>
<ul>
<li>
<p>双亲表示法</p>
<ul>
<li>求父节点方便</li>
</ul>
</li>
<li>
<p>孩子表示法</p>
<ul>
<li>求子节点方便</li>
</ul>
</li>
<li>
<p>双亲孩子表示法</p>
<ul>
<li>求父节点和子节点都很方便</li>
</ul>
</li>
<li>
<p>二叉树表示法</p>
<ul>
<li>把一个普通树转化成二叉树来存储</li>
<li>具体转换方法
<ul>
<li>左指针域指向它的第一个孩子</li>
<li>右指针域指向它的堂兄弟</li>
</ul>
</li>
<li>只要满足此条件，就可以把一个普通树转换成二叉树</li>
<li>一个普通树转化成的二叉树一定没有右子树</li>
</ul>
<p><img src="./images/data_structure/Untitled_13.png" alt="./images/data_structure/Untitled_13.png" /></p>
</li>
</ul>
<h3 id="森林的存储"> 森林的存储</h3>
<ul>
<li>先把森林转化为二叉树，再存储二叉树</li>
<li>将多个树合在一起存储，存储多个树时，把其他树当作兄弟来存储即可</li>
</ul>
<p><img src="./images/data_structure/Untitled_14.png" alt="./images/data_structure/Untitled_14.png" /></p>
<h3 id="树的操作-二叉树的遍历"> 树的操作 - 二叉树的遍历</h3>
<h4 id="先序遍历"> 先序遍历</h4>
<ul>
<li>
<p>遍历顺序（先访问根节点）</p>
<ul>
<li>先访问根节点</li>
<li>再先序访问左子树</li>
<li>再先序访问右子树</li>
</ul>
</li>
<li>
<p>举个例子</p>
<p><img src="./images/data_structure/Untitled_15.png" alt="./images/data_structure/Untitled_15.png" /></p>
<ul>
<li>A-B-D-C-E-F-G</li>
</ul>
<p><img src="./images/data_structure/Untitled_16.png" alt="./images/data_structure/Untitled_16.png" /></p>
<ul>
<li>A-B-C-D-E-F-L-Q-M-N-S</li>
</ul>
<p><img src="./images/data_structure/Untitled_17.png" alt="./images/data_structure/Untitled_17.png" /></p>
<ul>
<li>A-B-Q-L-C-D-G-E-F</li>
</ul>
</li>
</ul>
<h4 id="中序遍历"> 中序遍历</h4>
<ul>
<li>
<p>遍历顺序（中间访问根节点）</p>
<ul>
<li>中序遍历左子树</li>
<li>再访问根节点</li>
<li>再中序遍历右子树</li>
</ul>
</li>
<li>
<p>举个例子</p>
<p><img src="./images/data_structure/Untitled_18.png" alt="./images/data_structure/Untitled_18.png" /></p>
<ul>
<li>B-D-C-E-A-C-F-N-Q-M
<ul>
<li>此处N后面可能会有点疑惑，这里解释下，因为到了MNQ这个子树，所以先判断M的左子树，即NQ树，首先遍历N的左子树（空），再遍历根节点（N），再遍历右子树（Q），再回头访问这个根节点（M），由于没有右子树，所以为空</li>
</ul>
</li>
</ul>
<p><img src="./images/data_structure/Untitled_19.png" alt="./images/data_structure/Untitled_19.png" /></p>
<ul>
<li>B-C-D-A-M-Q-E-L-N</li>
</ul>
</li>
</ul>
<h4 id="后序遍历"> 后序遍历</h4>
<ul>
<li>
<p>遍历顺序（最后访问根节点）</p>
<ul>
<li>后续遍历左子树</li>
<li>再后续遍历右子树</li>
<li>再访问根节点</li>
</ul>
</li>
<li>
<p>举个例子</p>
<p><img src="./images/data_structure/Untitled_20.png" alt="./images/data_structure/Untitled_20.png" /></p>
<ul>
<li>B-D-M-F-L-E-C-A</li>
</ul>
<p><img src="./images/data_structure/Untitled_21.png" alt="./images/data_structure/Untitled_21.png" /></p>
<ul>
<li>N-W-T-S-F-P-L-Q-M</li>
</ul>
</li>
</ul>
<h3 id="已知两种遍历序列求原始二叉树"> 已知两种遍历序列求原始二叉树</h3>
<ul>
<li>通过<strong>先序和中序</strong>或者<strong>中序和后序</strong>，我们可以还原出原始的二叉树，但是通过先序和后续是无法还原出原始的二叉树的。</li>
<li>也就是说：只有通过先序和中序或中序和后续我们才可以唯一的确定一个二叉树</li>
</ul>
<h4 id="已知先序和中序求后序"> 已知先序和中序求后序</h4>
<ol>
<li>先序的第一个字母（A）一定是根节点</li>
<li>中序遍历在A左边的字母（BDCE）是左子树，右边是右子树（FHG）</li>
<li>重复1、2的操作</li>
</ol>
<ul>
<li>例1
<ul>
<li>先序：ABCDEFGH</li>
<li>中序：BDCEAFHG</li>
<li>求后序：DECBHGFA
<ul>
<li>
<p>先还原出二叉树</p>
<ul>
<li>
<p>先序第一个字母A，即为根节点，中序里A的左边BCDE是左子树，右边FHG是右子树</p>
</li>
<li>
<p>先序第二个是B，中序第一个是B，即根节点的左子树的根是B，也因为中序第一个是B所以没有左子树</p>
</li>
<li>
<p>B的右子树剩下CDE，由于先序是CDE（C为根），中序是DCE（D在DE中间，即D为C的左子树，E为D的右子树），所以左子树的顺序就出来了</p>
<p><img src="./images/data_structure/24566B02-7154-459D-BC32-6FE22BA16CA7.jpeg" alt="./images/data_structure/24566B02-7154-459D-BC32-6FE22BA16CA7.jpeg" /></p>
</li>
<li>
<p>剩下FGH就是A的右子树，先序是FGH，中序是FHG，所以F是右子树的根节点</p>
</li>
<li>
<p>由于中序里是FHG，F左边没有内容所以GH是F的右子树，因为先序是GH，所以G为根节点</p>
</li>
<li>
<p>中序中由于H在G的左边所以H是G的左子树</p>
</li>
</ul>
</li>
<li>
<p>原始二叉树：</p>
<p><img src="./images/data_structure/3E809A58-C95B-4B8F-8139-880E12F3A6E0.jpeg" alt="./images/data_structure/3E809A58-C95B-4B8F-8139-880E12F3A6E0.jpeg" /></p>
</li>
<li>
<p>所以后序的顺序是：DECBHGFA</p>
</li>
</ul>
</li>
</ul>
</li>
<li>例2
<ul>
<li>
<p>先序：ABDGHCEFI</p>
</li>
<li>
<p>中序：GDHBAECIF</p>
</li>
<li>
<p>后序：GHDBEIFCA</p>
</li>
<li>
<p>原始二叉树</p>
<p><img src="./images/data_structure/8CF4D816-9563-4858-BF66-4433D577954C.jpeg" alt="./images/data_structure/8CF4D816-9563-4858-BF66-4433D577954C.jpeg" /></p>
</li>
<li>
<p>这里由于例1所以简单描述</p>
<ol>
<li>先序的A在中序中就可以判断GDHB是A的左子树，ECIF是A的右子树</li>
<li>AB的B在中序中是GDHB，由于中序的B右边没其他了所以可以确定GDH是B的左子树</li>
<li>看先序中ABD，D在GH前面，中序是GDH，就可以判断D是GH的根节点，且D的左子树是G，H是D的右子树至此A的左子树已完成遍历</li>
<li>看A的右子树ECIF对应先序的CEFI，先序中C在前，中序中C在E和IF的中间，所以C是EIF的根节点，且E为左子树，IF为右子树</li>
<li>剩下IF，由于先序是FI，所以F是I的根节点，中序是IF，I在F的左边所以I是F的左子树</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="已知中序和后序求先序"> 已知中序和后序求先序</h4>
<ul>
<li>
<p>由于没有好的总结所以这里稍微写下</p>
<ul>
<li>后序最后面的即整个树的根节点，然后看其在中序中的位置，即可分开树的左子树与右子树</li>
<li>然后由于后序是后遍历左子树再后遍历右子树再访问根节点，所以能得出左右子树的上下层逻辑关系</li>
<li>然后再通过中序的左右位置判断其左右子树的关系</li>
</ul>
</li>
<li>
<p>例1</p>
<ul>
<li>中序：BDCEAFHG</li>
<li>后序：DECBHGFA</li>
<li>求先序：ABCDEFGH1</li>
</ul>
<p><img src="./images/data_structure/Untitled_22.png" alt="./images/data_structure/Untitled_22.png" /></p>
<ul>
<li>顺序
<ol>
<li>后序A在最后所以A是根节点，所以中序的BDCE是A的左子树，FHG是A的右子树</li>
<li>然后看后序DECB的B在最后，再看中序是从B开始所以B是DEC的根节点，且在中序中DCE在B的右边所以DCE是B的右子树</li>
<li>后序中DEC，中序是DCE，所以DE可以说C的子树，且中序是DCE所以D是C的左子树，E是C的右子树，至此A的左子树已经遍历完成</li>
<li>右子树中FHG后序是HGF，所以F是右子树的根，后序顺序是HGF，所以H是G的子树，G是F的子树，再看中序HG在F的右边，所以G是F的右子树，H在G的左边，所以H是G的左子树</li>
</ol>
</li>
</ul>
</li>
<li>
<p>例2</p>
<ul>
<li>中序：GDHBAECIF</li>
<li>后序：GHDBEIFCA</li>
<li>求先序：ABDGHCEFI</li>
<li>这里简略说下，右子树中从后序来看可以看出关系是C&gt;EIF，F&gt;IE，从中序可以看出E是C的左子树，IF是C的右子树，所以F&gt;I，即I是F的左子树</li>
</ul>
</li>
</ul>
<h3 id="树的应用"> 树的应用</h3>
<ul>
<li>树是数据库中数据组织的一种重要形式</li>
<li>操作系统子父进程的关系本身就是一棵树</li>
<li>面向对象语言中类的集成关系</li>
<li>赫夫曼树</li>
</ul>
<h3 id="实现【待】"> 实现【待】</h3>
<h2 id="图"> 图</h2>
<ul>
<li>由于教程没有图，所以额外补上</li>
</ul>
<p><a href="https://www.bilibili.com/video/BV1nJ411V7bd" target="_blank" rel="noopener noreferrer">跳转链接</a></p>
<h3 id="数据的逻辑结构"> 数据的逻辑结构</h3>
<ul>
<li>集合：数据元素间除“同属于一个集合”外，无其他关系</li>
<li>线性结构：一个对一个，如线性表、栈、队列</li>
<li>树形结构：一个对多个，如树</li>
<li>图形结构：多个对多个</li>
</ul>
<h3 id="图的定义"> 图的定义</h3>
<ul>
<li>图：G=（V, E）
<ul>
<li>V：定点（数据元素）的有穷非空集合</li>
<li>E：边的有穷集合</li>
</ul>
</li>
<li>无向图：每条边都是无方向的</li>
<li>有向图：每条边都是有方向的</li>
</ul>
<p><img src="./images/data_structure/Untitled_23.png" alt="./images/data_structure/Untitled_23.png" /></p>
<ul>
<li>
<p>完全图：任意两个点都有一条边相连</p>
<ul>
<li>无向完全图：n个顶点，<code>n(n-1)/2</code>条边</li>
<li>有向完全图：n个顶点，<code>n(n-1)</code>条边</li>
</ul>
<p><img src="./images/data_structure/Untitled_24.png" alt="./images/data_structure/Untitled_24.png" /></p>
</li>
<li>
<p>稀疏图：有很少边或弧的图（e&lt;nlogn）</p>
</li>
<li>
<p>稠密图：有较多边或弧的图</p>
</li>
<li>
<p>网：边/弧带<strong>权</strong>的图（带值的边/弧）</p>
</li>
<li>
<p>邻接：有边/弧相连的<strong>两个顶点</strong>之间的关系</p>
<ul>
<li>存在<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1.036108em;vertical-align:-0.286108em;"></span><span>(</span><span><span style="margin-right:0.03588em;">v</span><span><span><span><span style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>,</span><span style="margin-right:0.16666666666666666em;"></span><span><span style="margin-right:0.03588em;">v</span><span><span><span><span style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span style="margin-right:0.05724em;">j</span></span></span></span><span>​</span></span><span><span style="height:0.286108em;"><span></span></span></span></span></span></span><span>)</span></span></span></span> ，则称<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.716668em;vertical-align:-0.286108em;"></span><span><span style="margin-right:0.03588em;">v</span><span><span><span><span style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>,</span><span style="margin-right:0.16666666666666666em;"></span><span><span style="margin-right:0.03588em;">v</span><span><span><span><span style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span style="margin-right:0.05724em;">j</span></span></span></span><span>​</span></span><span><span style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 互为<strong>邻接点</strong>
<ul>
<li>无向图，<code>( )</code>表示不分先后</li>
</ul>
</li>
<li>存在<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.5782em;vertical-align:-0.0391em;"></span><span>&lt;</span><span style="margin-right:0.2777777777777778em;"></span></span><span><span style="height:0.8252079999999999em;vertical-align:-0.286108em;"></span><span><span style="margin-right:0.03588em;">v</span><span><span><span><span style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>,</span><span style="margin-right:0.16666666666666666em;"></span><span><span style="margin-right:0.03588em;">v</span><span><span><span><span style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span style="margin-right:0.05724em;">j</span></span></span></span><span>​</span></span><span><span style="height:0.286108em;"><span></span></span></span></span></span></span><span style="margin-right:0.2777777777777778em;"></span><span>&gt;</span></span></span></span> ，则称<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.58056em;vertical-align:-0.15em;"></span><span><span style="margin-right:0.03588em;">v</span><span><span><span><span style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> <strong>邻接到</strong><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.716668em;vertical-align:-0.286108em;"></span><span><span style="margin-right:0.03588em;">v</span><span><span><span><span style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span style="margin-right:0.05724em;">j</span></span></span></span><span>​</span></span><span><span style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>, <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.716668em;vertical-align:-0.286108em;"></span><span><span style="margin-right:0.03588em;">v</span><span><span><span><span style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span style="margin-right:0.05724em;">j</span></span></span></span><span>​</span></span><span><span style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> <strong>邻接于 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.58056em;vertical-align:-0.15em;"></span><span><span style="margin-right:0.03588em;">v</span><span><span><span><span style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></strong>
<ul>
<li>有向图，<code>&lt; &gt;</code> 表示分先后顺序，从<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.58056em;vertical-align:-0.15em;"></span><span><span style="margin-right:0.03588em;">v</span><span><span><span><span style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="margin-right:0.2777777777777778em;"></span><span>→</span><span style="margin-right:0.2777777777777778em;"></span></span><span><span style="height:0.716668em;vertical-align:-0.286108em;"></span><span><span style="margin-right:0.03588em;">v</span><span><span><span><span style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span style="margin-right:0.05724em;">j</span></span></span></span><span>​</span></span><span><span style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></li>
</ul>
</li>
</ul>
</li>
<li>
<p>关联（依附）：边/弧与顶点之间的关系</p>
</li>
<li>
<p>顶点的度：与该顶点相关联的边的树木，记为TD(v)</p>
<ul>
<li>
<p>在<strong>有向图</strong>中，顶点的度等于该顶点的<strong>入度</strong>与<strong>出度</strong>之和</p>
<ul>
<li>顶点b的入度时以b为<strong>终点</strong>的有向边的条数，记作ID(v)</li>
<li>顶点v的出度是以v为<strong>始点</strong>的有向边的条数，记作OD(v)</li>
</ul>
</li>
<li>
<p>例：图中各顶点的度</p>
<p><img src="./images/data_structure/Untitled_25.png" alt="./images/data_structure/Untitled_25.png" /></p>
</li>
</ul>
</li>
<li>
<p>例题</p>
<p>问：当有向图中仅1个顶点的入度为0其余顶点的入度均为1,此时是何形状？答：是树！而且是一棵有向树！</p>
<p><img src="./images/data_structure/Untitled_26.png" alt="./images/data_structure/Untitled_26.png" /></p>
</li>
<li>
<p>路径：接续的边构成的顶点序列</p>
</li>
<li>
<p>路径长度：路径上边或弧的数目/权值之和</p>
</li>
</ul>
<p><img src="./images/data_structure/Untitled_27.png" alt="./images/data_structure/Untitled_27.png" /></p>
<ul>
<li>回路(环)：第一个顶点和最后一个顶点相同的路径
<ul>
<li>0→1→2→0</li>
</ul>
</li>
<li>简单路径：除路径起点和终点可以相同外，其余顶点均不相同的路径
<ul>
<li>0→1→3→2</li>
<li>非简单路径：0和1出现了两次所以是非简单路径</li>
</ul>
</li>
<li>简单回路(简单环)：除路径起点和终点相同外，其余顶点均不相同的路径</li>
</ul>
<p><img src="./images/data_structure/Untitled_28.png" alt="./images/data_structure/Untitled_28.png" /></p>
<ul>
<li>
<p>连通图（强连通图）</p>
<ul>
<li>在无（有）向图G=（V, {E}）中，若对任何两个顶点v、u都存在从v到u的路径，则称G是<strong>连通图</strong>（强连通图）</li>
</ul>
<p><img src="./images/data_structure/Untitled_29.png" alt="./images/data_structure/Untitled_29.png" /></p>
</li>
<li>
<p>权与网</p>
<ul>
<li>图中边或弧所具有的相关数称为权。标明从一个顶点到另一个顶点的距离或耗费</li>
<li>带权的图称为网</li>
</ul>
</li>
<li>
<p>子图</p>
<ul>
<li>
<p>设有两个图G=(V, {E})、G1=(V1, {E1})，若<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8193em;vertical-align:-0.13597em;"></span><span style="margin-right:0.22222em;">V</span><span>1</span><span style="margin-right:0.2777777777777778em;"></span><span>⊆</span><span style="margin-right:0.2777777777777778em;"></span></span><span><span style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span style="margin-right:0.22222em;">V</span><span>,</span><span style="margin-right:0.16666666666666666em;"></span><span style="margin-right:0.05764em;">E</span><span>1</span><span style="margin-right:0.2777777777777778em;"></span><span>⊆</span><span style="margin-right:0.2777777777777778em;"></span></span><span><span style="height:0.68333em;vertical-align:0em;"></span><span style="margin-right:0.05764em;">E</span></span></span></span>则称G1是G的子图</p>
<ul>
<li>例：(b), (c)是(a)的子图</li>
</ul>
<p><img src="./images/data_structure/Untitled_30.png" alt="./images/data_structure/Untitled_30.png" /></p>
</li>
</ul>
</li>
<li>
<p>连通分量（强连通分量）</p>
<ul>
<li>
<p>无向图G的<strong>极大连通子图</strong>称为G的<strong>连通分量</strong></p>
<ul>
<li>极大连通子图意思是：该子图是G连通子图，将G的任何不在该子图中的顶点加入，子图不再连通</li>
</ul>
<p><img src="./images/data_structure/Untitled_31.png" alt="./images/data_structure/Untitled_31.png" /></p>
</li>
<li>
<p>强连通分量</p>
<ul>
<li>
<p>有向图G的<strong>极大强连通子图</strong>称为G的<strong>强连通分量</strong></p>
<ul>
<li>极大强连通子图意思是：该子图是G的强连通子图，将D的任何不在该子图中的顶点加入，子图不再是强连通的</li>
</ul>
<p><img src="./images/data_structure/Untitled_32.png" alt="./images/data_structure/Untitled_32.png" /></p>
</li>
</ul>
</li>
<li>
<p>极小连通子图：该子图是G的连通子图，在该子图中删除一条边1子图都不再连通</p>
</li>
<li>
<p>生成树：包含无向图G所以顶点的极小连通子图</p>
</li>
<li>
<p>生成森林：对非连通图，由各个连通分量的生成树的集合</p>
</li>
</ul>
<p><img src="./images/data_structure/Untitled_33.png" alt="./images/data_structure/Untitled_33.png" /></p>
</li>
</ul>
<h3 id="图的抽象类型定义"> 图的抽象类型定义</h3>
<ul>
<li>
<p>图的抽象数据类型定义如下：</p>
<div><pre><code>ADT Graph<span>{</span>
	数据对象V<span>:</span>具有相同特性的数据元素的集合，称为顶点集
	数据关系R<span>:</span>R<span>=</span><span>{</span>VR<span>}</span>
		VR<span>=</span><span>{</span><span>&lt;</span>V<span>,</span>W<span>></span><span>|</span><span>&lt;</span>V<span>,</span>W<span>></span><span>|</span>V<span>,</span>W∈V<span>^</span><span>p</span><span>(</span>V<span>,</span>W<span>)</span><span>,</span>
			<span>&lt;</span>V<span>,</span>W<span>></span>表示从V到W的弧，<span>P</span><span>(</span>V<span>,</span>W<span>)</span>定义了弧<span>&lt;</span>V<span>,</span>W<span>></span>的信息
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
<li>
<p>基本操作</p>
<div><pre><code>基础操作P：
	<span>Create_Graph</span><span>(</span><span>)</span>：图的创建操作
		初始条件：无
		操作结果：生成一个没有顶点的空图G
	GetVex（G<span>,</span>v）：求图中的顶点v的值
		初始条件：图G存在，v是图中的一个顶点
		操作结果：生成一个没有顶点的空图G
	······
	<span>CreateGraph</span><span>(</span><span>&amp;</span>G<span>,</span>V<span>,</span>VR<span>)</span>
		初始条件：V是图的顶点集，VR是图中弧的集合
		操作结果：按V和VR的定义构造图G
	<span>DFSTraverse</span><span>(</span>G<span>)</span>
		初始条件：图G存在
		操作结果：对图进行深度优先遍历
	<span>BFSTraverse</span><span>(</span>G<span>)</span>
		初始条件：图G存在
		操作结果：对图进行广度优先遍历
<span>}</span>ADT Graph
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div></li>
</ul>
<h3 id="图的存储结构"> 图的存储结构</h3>
<ul>
<li>图的逻辑结构：多对多
<ul>
<li>数组表示法（临界矩阵）：图没有顺序存储结构，但可以借助二维数组来表示元素间的关系</li>
<li>链式存储结构
<ul>
<li>多重链表
<ul>
<li>邻接表</li>
<li>邻接多重表</li>
<li>十字链表</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>重点：
<ul>
<li>邻接矩阵（数组）表示法</li>
<li>邻接表（链式）表示法</li>
</ul>
</li>
</ul>
<h3 id="邻接矩阵"> 邻接矩阵</h3>
<h4 id="数组-邻接矩阵-表示法"> 数组（邻接矩阵）表示法</h4>
<ul>
<li>
<p>建立一个顶点表（记录各个顶点信息）和一个邻接矩阵（表示各个顶点之间关系）</p>
<p><img src="./images/data_structure/Untitled_34.png" alt="./images/data_structure/Untitled_34.png" /></p>
</li>
<li>
<p>无向图的邻接矩阵表示法</p>
<ul>
<li>两个顶点之间如果有边（两个顶点是邻接关系），则邻接矩阵的值为1，反之为0
<ul>
<li>可以看到对角线上都为零，因为没有指向自身，且此矩阵是对称矩阵</li>
</ul>
</li>
<li>总结
<ol>
<li>无向图的邻接矩阵是对称的</li>
<li>顶点i的度=第i行（列）中1的个数</li>
</ol>
</li>
</ul>
<p><img src="./images/data_structure/Untitled_35.png" alt="./images/data_structure/Untitled_35.png" /></p>
<p><img src="./images/data_structure/Untitled_36.png" alt="./images/data_structure/Untitled_36.png" /></p>
</li>
<li>
<p>完全图的话，除了自身其余都为1</p>
<ul>
<li>完全图的邻接矩阵中，对角元素为0，其余</li>
</ul>
</li>
</ul>
<p><img src="./images/data_structure/Untitled_37.png" alt="./images/data_structure/Untitled_37.png" /></p>
<ul>
<li>
<p>有向图的邻接矩阵表示法</p>
<ul>
<li>顶点指向的顶点对应行的顶点置为1</li>
<li>不是对称的矩阵</li>
<li>行为出度，列为入度</li>
<li>总结：
<ol>
<li>有向图的邻接矩阵可能是不对称的</li>
<li>顶点的出度=第i行元素之和</li>
<li>顶点的入读=第i列元素之和</li>
<li>顶点的度=第i行元素之和+第i列元素之和</li>
</ol>
</li>
</ul>
<p><img src="./images/data_structure/Untitled_38.png" alt="./images/data_structure/Untitled_38.png" /></p>
</li>
<li>
<p>网（即有权图）的邻接矩阵表示法</p>
<ul>
<li>顶点指向的顶点对应行的顶点置为权值的大小，没有被值的顶点则置为无穷</li>
</ul>
<p><img src="./images/data_structure/Untitled_39.png" alt="./images/data_structure/Untitled_39.png" /></p>
</li>
</ul>
<h4 id="邻接矩阵的建立"> 邻接矩阵的建立</h4>
<ul>
<li>
<p>邻接矩阵的存储表示：用两个数组分别存储顶点表和邻接矩阵</p>
<div><pre><code><span><span>#</span><span>define</span> <span>MVNum</span> <span><span>100</span></span><span>//最大定点数</span></span>
<span>typedef</span> <span>char</span> VerTexType<span>;</span><span>//设顶点的数据类型为字符型</span>
<span>typedef</span> <span>int</span> ArcType<span>;</span><span>//假设边的权值类型为整型</span>

<span>typedef</span> <span>struct</span><span>{</span>
    VerTexType vexs<span>[</span>MVNum<span>]</span><span>;</span><span>//顶点表[一维数组]</span>
    ArcType arcs<span>[</span>MVNum<span>]</span><span>[</span>MVNum<span>]</span><span>;</span><span>//邻接矩阵[二维数组]</span>
<span>}</span>AMGraph<span>;</span><span>//Adjacency Matrix Graph</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></li>
<li>
<p>采用邻接矩阵表示法创建无向网</p>
<ul>
<li>无向网
<ul>
<li>无向网</li>
<li>有向图</li>
<li>有向网</li>
</ul>
</li>
<li>算法思想
<ol>
<li>输入总顶点数和总边数</li>
<li>一次输入点的信息存入顶点表中</li>
<li>初始化邻接矩阵，使每个权值初始化为极大值</li>
<li>构造邻接矩阵</li>
</ol>
</li>
</ul>
<div><pre><code><span><span>#</span><span>define</span> <span>MaxInt</span> <span><span>32767</span></span><span>//表示极大值，即无穷</span></span>
define MVNum <span>100</span><span>//最大顶点数</span>
<span>typedef</span> <span>char</span> VerTexType<span>;</span><span>//设顶点的数据类型为字符型</span>
<span>typedef</span> <span>int</span> ArcType<span>;</span><span>//假设边的权值类型为整型</span>
<span>typedef</span> <span>struct</span><span>{</span>
    VerTexType vexs<span>[</span>MVNum<span>]</span><span>;</span><span>//顶点表[一维数组]</span>
    ArcType arcs<span>[</span>MVNum<span>]</span><span>[</span>MVNum<span>]</span><span>;</span><span>//邻接矩阵[二维数组]</span>
    <span>int</span> vexnum<span>,</span>arcnum<span>;</span><span>//图的当前点数和边数</span>
<span>}</span>AMGraph<span>,</span>G<span>;</span><span>//Adjacency Matrix Graph</span>

Status <span>CreateUDN</span><span>(</span>AMGraph <span>&amp;</span>G<span>)</span><span>{</span>
    <span>//采用邻接矩阵表示法，创建无向网G</span>
    cin<span>>></span>G<span>.</span>vexnum<span>>></span>G<span>.</span>arcnum<span>;</span><span>//输入总项点数，总边数</span>
    <span>for</span><span>(</span>i<span>=</span><span>0</span><span>;</span>i<span>&lt;</span>G<span>.</span>vexnum<span>;</span><span>++</span>i<span>)</span>
        cin<span>>></span>G<span>.</span>vexs<span>[</span>i<span>]</span><span>;</span><span>//依次输入点的信息</span>
    <span>//由于使二维数组，所以需要两个for循环</span>
    <span>for</span><span>(</span>i<span>=</span><span>0</span><span>;</span>i<span>&lt;</span>G<span>.</span>vexnum<span>;</span><span>++</span>i<span>)</span><span>//初始化邻接矩阵</span>
        <span>for</span><span>(</span>j<span>=</span><span>0</span><span>;</span>j<span>&lt;</span>G<span>.</span>vexnum<span>;</span><span>++</span>j<span>)</span>
            G<span>.</span>arcs<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>=</span>MaxInt<span>;</span><span>//边的权值均置为极大值</span>
    <span>for</span><span>(</span>k<span>=</span><span>0</span><span>;</span>k<span>&lt;</span>G<span>.</span>arcnum<span>;</span><span>++</span>k<span>)</span><span>{</span>
            cin<span>>></span>v1<span>>></span>v2<span>>></span>w<span>;</span><span>//输入一条边所以复的项点及边的权值</span>
            i<span>=</span><span>LocateVex</span><span>(</span>G<span>,</span>v1<span>)</span><span>;</span>
            j<span>=</span><span>LocateVex</span><span>(</span>G<span>,</span>v2<span>)</span><span>;</span><span>//确定v1和v2在G中的位置</span>
            G<span>.</span>arcs<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>=</span>w<span>;</span><span>//边&lt;v1,v2>的权值置为w</span>
            G<span>.</span>arcs<span>[</span>j<span>]</span><span>[</span>i<span>]</span><span>=</span>G<span>.</span>arcs<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>;</span><span>//置&lt;v1,v2>的对称边&lt;v2,v1>的权值为w</span>
        <span>}</span><span>//for</span>
    <span>return</span> OK<span>;</span>
<span>}</span><span>//CreateUDN</span>
<span>//补充用于在图中查找顶点</span>
<span>int</span> <span>LocateVex</span><span>(</span>AMGraph G<span>,</span> VertexType u<span>)</span><span>{</span>
    <span>//图G中查找顶点u，存在则返回顶点表中的下表; 否则返回-1</span>
    <span>int</span> i<span>;</span>
    <span>for</span><span>(</span>i<span>=</span><span>0</span><span>;</span>i<span>&lt;</span>G<span>.</span>vexnum<span>;</span><span>++</span>i<span>)</span>
        <span>if</span><span>(</span>i<span>==</span>G<span>.</span>vexs<span>[</span>i<span>]</span><span>)</span> <span>return</span> i<span>;</span>
    <span>return</span> <span>-</span><span>1</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div></li>
</ul>
<h4 id="邻接矩阵表示法的优缺点"> 邻接矩阵表示法的优缺点</h4>
<ul>
<li>优点
<ul>
<li>直观、间断、好理解</li>
<li>方便检查任意一对顶点间是否存在边</li>
<li>方便找任一顶点的所有“邻接点”（有边直接相连的顶点）</li>
<li>方便计算任一顶点的“度”（从该点发出的边数为“出度”，指向该点的边数为“入度”）
<ul>
<li>无向图：对应行（或列）非0元素的个数</li>
<li>有向图：对应行非0元素的个数是“出度”；对应列非0元素的个数是“入度”</li>
</ul>
</li>
</ul>
</li>
<li>缺点
<ul>
<li>不便于增加或删除节点</li>
<li>浪费空间——存稀疏图（点很多而边很少）有大量无效元素
<ul>
<li>对稠密图（特别是完全图）还是很合算的</li>
</ul>
</li>
<li>浪费时间——统计稀疏图中一共有多少条边</li>
</ul>
</li>
</ul>
<h3 id="邻接表"> 邻接表</h3>
<h4 id="邻接表表示法-链式"> 邻接表表示法（链式）</h4>
<ul>
<li>
<p>无向图的邻接表表示方式</p>
<ul>
<li>顶点
<ul>
<li>按编号顺序将顶点数据存储在一堆数组中</li>
</ul>
</li>
<li>关联同一顶点的边（以顶点为尾的弧）
<ul>
<li>用线性链表存储</li>
</ul>
</li>
</ul>
<p><img src="./images/data_structure/Untitled_40.png" alt="./images/data_structure/Untitled_40.png" /></p>
<ul>
<li>特点
<ul>
<li>邻接表不为一（边的顺序可以互换[边没有顺序]）</li>
<li>若无向图中有n个顶点、e条边，则其邻接表需n个头节点和2e个表节点。适宜存储稀疏图</li>
<li>无向图中顶点Vi的度为第i个单链表中的结点数</li>
</ul>
</li>
</ul>
</li>
<li>
<p>有向图的邻接表表示方式</p>
<p><img src="./images/data_structure/Untitled_41.png" alt="./images/data_structure/Untitled_41.png" /></p>
<ul>
<li>
<p>邻接表记录出度，逆邻接表记录入度</p>
</li>
<li>
<p>邻接表找出度易，找入度难</p>
</li>
<li>
<p>逆邻接表找入度易，找出度难</p>
</li>
<li>
<p>特点</p>
<ul>
<li>顶点vi的出度为第i个单链表中的结点个数</li>
<li>顶点vi的入度为整个当联邦中邻接点域值是i-1的结点个数</li>
</ul>
</li>
<li>
<p>练习：已知某网的邻接（出边）表，请画出该图</p>
<p><img src="./images/data_structure/Untitled_42.png" alt="./images/data_structure/Untitled_42.png" /></p>
</li>
</ul>
</li>
</ul>
<h4 id="图的邻接表存储特点"> 图的邻接表存储特点</h4>
<ul>
<li>
<p>邻接表特点</p>
<p><img src="./images/data_structure/Untitled_43.png" alt="./images/data_structure/Untitled_43.png" /></p>
<ul>
<li>方便找任一顶点的所有“邻接点”
<ul>
<li>节约稀疏图的空间需要N个头指针+2E个几诶单（每个节点至少2两个域）</li>
</ul>
</li>
<li>方便计算任一顶点的“度”？
<ul>
<li>对无向图：是的</li>
<li>对有向图：指南计算“出度”；需要构造“逆邻接表”（存指向自己的边）来方便计算“入度”</li>
</ul>
</li>
<li>不方便检查任意一对顶点间是否存在边</li>
</ul>
</li>
<li>
<p>邻接矩阵与邻接表表示法的关系</p>
<p><img src="./images/data_structure/Untitled_44.png" alt="./images/data_structure/Untitled_44.png" /></p>
<ul>
<li>联系：邻接表中每个链表对应于邻接矩阵中的一行，链表中结点个数等于一行中非零元素的个数</li>
<li>区别：
<ol>
<li>对于任一确定的无向图，<strong>邻接矩阵是唯一的</strong>（行列号与顶点编号一致），但<strong>邻接表不唯一</strong>（邻接次序与顶点编号无关）</li>
<li>邻接矩阵的空间复杂度为O(n^2),而邻接表的空间复杂度为O(n+e)【更好】</li>
</ol>
</li>
<li>用途：邻接矩阵多用于稠密图；而邻接表多用于稀疏图</li>
</ul>
</li>
<li>
<p>邻接表的有向图与无向图的缺点补充【了解】</p>
<p><img src="./images/data_structure/Untitled_45.png" alt="./images/data_structure/Untitled_45.png" /></p>
<ul>
<li>
<p>十字链表</p>
<ul>
<li>
<p>存储有向图，解决求结点的度难度问题</p>
</li>
<li>
<p>简介</p>
<ul>
<li>十字链表( Orthogonal List)是有向图的另一种链式存储结构。我们也可以把它看成是将有向图的邻接表和逆邻接表结合起来形成的一种链表。</li>
<li>有向图中的每一条弧对应十字链表中的一个弧结点，同时有向图中的每个顶点在十字链表中对应有一个结点，叫做顶点结点</li>
</ul>
<p><img src="./images/data_structure/Untitled_46.png" alt="./images/data_structure/Untitled_46.png" /></p>
</li>
</ul>
</li>
<li>
<p>链接多重表</p>
<ul>
<li>
<p>存储无向图，每条变都要存储两遍问题</p>
<p><img src="./images/data_structure/Untitled_47.png" alt="./images/data_structure/Untitled_47.png" /></p>
<p><img src="./images/data_structure/Untitled_48.png" alt="./images/data_structure/Untitled_48.png" /></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="图的遍历"> 图的遍历</h3>
<ul>
<li>定义
<ul>
<li>从已给的连通图中某一项点出发，沿着一些边访遍图中所有的顶点，且使每个顶点仅被访问一次，就叫做图的遍历，他是图的基本运算查找和排序</li>
</ul>
</li>
<li>图的特点
<ul>
<li>图中可能存在回路，且图的任一顶点都可能与其他顶点想通，再访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点
<ul>
<li>
<p>如何避免重复访问？</p>
<ul>
<li>设置辅助数组</li>
</ul>
<p><img src="./images/data_structure/Untitled_49.png" alt="./images/data_structure/Untitled_49.png" /></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="排序与查找"> 排序与查找</h1>
<h2 id="折半查找【待】"> 折半查找【待】</h2>
<h2 id="排序算法【待】"> 排序算法【待】</h2>
<ul>
<li>冒泡
<ul>
<li>数与数之间两两相比，升序的话大的放右边，一直比较下去，第一次循环过后最大的数就放在最右边，n*(n-1)次循环后不连续的n个数就排序完成了</li>
</ul>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>
<span>int</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
    <span>int</span> list<span>[</span><span>5</span><span>]</span><span>;</span>
    <span>int</span> len <span>=</span> <span>sizeof</span><span>(</span>list<span>)</span> <span>/</span> <span>sizeof</span><span>(</span>list<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
    <span>int</span> <span>*</span>p<span>,</span> c<span>;</span>
    p <span>=</span> list<span>;</span>
    <span>printf</span><span>(</span><span>"please input ten number:"</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> n <span>=</span> <span>0</span><span>;</span> n <span>&lt;</span> len<span>;</span> n<span>++</span><span>)</span>
        <span>scanf</span><span>(</span><span>"%d"</span><span>,</span> p<span>++</span><span>)</span><span>;</span>
    <span>int</span> num <span>=</span> <span>sizeof</span><span>(</span>list<span>)</span> <span>/</span> <span>sizeof</span><span>(</span>list<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> num<span>-</span><span>1</span><span>;</span> i<span>++</span><span>)</span>
    <span>{</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> i <span>+</span> <span>1</span><span>;</span> j <span>&lt;</span> num<span>;</span> j<span>++</span><span>)</span>
        <span>{</span>
            <span>if</span> <span>(</span>list<span>[</span>i<span>]</span> <span>></span> list<span>[</span>j<span>]</span><span>)</span>
            <span>{</span>
                c <span>=</span> list<span>[</span>i<span>]</span><span>;</span>
                list<span>[</span>i<span>]</span> <span>=</span> list<span>[</span>j<span>]</span><span>;</span>
                list<span>[</span>j<span>]</span> <span>=</span> c<span>;</span>
            <span>}</span>
        <span>}</span>
        <span>for</span> <span>(</span><span>int</span> k <span>=</span> <span>0</span><span>;</span> k <span>&lt;</span> <span>5</span><span>;</span> k<span>++</span><span>)</span>
        <span>{</span>
            <span>printf</span><span>(</span><span>"%d "</span><span>,</span> list<span>[</span>k<span>]</span><span>)</span><span>;</span>
        <span>}</span><span>printf</span><span>(</span><span>"\n"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>int</span> b <span>=</span> <span>0</span><span>;</span> b <span>&lt;</span> len<span>;</span> b<span>++</span><span>)</span>
    <span>{</span>
        <span>printf</span><span>(</span><span>"%d "</span><span>,</span> list<span>[</span>b<span>]</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div></li>
<li>插入
<ul>
<li>左所有的数字里面，升序的选择第i个数，往后判断，如果比它小则互换位置，经过第n次比较后这个不连续的n*(n-1)个数就排序完成了</li>
</ul>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>
<span>int</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
    <span>int</span> list<span>[</span><span>]</span><span>=</span><span>{</span><span>9</span><span>,</span><span>5</span><span>,</span><span>7</span><span>,</span><span>3</span><span>,</span><span>1</span><span>,</span><span>6</span><span>}</span><span>;</span>
    <span>int</span> poc<span>;</span>
    <span>int</span> box<span>;</span>
    <span>int</span> i<span>,</span>j<span>;</span>
    <span>int</span> len<span>=</span><span>sizeof</span><span>(</span>list<span>)</span><span>/</span><span>sizeof</span><span>(</span>list<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
    <span>for</span><span>(</span>i<span>=</span><span>1</span><span>;</span>i<span>&lt;</span>len<span>;</span>i<span>++</span><span>)</span>
    <span>{</span>
        box<span>=</span>list<span>[</span>i<span>]</span><span>;</span>
        <span>for</span><span>(</span>j<span>=</span>i<span>-</span><span>1</span><span>;</span>j<span>>=</span><span>0</span><span>&amp;&amp;</span>list<span>[</span>j<span>]</span><span>></span>box<span>;</span>j<span>--</span><span>)</span>
        <span>{</span>
            list<span>[</span>j<span>+</span><span>1</span><span>]</span><span>=</span>list<span>[</span>j<span>]</span><span>;</span>
        <span>}</span>
        list<span>[</span>j<span>+</span><span>1</span><span>]</span><span>=</span>box<span>;</span>
    <span>}</span>
    <span>for</span><span>(</span><span>int</span> k<span>=</span><span>0</span><span>;</span>k<span>&lt;</span><span>6</span><span>;</span>k<span>++</span><span>)</span>
    <span>{</span>
        <span>printf</span><span>(</span><span>"%d "</span><span>,</span>list<span>[</span>k<span>]</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div></li>
<li>选择
<ul>
<li>从所有的元素里面找到最小的，再与第一个互换，然后在剩下的元素里进行查找和互换</li>
</ul>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>
<span>int</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
    <span>int</span> list<span>[</span><span>]</span><span>=</span><span>{</span><span>9</span><span>,</span><span>5</span><span>,</span><span>7</span><span>,</span><span>3</span><span>,</span><span>1</span><span>,</span><span>6</span><span>}</span><span>;</span>
    <span>int</span> len <span>=</span> <span>sizeof</span><span>(</span>list<span>)</span> <span>/</span> <span>sizeof</span><span>(</span>list<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
    <span>int</span> min<span>,</span>box<span>,</span>i<span>,</span>j<span>;</span>
    <span>for</span><span>(</span>i<span>=</span><span>0</span><span>;</span>i<span>&lt;</span>len<span>;</span>i<span>++</span><span>)</span>
    <span>{</span>
        min <span>=</span> i<span>;</span>
        <span>for</span><span>(</span>j<span>=</span>i<span>+</span><span>1</span><span>;</span>j<span>&lt;</span>len<span>;</span>j<span>++</span><span>)</span>
        <span>{</span>
            <span>if</span><span>(</span>list<span>[</span>j<span>]</span><span>&lt;</span>list<span>[</span>min<span>]</span><span>)</span>
                min <span>=</span> j<span>;</span>
        <span>}</span>
        box<span>=</span>list<span>[</span>i<span>]</span><span>;</span>
        list<span>[</span>i<span>]</span><span>=</span>list<span>[</span>min<span>]</span><span>;</span>
        list<span>[</span>min<span>]</span><span>=</span>box<span>;</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>int</span> k <span>=</span> <span>0</span><span>;</span> k <span>&lt;</span> <span>6</span><span>;</span> k<span>++</span><span>)</span>
    <span>{</span>
        <span>printf</span><span>(</span><span>"%d "</span><span>,</span> list<span>[</span>k<span>]</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div></li>
<li>快速排序
<ul>
<li>设置l和r下标，将数组分为三段，a[l:i-1], a[i], a[i+1:r]，然后一直递归对a[l:i-1]和 a[i+1:r]排序互换位置，最后再对a[l:i-1], a[i], a[i+1:r]何必</li>
</ul>
</li>
<li>归并排序
<ul>
<li>先两个两个数两两排序，再四个数列四四排序...</li>
</ul>
</li>
<li>排序和查找的关系
<ul>
<li>排序时查找的前提</li>
<li>排序时重点</li>
</ul>
</li>
</ul>
<h1 id="刷题"> 刷题</h1>
<h2 id="专业课刷题"> 专业课刷题</h2>
<ul>
<li>
<p>C语言常常称为<strong>中级语言</strong>，方便移植</p>
</li>
<li>
<p><strong>9和字符 '9'</strong> 不相等！！ <code>9!='9'</code> ，值为1，因为类型都不一样</p>
</li>
<li>
<p>字符串长度<strong>包括所有字符和空格字符的个数</strong></p>
</li>
<li>
<p>常用算法的使用（注意，考试中考察下列算法大多是填写空白填空，所以得知道核心算法！还有代码的先后顺序）</p>
<ul>
<li>
<p>素数</p>
<ul>
<li>素数是指除了1和它本身之外，不能被任何整数整除的数</li>
<li>只要不被大于一、小于其本身的数%为0则是素数</li>
</ul>
</li>
<li>
<p>阶乘</p>
</li>
<li>
<p>闰年</p>
<ul>
<li>分开
<ul>
<li>先<code>if(year%400==0)</code></li>
<li>再嵌套<code>if(year%4==0 &amp;&amp; year%100!=0)</code></li>
</ul>
</li>
<li>或直接
<ul>
<li><code>if(year%4==0 &amp;&amp; year%100!=0 ||year%400==0))</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>每个数的次方相加</p>
</li>
<li>
<p>斐波那契数列的递归算法</p>
<div><pre><code><span>if</span> <span>(</span>n<span>&lt;=</span><span>2</span><span>)</span> <span>return</span> <span>1</span><span>;</span>
<span>else</span> <span>return</span> <span>fibon</span><span>(</span>n<span>-</span><span>1</span><span>)</span><span>+</span><span>fibon</span><span>(</span>n<span>-</span><span>2</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>二分查找的递归算法</p>
</li>
<li>
<p>快速排序的代码实现</p>
</li>
</ul>
</li>
<li>
<p>switch ··· case ··· default ···</p>
</li>
<li>
<p>数据不可分割的单位是<strong>数据项</strong>，数据元素是基本单位，数据项是最小单位不可分割</p>
</li>
<li>
<p><strong>时间复杂度</strong>是<strong>运行时间</strong>，空间复杂性是运行时候程序所占用空间变量</p>
</li>
<li>
<p>时间复杂性有最好情况和最坏情况，一般指的是<strong>平均复杂度</strong></p>
</li>
<li>
<p>数据存储结构分四类：<strong>顺序存储、链式存储、索引存储、散列存储</strong></p>
</li>
<li>
<p>拓扑序列是<strong>有序列表</strong>，<strong>除了拓扑序列之外其他都是无序列表</strong></p>
</li>
<li>
<p>表达式求值进行<strong>栈</strong>计算</p>
</li>
<li>
<p>哈希表（hash）是解决<strong>栈溢出</strong>的问题</p>
</li>
<li>
<p>一个长度为 n 的链式队列入队的复杂性是<strong>o(1)</strong></p>
</li>
<li>
<p>树</p>
<ul>
<li>
<p>概念</p>
<ul>
<li>
<p>度、叶结点、深度</p>
<p><img src="./images/data_structure/Untitled060.png" alt="./images/data_structure/Untitled060.png" /></p>
<ul>
<li>结点的度
<ul>
<li>结点的孩子树（数量）</li>
<li>B的度有两个度EF；F有两个度IJ</li>
</ul>
</li>
<li>一棵树的度
<ul>
<li>该树中节点的最大度数</li>
<li>B树的度为2</li>
</ul>
</li>
<li>叶结点
<ul>
<li>度为0的结点叫做叶结点</li>
<li>E的度为0，因为他没有孩子树，所以他是叶结点</li>
</ul>
</li>
<li>树的深度（高度）
<ul>
<li>这棵树的层数</li>
<li>B这棵树的深度为3</li>
</ul>
</li>
</ul>
</li>
<li>
<p>二叉树</p>
<ul>
<li>二叉树中每个节点至多两个结点（至多≤2)</li>
<li>性质
<ul>
<li>高度为h≥2的二叉树至少有h+1个结点</li>
<li>高度不超过h的二叉树至多右<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8491079999999999em;vertical-align:0em;"></span><span><span>2</span><span><span><span><span style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>h</span><span>+</span><span>1</span></span></span></span></span></span></span></span></span></span></span></span>个结点</li>
</ul>
</li>
</ul>
</li>
<li>
<p>满二叉树（拥有奇数个结点）</p>
<ul>
<li>一棵树高度为h且有<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.9324379999999999em;vertical-align:-0.08333em;"></span><span><span>2</span><span><span><span><span style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>h</span><span>+</span><span>1</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2222222222222222em;"></span><span>−</span><span style="margin-right:0.2222222222222222em;"></span></span><span><span style="height:0.64444em;vertical-align:0em;"></span><span>1</span></span></span></span>个结点的二叉树称为满二叉树
<ul>
<li>除最低下的叶子节点，其他的结点都是2，若有一个结点不满足则不是满二叉树</li>
</ul>
</li>
</ul>
</li>
<li>
<p>完全二叉树</p>
<ul>
<li>结点是连续的，若不连续则不是完全二叉树，最下面一层上的结点都几种再该层最左边，完全二叉树是近似于满二叉树的</li>
<li>满二叉树一定是完全二叉树，完全二叉树不一地呢是满二叉树</li>
</ul>
</li>
<li>
<p>森林的先中后序遍历，先使用左儿子右兄弟的方法整理一次后再进行先中后序遍历</p>
</li>
</ul>
</li>
<li>
<p>二叉树的分支<strong>最多为2</strong></p>
</li>
<li>
<p>二叉树的形态有5种</p>
<p><img src="./images/data_structure/IMG_20210407_163445.jpg" alt="./images/data_structure/IMG_20210407_163445.jpg" /></p>
</li>
<li>
<p>m 个节点的二叉树，对应的二叉链表有<strong>m+1</strong>个非空域</p>
</li>
<li>
<p>二叉树的深度遍历可以采用的数据结构<strong>堆</strong></p>
</li>
<li>
<p>深度为n的二叉树最多有<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.46528em;vertical-align:0em;"></span><span>∗</span><span style="margin-right:0.2222222222222222em;"></span><span>∗</span><span style="margin-right:0.2222222222222222em;"></span></span><span><span style="height:0.8879999999999999em;vertical-align:0em;"></span><span><span>n</span><span><span><span><span style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>(</span><span>n</span><span>−</span><span>1</span><span>)</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2222222222222222em;"></span><span>∗</span><span style="margin-right:0.2222222222222222em;"></span></span><span><span style="height:0.46528em;vertical-align:0em;"></span><span>∗</span></span></span></span>个节点</p>
</li>
<li>
<p>具有 n 个叶子节点的哈夫曼树，共有 <strong>2*n-1</strong> 个节点</p>
</li>
<li>
<p>计算二叉树的<strong>最小高度：</strong><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.93858em;vertical-align:-0.24414em;"></span><span><span>lo<span style="margin-right:0.01389em;">g</span></span><span><span><span><span style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>2</span></span></span></span><span>​</span></span><span><span style="height:0.24414em;"><span></span></span></span></span></span></span><span style="margin-right:0.16666666666666666em;"></span><span>h</span><span style="margin-right:0.2777777777777778em;"></span><span>=</span><span style="margin-right:0.2777777777777778em;"></span></span><span><span style="height:0.43056em;vertical-align:0em;"></span><span>n</span></span></span></span>，n为结点，h为高度；例如2000个结点，<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span style="margin-right:0.01968em;">l</span><span>o</span><span><span style="margin-right:0.03588em;">g</span><span><span><span><span style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>2</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>11</span><span style="margin-right:0.2777777777777778em;"></span><span>=</span><span style="margin-right:0.2777777777777778em;"></span></span><span><span style="height:0.64444em;vertical-align:0em;"></span><span>2048</span></span></span></span>所以最小高度为11，(2^10=1024)</p>
</li>
<li>
<p>二叉树的<strong>左孩子结点是<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.65952em;vertical-align:0em;"></span><span>2</span><span>i</span></span></span></span>，右孩子结点是<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.74285em;vertical-align:-0.08333em;"></span><span>2</span><span>i</span><span style="margin-right:0.2222222222222222em;"></span><span>+</span><span style="margin-right:0.2222222222222222em;"></span></span><span><span style="height:0.64444em;vertical-align:0em;"></span><span>1</span></span></span></span></strong></p>
</li>
<li>
<p>满二叉树的高度为n（根为第1层），则该<strong>二叉树的结点总数为<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.747722em;vertical-align:-0.08333em;"></span><span><span>2</span><span><span><span><span style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>n</span></span></span></span></span></span></span></span><span style="margin-right:0.2222222222222222em;"></span><span>−</span><span style="margin-right:0.2222222222222222em;"></span></span><span><span style="height:0.64444em;vertical-align:0em;"></span><span>1</span></span></span></span>个。叶子结点右<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8141079999999999em;vertical-align:0em;"></span><span><span>2</span><span><span><span><span style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>n</span><span>−</span><span>1</span></span></span></span></span></span></span></span></span></span></span></span>个</strong></p>
</li>
<li>
<p>二叉判断树，大概就是选取中间，按树的思路数列从左到右放，剩下的余数放在右子树即可</p>
</li>
<li>
<p>计算二叉树平均查找长度：(第n层 * 第n层节点的数量)/总节点数</p>
<ul>
<li>
<p>假设树是有四层高度，如图所示，那么应为<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>(</span><span>1</span><span style="margin-right:0.2222222222222222em;"></span><span>+</span><span style="margin-right:0.2222222222222222em;"></span></span><span><span style="height:0.64444em;vertical-align:0em;"></span><span>2</span><span style="margin-right:0.2222222222222222em;"></span><span>∗</span><span style="margin-right:0.2222222222222222em;"></span></span><span><span style="height:0.72777em;vertical-align:-0.08333em;"></span><span>2</span><span style="margin-right:0.2222222222222222em;"></span><span>+</span><span style="margin-right:0.2222222222222222em;"></span></span><span><span style="height:0.64444em;vertical-align:0em;"></span><span>3</span><span style="margin-right:0.2222222222222222em;"></span><span>∗</span><span style="margin-right:0.2222222222222222em;"></span></span><span><span style="height:0.72777em;vertical-align:-0.08333em;"></span><span>4</span><span style="margin-right:0.2222222222222222em;"></span><span>+</span><span style="margin-right:0.2222222222222222em;"></span></span><span><span style="height:0.64444em;vertical-align:0em;"></span><span>4</span><span style="margin-right:0.2222222222222222em;"></span><span>∗</span><span style="margin-right:0.2222222222222222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>3</span><span>)</span><span>/10</span><span style="margin-right:0.2777777777777778em;"></span><span>=</span><span style="margin-right:0.2777777777777778em;"></span></span><span><span style="height:0.64444em;vertical-align:0em;"></span><span>2.9</span></span></span></span></p>
<p><img src="./images/data_structure/Untitled061.png" alt="./images/data_structure/Untitled061.png" /></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>图</p>
<ul>
<li>n 个节点的联通图至少有<strong>n-1</strong>条边</li>
<li>查找关键字的信息搜索信息范围采用图的<strong>深度遍历（搜索边界速度快）</strong></li>
<li>查找关键字的信息搜索精确度采用图的<strong>广度遍历（搜索所有有关的内容速度快）</strong></li>
<li>中国铁路网信息是<strong>图</strong>的数据结构</li>
</ul>
</li>
<li>
<p>排序⭐</p>
<ul>
<li>冒泡排序
<ul>
<li>平均时间复杂度为<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1.064108em;vertical-align:-0.25em;"></span><span>o</span><span>(</span><span><span>n</span><span><span><span><span style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>2</span></span></span></span></span></span></span></span><span>)</span></span></span></span></li>
</ul>
</li>
<li>插入排序
<ul>
<li>平均时间复杂度为<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1.064108em;vertical-align:-0.25em;"></span><span>o</span><span>(</span><span><span>n</span><span><span><span><span style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>2</span></span></span></span></span></span></span></span><span>)</span></span></span></span></li>
</ul>
</li>
<li>选择排序
<ul>
<li>平均时间复杂度为<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1.064108em;vertical-align:-0.25em;"></span><span>o</span><span>(</span><span><span>n</span><span><span><span><span style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>2</span></span></span></span></span></span></span></span><span>)</span></span></span></span></li>
</ul>
</li>
<li>快速排序
<ul>
<li>平均时间复杂度为<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>o</span><span>(</span><span>n</span><span style="margin-right:0.16666666666666666em;"></span><span><span>lo<span style="margin-right:0.01389em;">g</span></span><span><span><span><span style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>2</span></span></span></span></span><span>​</span></span><span><span style="height:0.24414em;"><span></span></span></span></span></span></span><span style="margin-right:0.16666666666666666em;"></span><span><span>n</span></span><span>)</span></span></span></span></li>
<li>过程：
<ul>
<li>先选定键（默认为最左边的数）</li>
<li>设置L（最左）与R（最右）指标
<ul>
<li>L指向最左边的下标，从左往右判断是否比键大，若大则与R交换，否则L+1（往右）</li>
<li>R指向最右边的下标，从右往左判断是否比键小，若小则与L交换，否则R-1（往左）</li>
</ul>
</li>
<li>先从R开始与键判断，重复执行直到L与R重合，则第一次执行完毕</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>数据安全课记</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/notes/data_security/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/notes/data_security/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">数据安全课记</source>
      <category>笔记</category>
      <pubDate>Wed, 29 Jul 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="导"> 导</h1>
<p>利用率：（N-1)/N
读效率稍高，写效率稍差
容错性：允许一块硬盘故障导读与大纲</p>
<p>这篇笔记始于2020/3/10</p>
<p>定位：计算机类网络专业核心课程</p>
<p>数据备份 -&gt; 防止灾难、意外事故造成损失</p>
<p>数据恢复 -&gt; 灾难发生后，尽可能拯救数据</p>
<h2 id="网站推荐"> 网站推荐：</h2>
<p>https://www.dgxue.com/huifu/ 数据恢复迷</p>
<h2 id="数据备份"> 数据备份</h2>
<h3 id="数据存储介质"> 数据存储介质</h3>
<ul>
<li>硬盘、磁带、光盘
<ul>
<li>主流与趋势</li>
<li>市场调查</li>
</ul>
</li>
</ul>
<h3 id="存储系统结构-重点"> 存储系统结构（重点）</h3>
<ul>
<li>存储系统结构（重点）
<ul>
<li>DAS、NAS、SAN
<ul>
<li>各个存储架构的组成、技术特点、应用</li>
<li>能够设计合理的存储架构</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="存储新技术"> 存储新技术</h3>
<ul>
<li>虚拟化、节能技术
<ul>
<li>分级存储于管理、数据自动迁移、重复数据删除技术、自动精简配置、MAID技术</li>
<li>能够根据需要使用配置相关技术</li>
</ul>
</li>
</ul>
<h3 id="数据容灾技术-重点"> 数据容灾技术（重点）</h3>
<ul>
<li>容灾系统、容灾策略及方案
<ul>
<li>能够设计合理的数据容灾系统</li>
</ul>
</li>
</ul>
<h2 id="数据恢复"> 数据恢复</h2>
<h3 id="磁盘内部物理和逻辑结构"> 磁盘内部物理和逻辑结构</h3>
<ul>
<li>
<p>磁盘部件</p>
</li>
<li>
<p>工作原理</p>
</li>
<li>
<p>逻辑结构划分</p>
</li>
<li>
<p>分区设定（难点）</p>
</li>
</ul>
<h3 id="fat文件系统-难点-重点"> FAT文件系统（难点+重点）</h3>
<ul>
<li>系统结构</li>
<li>文件记录方式</li>
<li>数据存储方式</li>
<li>数据的查找与恢复</li>
</ul>
<h3 id="ntfs文件系统-难点-重点"> NTFS文件系统（难点+重点）</h3>
<p>windows主流文件系统</p>
<ul>
<li>系统结构</li>
<li>文件记录方式</li>
<li>数据存储方式</li>
<li>数据的查找与恢复</li>
</ul>
<h3 id="raid磁盘阵列-难点-重点"> RAID磁盘阵列（难点+重点）</h3>
<ul>
<li>
<p>阵列类型</p>
</li>
<li>
<p>特点与参数</p>
</li>
<li>
<p>阵列恢复方法</p>
</li>
</ul>
<h3 id="数据恢复工具"> 数据恢复工具</h3>
<ul>
<li>
<p>PC3000</p>
</li>
<li>
<p>Winhex</p>
<p>16进制编辑软件</p>
</li>
<li>
<p>其他数据恢复软件</p>
<p>傻瓜式恢复软件</p>
</li>
</ul>
<h1 id="数据备份-数据存储介质"> 数据备份 - 数据存储介质</h1>
<h3 id="光存储设备"> 光存储设备</h3>
<p>光存储设备常被简称光驱，光存储设备所使用的存储存放介质被称为光盘，由于其存储容量大、价格便宜、保存时间长，是许多软件和数据采用的存储介质。从CD、DVD再到HD DVD和BD，光盘存储量越来越大，技术也越来越先进</p>
<h3 id="光存储设备的种类"> 光存储设备的种类</h3>
<p>光存储设备分为<strong>台式内置光驱、笔记本内置光驱、外置通用光驱</strong>三种</p>
<ul>
<li>
<p>台式内置光驱</p>
<p>台式内置光驱安装在主机箱内部，是DIY市场中最为普遍的光存储产品类型</p>
</li>
<li>
<p>笔记本内置光驱</p>
<p>笔记本内置光驱强调薄、轻、省电、价格高，其牢固度要远低于台式机内置
光驱</p>
</li>
<li>
<p>外置通用光驱</p>
<p>外置通用光驱则是通过外部接口连接在主机上，主要是针对需要移动工作的
用户，更多的是强调移动性，在性能、其数据传输率、体积、重量等方面都
受到制约，要逊色于内置式光驱，而且价格要远远高于内置式</p>
</li>
</ul>
<h3 id="按读写光盘的类型分类"> 按读写光盘的类型分类</h3>
<ol>
<li>
<p>DVD-DOM驱动器</p>
<p>一种可以读取DVD盘片的光驱，兼容DVD-ROM、CD-ROM等常见的格式</p>
<p>DVD-ROM驱动器分台式机内置型、笔记本内置型和外置型三种</p>
<p>DVD的单倍速是指1358KB/s，而CD的单倍速是150KB/s，大约为
CD的9倍</p>
<p>目前DvD-ROM驱动器所能达到的最大DVD读取速度是18倍速最大数据传输率为27MB/S，缓存容量从198K至256K不等。接口类型有IDE和SATA两种。安装方式分内置和外置两种</p>
</li>
<li>
<p>DVD刻录机</p>
<p>可写光盘</p>
<p>DVD刻录规格并没有简历起统一的规格，目前有三种不同的刻录规格：DVD-RAM、DVD-R/W、DVD+R/W，而且三种规格相互不兼容，主流为DVD-R/W、DVD+R/W</p>
<p>目前多数刻录机都支持 DVD-ROM，DVD+R DL，DVD+R，DVD+RW. dVD-R DL，DVD-R，DVD-RW，DVD-RAM，DVD Video，CD-ROM，CD-R，CD-RW等多种类型</p>
</li>
<li>
<p>蓝光刻录机</p>
<p>蓝光刻录机是基于蓝光DVD技术标准的刻录机
DVD使用MPEG2压缩技术，可以存储广播级效果的电影</p>
</li>
</ol>
<h3 id="光存储设备的工作原理"> 光存储设备的工作原理</h3>
<ol>
<li>
<p>光存储设备的外部结构</p>
<p><img src="./images/data_security/image-20200310112122566.png" alt="image-20200310112122566" /></p>
<p><img src="./images/data_security/8.png" alt="image-20200310112122566" /></p>
</li>
<li>
<p>读取数据的工作原理</p>
<ul>
<li>
<p>光盘上存在着凹点和凸点
凹0 凸1，突起的地方表示1，凹陷的地方表示0</p>
<p>详细：光盘上存在着“凹点”和“凸点”两种状态，它们的反射信号正好相反，这两种不同的信号很容易就能被光监测器识别，在光驱中有专门的部件将它们转换并校验，再交给光存储设备中的控制芯片处理，然后就会在计算机中得到光盘中的数据。</p>
</li>
<li>
<p>不同类型的光盘主要区别是激光头产生的不同波长</p>
<p>激光头会产生0.54μm~0.78μm</p>
</li>
<li>
<p>激光波长：</p>
<ul>
<li>DVD：650nm</li>
<li>CD：780nm</li>
</ul>
</li>
</ul>
<p><img src="./images/data_security/image-20200310112435997.png" alt="image-20200310112435997" /></p>
</li>
<li>
<p>刻录数据的工作原理</p>
<p>只有具备刻录光盘功能的光存储设备才能在特定的光盘中刻录数据。
CD刻录机是在 CD-ROM的基础上发展起来的光存储设备，可刻录的光盘类型有CD-R光盘和CD-RW光盘</p>
<p>DVD刻录机是在DVD-ROM的基础上发展起来的光存储设备，可刻录的光盘类型有DVD-R、 DVD-RW、 DVD-R DL、DVD+R、DVD+RW、DVD+R DL、DVD-RAM、CD-R、CD-RW等9种格式的光盘。</p>
<p>具体过程：可刻录光盘是在聚碳酸酯制成的片基上喷涂了一层染料层，激光头根据刻写数据的不同控制发射激光束的功率，使部分染料受热分解，在空白的光盘上用高温“烧刻”出可供读取的反光点，由于染料层分解后不能复原，因此DVD-R光盘只能烧刻一次，而RW由于染料层的不同，可以反复刻写。</p>
<p><img src="./images/data_security/image-20200310112641593.png" alt="image-20200310112641593" /></p>
</li>
<li>
<p>光存储设备的性能指标</p>
<p>衡量光驱性能指标的最重要参数是数据传输率，其他还有平均寻道时间、数据传输模式、CPU占用时间、缓存容量以及
纠错能力等。</p>
<ol>
<li>
<p>倍速</p>
<ol>
<li>CD-ROM基准倍率为150Kb/s（1x） 如50x光驱的数据传输速度为7.5MB/s</li>
<li>DVD基准倍率为1.35MB/s（1x） 如20x光驱的数据传输速度为27MB/s</li>
<li>BD-ROM基准倍率为4.5MB/s（1x）</li>
</ol>
<p>最大数据传输速度指激光头在光盘最外圈读写数据所达到的最大值，光盘内圈数据传输速度大约为外圈的一半左右。</p>
</li>
<li>
<p>多格式支持</p>
<p>DVD-ROM光盘驱动器能支持和兼容读取多种盘片</p>
</li>
<li>
<p>缓存容量</p>
<p>高，因此缓存容量对光驱的性能影响相当大。目前普通光驱大多采用198KB<sub>256K缓存容量，而刻录机一般采用2</sub>8MB缓存容量。</p>
</li>
<li>
<p>接口类型</p>
<p>市面上主要有IDE、USB、SCSI和SATA，SCSI接口的CD-ROM价格较贵、安装较复杂，且需要专门的转接卡</p>
<p>现在的DE接口的传输速率最高可达133MB/s，SATA150接口的传输速率最高可达150MB/s，而18倍速的 DVD-ROM的实际需要的速度只有18*1358KB/s=24.444MBs，选用哪种接口基本都能满足传输速度要求。</p>
</li>
<li>
<p>纠错能力</p>
<p>光驱对一些数据区域不连续的光盘进行读取时的使用能力。</p>
<p>其中对比明显为兼容性差的国外的光驱不能读取盗版的光盘，而国内的光驱兼容性强可以读取盗版光盘</p>
</li>
<li>
<p>震动、噪音和发热</p>
</li>
</ol>
</li>
</ol>
<h3 id="光驱常见故障"> 光驱常见故障</h3>
<p><img src="./images/data_security/17.png" alt="image-20200310112641593" /></p>
<h4 id="光盘概述"> 光盘概述</h4>
<h5 id="优点"> 优点：</h5>
<p>写入后不可修改，成本中等，维护成本低</p>
<ul>
<li>成本低
<ul>
<li>每张成本不过一两元甚至更低</li>
</ul>
</li>
<li>使用寿命长！
<ul>
<li>合理使用一般会在100年左右</li>
<li>抗干扰能力强</li>
</ul>
</li>
<li>便于携带</li>
</ul>
<h3 id="光盘的分类"> 光盘的分类</h3>
<ol>
<li>
<p>CD-ROM光盘</p>
<p><img src="./images/data_security/20.png" alt="image-20200310112641593" /></p>
</li>
<li>
<p>DVD-ROM光盘</p>
<p>DVD-ROM光盘的容量是CD光盘的7倍，为了在相同面积内装载更多内容，DVD光盘釆用了更高密度的（螺旋）轨道间隙设计，从以往CD的1.6微米减小至0.74微米。数据凹槽的（宽度）尺寸从CD的0.83微米缩小到0.40微米。更小的数据凹槽需要更短波长的光束才能正确读取，因此DVD使用了640纳米波长的激光束（而CD的激光波长则为780纳米）.存储一部长度为135分钟的电影通常需要4692Kbps的速率。换算成容量单位即为4.75GB，因此以此为标准规定了DD光盘的最初容量。</p>
<p><img src="./images/data_security/22.png" alt="image-20200310112641593" /></p>
</li>
<li>
<p>刻录机</p>
<p>除了只能读不能写的只读型ROM（ Read-Only Memory，只读存储器）光盘外，还有可写一次-R（ Recordable，可记录）与反复擦写RW（ReWritable，可重写）的光盘。它们除了可以被读取之外，还都能够写入数据。
CDR/DVD±R与 CD-RW//DVD+RW之间的差别是：±R只能写一次，不能擦掉后重写；而±RW则可以反复擦写。</p>
</li>
</ol>
<p>DVD盘片格式分类</p>
<ol>
<li>DVD-RAM规格</li>
<li>DV-RW</li>
<li>DVD+RW</li>
<li>DVD-R与DVD+R</li>
<li>DVD-Multi与DVD-Dual</li>
</ol>
<p>其中+R好过-R，-R光头定位进度低寻址方式的信号识别度较差，+R则精度高寻址方式比前者好</p>
<p><img src="./images/data_security/27.png" alt="image-20200310112641593" /></p>
<p><img src="./images/data_security/28.png" alt="image-20200310112641593" /></p>
<h5 id="bd与hd的蓝光盘"> BD与HD的蓝光盘</h5>
<ul>
<li>
<p>BD</p>
<p>蓝光盘的容量大，添加了硬质塑料或聚合物外壳，盘片的保护性好；但与现有DvD不兼容，而且制作成木较髙，播放机的销售价格也较贵
BD视盘采用的是MPEG2、MPEG4/AVC（H.264）和VC-1视频编码，音频则采用了 Dolby Digital（AC3）、DTS和LPCM（可达7.1声道）编码，可选 Dolby Digital Plus和无损的Dolby TrueHD与 DTS HD</p>
<p><img src="./images/data_security/30.png" alt="image-20200310112641593" /></p>
</li>
<li>
<p>HD</p>
<p>HD DVD采用MPEG-4AVC、VC-1和MPEG2视频编码，采用DolbyDigital Plus、DTS、 Dolby digital（AC3）和 MPEG Audio等有损编码和LPCM、MLP（ TRUE HD双声道]和 DTS HD等无损编码</p>
</li>
</ul>
<h4 id="光存储设备选购指南"> 光存储设备选购指南</h4>
<ol>
<li>
<p>品牌</p>
<p>售后</p>
</li>
<li>
<p>读盘能力</p>
<p>单激光头和双激光头</p>
</li>
<li>
<p>接口和缓存</p>
<p>IDE和SATA，推荐SAA</p>
</li>
<li>
<p>区码的限制</p>
</li>
<li>
<p>倍速</p>
</li>
<li>
<p>多格式支持</p>
</li>
</ol>
<h4 id="刻录机的选购"> 刻录机的选购</h4>
<ol>
<li>兼容性</li>
<li>稳定性</li>
<li>关头系统</li>
<li>读写倍速</li>
<li>区码问题</li>
<li>售后服务</li>
</ol>
<h2 id="磁带存储技术"> 磁带存储技术</h2>
<ul>
<li>磁带存储器的读写原理基本上与磁盘存储器相同，只是他的载体是一种带状塑料叫做磁带，写入时可通过磁头把信息代码记录在磁带上，当记录代码的磁带在磁头下移动时，就可在磁头线圈上感应出电动势，即读出信息代码</li>
<li>磁带存储器由磁带机和磁盘两部分组成</li>
</ul>
<h3 id="发展历程"> 发展历程</h3>
<p>1949年，磁带从实验室诞生，1952年，IBM的第一个磁带单元IBM 726问世，磁带由像以前电影播放的大机柜到后面的小盒子</p>
<h3 id="磁带类型"> 磁带类型</h3>
<p>磁带根据读写磁带的工作原理，可以分成六种规格</p>
<ul>
<li>其中两种采用螺旋扫描读写工作</li>
<li>另外四种则是选用数据流存储技术设计的设备</li>
</ul>
<p>螺旋扫描读写方式</p>
<ul>
<li>面向工作组级的DAT（4mm）磁带机</li>
<li>面向部门级的8mm磁带机</li>
</ul>
<p>数据流春初技术设计的设备</p>
<ul>
<li>单磁头读写方式</li>
<li>磁带宽度为1/4英寸</li>
<li>面向低端应用的Travan和DC系列</li>
<li>DLT和IBM的3480/3490/3590系列</li>
</ul>
<h3 id="磁带技术介绍"> 磁带技术介绍</h3>
<ul>
<li>硬件
<ul>
<li>单轴</li>
<li>双轴</li>
</ul>
</li>
<li>记录方式
<ul>
<li>螺旋</li>
<li>线性</li>
</ul>
</li>
<li>磁带宽度
<ul>
<li>4毫米</li>
<li>8毫米</li>
<li>1/4英寸</li>
<li>1/2英寸</li>
</ul>
</li>
</ul>
<h3 id="线性扫描记录"> 线性扫描记录</h3>
<p>磁头和磁带之间会有接触（摩擦），会磨损对寿命会减少，也会被干扰灰尘</p>
<ul>
<li>容量大</li>
</ul>
<h3 id="螺旋扫描记录"> 螺旋扫描记录</h3>
<p>磁头倾斜着读取，相比于线性扫描记录好</p>
<ul>
<li>定位块</li>
<li>寿命长</li>
</ul>
<h3 id="各种技术之间是不兼容的"> 各种技术之间是不兼容的！！！</h3>
<h3 id="lto技术"> LTO技术</h3>
<p>LTO(linear tape open)线性磁带开放协议，虽然是一直标准格式没的说并不互相兼容</p>
<p>由IBM、惠普与希捷联合建立，在磁带技术里速度最快、容量最大的磁带格式</p>
<ul>
<li>IBM LTO/Ultrium-1
<ul>
<li>平均文件访问时间70s</li>
</ul>
</li>
<li>IBM LTO/Ultrium-2
<ul>
<li>平均文件访问时间46s</li>
</ul>
</li>
<li>IBM LTO/Ultrium-3
<ul>
<li>平均文件访问时间23s</li>
</ul>
</li>
</ul>
<p><img src="./images/data_security/10.png" alt="image-20200310112641593" /></p>
<h3 id="dlt-sdlt"> DLT/SDLT</h3>
<p>容量中等速度慢</p>
<ul>
<li>SDLT-320</li>
<li>SDLT-640</li>
</ul>
<p><img src="./images/data_security/11.png" alt="image-20200310112641593" /></p>
<h3 id="ait"> AIT</h3>
<p>容量小速度快</p>
<ul>
<li>AIT-2</li>
<li>AIT-3</li>
</ul>
<p><img src="./images/data_security/12.png" alt="image-20200310112641593" /></p>
<h3 id="综合比较"> 综合比较</h3>
<p><img src="./images/data_security/13.png" alt="image-20200310112641593" /></p>
<h3 id="备份介质比较"> 备份介质比较</h3>
<p><img src="./images/data_security/14.png" alt="image-20200310112641593" /></p>
<h3 id="磁带机品牌"> 磁带机品牌</h3>
<h4 id="it厂商"> IT厂商</h4>
<p>HP、IBM、Exabyte</p>
<h4 id="存储厂商"> 存储厂商</h4>
<p>Storage Tek、.....</p>
<h3 id="磁带的保存"> 磁带的保存</h3>
<p>前期采购投入低，本身便宜但是后期维护成本高，存储协议之间兼容性差，磁盘存储不安全可被篡改，易丢失</p>
<ul>
<li>整体保存时间为十年</li>
<li>温度（保存场地需要对温度进行控制）
<ul>
<li>过高会数据丢失</li>
<li>过低会磁带损失</li>
</ul>
</li>
<li>湿度（保存场地需要对湿度进行控制）
<ul>
<li>湿度过高会导致磁带发霉</li>
</ul>
</li>
<li>定期倒带导致老化
<ul>
<li>如果不定期倒带会导致寿命降低老化</li>
</ul>
</li>
<li>磁带读写寿命短
<ul>
<li>一般磁带的读写次数不超过2000次</li>
</ul>
</li>
</ul>
<h2 id="磁带库"> 磁带库</h2>
<h3 id="基本组成"> 基本组成</h3>
<ul>
<li>库体和机械臂
<ul>
<li>自动化介质管理的基础</li>
<li>机槭臂的性能和可靠性在特定环境中要求较髙</li>
</ul>
</li>
<li>磁带机驱动器
<ul>
<li>类型：决定了数据昋吐能力、存储容量、数据査询速度，以及可靠性等基础指标</li>
<li>数量：决定了整个磁带库的总数据吞吐和处理能力</li>
</ul>
</li>
<li>磁带戒指存储槽位</li>
<li>其他附属部件</li>
</ul>
<h4 id="磁带库构成示意图"> 磁带库构成示意图</h4>
<h4 id="驱动器"> 驱动器</h4>
<h4 id="二维机械臂"> 二维机械臂</h4>
<h4 id="自由旋转机械臂"> 自由旋转机械臂</h4>
<h4 id="企业级自带库机械臂运动方式"> 企业级自带库机械臂运动方式</h4>
<h4 id="磁带仓"> 磁带仓</h4>
<h4 id="磁带标签"> 磁带标签</h4>
<ul>
<li>唯一的</li>
</ul>
<h4 id="驱动器的清洗"> 驱动器的清洗</h4>
<ul>
<li>自动清洗</li>
<li>主机清洗</li>
<li>手动清洗</li>
</ul>
<h4 id="磁带的保存-2"> 磁带的保存</h4>
<ul>
<li>整体保存时间为十年</li>
<li>温度</li>
<li>湿度</li>
</ul>
<h4 id="数据备份-2"> 数据备份</h4>
<ul>
<li>以SAN为中心的告诉、大容量数据备份</li>
<li>传统的基于LAN的数据备份</li>
<li>进行数据级的灾难恢复：方式不可抗力导致的数据丢失</li>
</ul>
<h4 id="磁带库的应用领域"> 磁带库的应用领域</h4>
<p>基本上只有归档存储的时候才会使用磁带库</p>
<ul>
<li>海量数据的归档</li>
</ul>
<h4 id="为什么要使用磁带库"> 为什么要使用磁带库</h4>
<ul>
<li>自动化管理大量磁带</li>
<li>自动化管理大量数据</li>
<li>消除人工误操作</li>
<li>提高数据保护和存储管理的效率</li>
</ul>
<h4 id="磁带库厂商"> 磁带库厂商</h4>
<p><img src="./images/data_security/image-20200317084957710.png" alt="image-20200317084957710" /></p>
<h2 id="vtl技术介绍"> VTL技术介绍</h2>
<h3 id="概念"> 概念</h3>
<p>虚拟磁带库 virtual Tape Library VTL，由磁盘构成，性能虽然好但是由于磁盘所以前期价格比较贵</p>
<ul>
<li>通过固化了专门软件的控制器，使磁盘（阵列）对主机或应用软件体现为常规物理磁带库，也称作虚拟磁带库。</li>
<li>标准的SCSI、FC或ISCSI主机接口，采用易用的管理软件配置、管理虚拟磁带库设备</li>
</ul>
<h3 id="虚拟磁带库架构"> 虚拟磁带库架构</h3>
<h3 id="虚拟磁带库实现方式"> 虚拟磁带库实现方式</h3>
<ul>
<li>
<p>纯软件方式VTL</p>
<p>整体性能一般、实现成本较低</p>
</li>
<li>
<p>专用服务器级VTL</p>
<ul>
<li>新能比纯软件快、价格也比纯软件贵，数据受主机的影响小，不足是系统优化性较低</li>
</ul>
</li>
<li>
<p>专用控制级VTL</p>
<ul>
<li>性能比专用服务器级快</li>
</ul>
</li>
</ul>
<h3 id="虚拟磁带库特点"> 虚拟磁带库特点</h3>
<p>去掉了机械手臂、磁带驱动器，传输速率高，但整体规模较大，不方便携带</p>
<ul>
<li>虚拟磁带库</li>
<li>虚拟驱动器</li>
<li>机械臂</li>
<li>虚拟磁带</li>
<li>数据传输</li>
<li>数据增值服务</li>
<li>对备份应用的影响</li>
</ul>
<h4 id="细分"> 细分</h4>
<ul>
<li>
<p>磁带库系统</p>
<p>不同虚拟磁带库架构之间是兼容的</p>
<ul>
<li>同一个物理的虚拟磁带库设备，可同时虚拟成多个磁带库系统；有些设备可提供8个甚至更多</li>
<li>可同时提供数据备份</li>
</ul>
</li>
<li>
<p>虚拟驱动器</p>
<ul>
<li>全面支持现有物理驱动器类型</li>
<li>支持设备数量
<ul>
<li>理论上没有数据限制</li>
</ul>
</li>
<li>通用标准接口</li>
</ul>
</li>
<li>
<p>机械臂</p>
</li>
<li>
<p>磁带</p>
<ul>
<li>全面支持现有物理磁带类型</li>
<li>可自定义的数据容量格式</li>
<li>与真实磁带的全面兼容、可进行真实磁带和虚拟磁带间的数据备份</li>
</ul>
</li>
<li>
<p>数据传输</p>
<ul>
<li><img src="./images/data_security/image-20200317090550373.png" alt="image-20200317090550373" /></li>
</ul>
</li>
<li>
<p>虚拟磁带</p>
<ul>
<li>数据压缩</li>
<li>重复数据删除</li>
<li>数据生命周期管理</li>
<li>数据加密</li>
<li>数据访问权限管理</li>
</ul>
</li>
<li>
<p>对数据备份应用的影响</p>
<ul>
<li>备份模式的转变
D-D、D-D-T、D-VTL</li>
<li>数据备份与数据归档的渐行渐远，已逐渐不使用</li>
<li>对备份窗口的策略
<ul>
<li>增量备份、差异备份逐渐转变为全备份</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="磁盘-磁带价格走势"> 磁盘/磁带价格走势</h3>
<p>逐年下降，磁盘接近磁带的价格</p>
<h3 id="磁盘-磁带的应用规划"> 磁盘/磁带的应用规划</h3>
<p>磁盘替代了许多磁带的应用领域</p>
<h3 id="备份-归档存储方式规划"> 备份/归档存储方式规划</h3>
<p>存储呈阶梯式存储简单说你可以将新能好价格高的硬件保留使用频繁的数据，将性能一般价格适中或性能低价格低的存储设备存放不经常使用的数据</p>
<ul>
<li>
<p>存储方式不同</p>
<ul>
<li>备份
<ul>
<li>在线备份</li>
<li>近线备份</li>
<li>离线备份</li>
<li>离线存档</li>
</ul>
</li>
<li>归档</li>
</ul>
<p><img src="./images/data_security/image-20200317091357770.png" alt="image-20200317091357770" /></p>
</li>
<li>
<p>设备/介质选择不同</p>
</li>
</ul>
<h3 id="磁盘库优缺点"> 磁盘库优缺点</h3>
<ul>
<li>优点
<ul>
<li>超大容量，可实现PB级别数据存储，单位容量价格低</li>
<li>可移动介质，便于离线和异地保存，磁带可以直接移动</li>
<li>广泛的备份管理软件支持，备份策略均针对磁带库结构定制和优化</li>
</ul>
</li>
<li>缺点
<ul>
<li>维护负担高
<ul>
<li>磁带库的核心部件磁带驱动器为非封闭机械易损件，本身故障率高，灰尘、潮湿等使故障率不可预期，导致设备可用性差</li>
</ul>
</li>
<li>备份容易出错
<ul>
<li>采用磁带库进行数据保护的介质磁带为非封闭介质，且磁带库中的磁带之间没有容错保护。备份业务涉及到的磁带组中任一盘磨损、卡带、霉点、粘连等，均会导致整个备份无法恢复</li>
</ul>
</li>
<li>备份恢复能力不佳
<ul>
<li>虽然磁带本身的读写速度已有长足提高，但备份恢复时需要抓带、加载、机械定位文件等机械动作，等待时间长，而备份恢复时一般会设计多带查找，应用端被迫因此延长，而备份恢复时一般会设计多带查找应用端被迫因此延长待机时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="磁盘备份的优缺点"> 磁盘备份的优缺点</h3>
<ul>
<li>磁盘备份（D2D)的优点：
<ul>
<li>与磁带不同，基于ATA的磁盘阵列比传统的光纤通道磁盘阵列的成本低很多，同时逐渐变得非常流行，它可以方便集成到备份系统中</li>
<li>可以解决磁带库固有的问题</li>
</ul>
</li>
<li>磁盘备份（D2D)的缺点：
<ul>
<li>以一个文件目录作为一个备份设备且只对应一个备份卷</li>
<li>备份数据通过文件系统写入磁盘目录</li>
<li>文件系统写速度慢</li>
<li>文件系统容易遭到人为破坏</li>
<li>备份策略需要重新制定</li>
</ul>
</li>
</ul>
<h3 id="虚拟磁带库的优缺点"> 虚拟磁带库的优缺点</h3>
<p>可成为在线应用与备份归档，可以处理数据量大要求速度快的场景</p>
<ul>
<li>优点
<ul>
<li>方便集成、兼容性好，去掉了几乎所有磁带库的缺点</li>
<li>设备可用性提升：虚拟磁带用电子化的机械手和磁带驱动器，代替了机械磁带库中裸、易损的系列机械装置，基于RAID保护的磁盘阵列具备降级工作能力，且具自动报警和在线热恢复能力</li>
<li>备份可靠性提升：虚拟磁带库采用基于RAID保护的磁盘阵列，从而将备份的可靠性较常规磁带备份提高了若干量级。封闭式结构的磁盘介质本身的MTBF（平均无故障间隔）一般为开放式结构的磁带介质的5倍以上。</li>
<li>恢复工作极为渐变：如果所需数据存在VTL当中则不会设计任何机械工作，恢复工作就像磁盘备份的速度一样</li>
</ul>
</li>
<li>缺点
<ul>
<li>备份介质不能直接移动，存储容量有限</li>
<li>价格高</li>
</ul>
</li>
</ul>
<h3 id="常见的几种设备与存储方式"> 常见的几种设备与存储方式</h3>
<h2 id="硬盘"> 硬盘</h2>
<h3 id="什么是硬盘"> 什么是硬盘</h3>
<p>硬盘HD</p>
<h3 id="工作方式"> 工作方式</h3>
<ul>
<li>磁电转换，硬盘存储数据是根据电、磁转换的原理来实现的</li>
<li>硬盘驱动器加电后，磁盘片由主轴电机驱动进行高速旋转，设置在盘片表面的磁头则在电路控制下径向移动到指定位置然后将数据存储或读出来。</li>
</ul>
<h3 id="硬盘发展简史"> 硬盘发展简史</h3>
<p>早期硬盘非常大所以没有使用，1968年沿用至今，硬盘也叫温盘</p>
<p>2000年3月，IBM推出“玻璃”硬盘，玻璃-为了降低成本通过将植物纤维提取制作而成，由于植物没有金属磁电能力好，所以后期亏本将其硬盘部门卖出给日本</p>
<p>2007年，硬盘进入TB时代，国内2015年才开始21</p>
<p><img src="./images/data_security/image-20200317102448921.png" alt="image-20200317102448921" /></p>
<h4 id="早期的硬盘"> 早期的硬盘</h4>
<p>早期硬盘非常重也非常昂贵，由于当时非常贵，所以IBM用出租的方式盈利，早期DOS系统也很小，所以使用软盘就可以代替，此时硬盘为M级别</p>
<p><img src="./images/data_security/image-20200317102644645.png" alt="image-20200317102644645" /></p>
<p>G级别的硬盘，最后那台机器为第一台自带硬盘的主机</p>
<p><img src="./images/data_security/image-20200317102752668.png" alt="image-20200317102752668" /></p>
<h3 id="小知识"> 小知识</h3>
<ul>
<li>
<p>为什么现在硬盘是c盘？因为，a盘留给了：软盘，b盘留给了：磁盘</p>
</li>
<li>
<p>磁盘（温盘）里面会保持气密性，会将里面的空气净化，磁头在读写中会与磁盘盘片精密接触，头发丝的距离，7200/60转一秒钟转120次，若有尘埃灰尘就会产生上下振动，若向下则会物理撞击，则会产生小坑，每过一次小坑则会产生振动导致产生更多的小肯</p>
</li>
<li>
<p>笔记本的硬盘较为特殊，会有移动监测区域，若超过阈值则命令硬盘停止工作移动至停泊区避免损坏硬盘</p>
</li>
<li>
<p>不到万不得已，若要开盘更换损害部件则要在超净台操作，开盘价格约在1500，超净台价格在几万到几十万不等</p>
</li>
</ul>
<h3 id="硬盘的结构"> 硬盘的结构</h3>
<p>硬盘主要由：盘片，磁头，盘片转轴及控制电机，磁头控制器，数据转换器，接口，缓存等几个部分组成。</p>
<p>硬盘尺寸主要有5.25英寸和3.5英寸，现在普遍是3.5</p>
<p>笔记本的有2.5、1.8和0.9</p>
<h3 id="硬盘的主要部件"> 硬盘的主要部件</h3>
<p>拆解硬盘需要有内六角的起子打开，硬盘一旦拆开就要报废，左上角的为控制电路板，如今已经缩减为一半大小，中间的为盘片，盘片中间为液态轴承马达</p>
<p><img src="./images/data_security/image-20200317102937973.png" alt="image-20200317102937973" /></p>
<h3 id="硬盘的外部结构"> 硬盘的外部结构</h3>
<p>外面都会有标签，都会标有编号、产地等信息</p>
<p>5VDC，5V五伏，DC直流电压</p>
<p><img src="./images/data_security/image-20200317103159204.png" alt="image-20200317103159204" /></p>
<h3 id="硬盘背面"> 硬盘背面</h3>
<p>绿色的为控制电路板，圆形是液态轴承马达</p>
<p><img src="./images/data_security/image-20200317103740901.png" alt="image-20200317103740901" /></p>
<h3 id="接口"> 接口</h3>
<h3 id="固定面板"> 固定面板</h3>
<p>硬盘是整体密封的，与外界隔绝，内部防水防尘，</p>
<p>里面有个透气孔是为了防止热胀冷缩所以放了个透气孔保持内外气压平衡，透气孔是有过滤膜可防水的</p>
<p><img src="./images/data_security/image-20200317103921518.png" alt="image-20200317103921518" /></p>
<h3 id="控制电路板"> 控制电路板</h3>
<p>其内部控制电路板可以说是一台完整的电脑，有CPU（中间最大的方框）有内存（左边长条的）</p>
<p><img src="./images/data_security/image-20200317104034206.png" alt="image-20200317104034206" /></p>
<h3 id="硬盘的内部结构"> 硬盘的内部结构</h3>
<p>中间的液态轴承马达带动盘片旋转，读写磁头的磁头非常的小，支架里的马达带动传动手臂左右移动读写</p>
<p><img src="./images/data_security/image-20200317104357652.png" alt="image-20200317104357652" /></p>
<p><img src="./images/data_security/image-20200317104407008.png" alt="image-20200317104407008" /></p>
<h3 id="机械硬盘的磁头技术"> 机械硬盘的磁头技术</h3>
<h4 id="浮动磁头组件"> 浮动磁头组件</h4>
<p>磁头加点后高速旋转，与盘片接触间隙只有0.1~0.3μm</p>
<p>下面有4个磁头，磁头要动是一起动的</p>
<p><img src="./images/data_security/image-20200317105354594.png" alt="image-20200317105354594" /></p>
<h4 id="磁头技术"> 磁头技术</h4>
<p><img src="./images/data_security/image-20200317105545967.png" alt="image-20200317105545967" /></p>
<h3 id="硬盘的接口"> 硬盘的接口</h3>
<p>IDE、scsl、 Serial ata、UsB、 Fibre channel、EEE1394
最常见的就是|DE和Sera|ATA</p>
<ul>
<li>IDE</li>
<li>SCSI
<ul>
<li>常用于服务器</li>
<li>优点
<ul>
<li>性能好</li>
</ul>
</li>
<li>缺点
<ul>
<li>价格昂贵</li>
</ul>
</li>
</ul>
</li>
<li>SATA
<ul>
<li>接口是L型的防呆设计可防止差错</li>
<li>一般可电脑挂载2个大一点可挂载4个</li>
<li><img src="./images/data_security/image-20200317105852764.png" alt="image-20200317105852764" /></li>
<li>特点
<ul>
<li>针脚小，解决了干扰问题</li>
</ul>
</li>
</ul>
</li>
<li>SAS
<ul>
<li>串口连接
<ul>
<li>传输速率高针对高性能企业</li>
<li>可靠性高</li>
</ul>
</li>
</ul>
</li>
<li>FC
<ul>
<li>光纤接口</li>
</ul>
</li>
</ul>
<h3 id="硬盘的性能指标"> 硬盘的性能指标</h3>
<ul>
<li>转速
<ul>
<li>7200RPM和5200RPM，高速10000RPM甚至15000RPM
同一款硬盘其中一个比较便宜可能就是转速比较低</li>
</ul>
</li>
<li>单碟容量
<ul>
<li>单碟容量越高传输速率越高</li>
</ul>
</li>
<li>高速缓存</li>
<li>最大内部数据传输速率
<ul>
<li>从磁头到硬盘的速度</li>
</ul>
</li>
<li>外部数据传输储率</li>
<li>寻道时间
<ul>
<li>磁头从停泊区移动到正确数据磁道上的时间</li>
</ul>
</li>
<li>潜伏期</li>
<li>全程访问时间
<ul>
<li>将前面所有的时间加起来</li>
</ul>
</li>
<li>连续无故障时间（MTBF）
<ul>
<li>MTBF至少30,000小时以上（3年以上）</li>
<li>保修期低于1年强烈建议不要买</li>
</ul>
</li>
</ul>
<h3 id="磁盘使用的基数"> 磁盘使用的基数</h3>
<ul>
<li>新型磁头技术</li>
<li>SMART技术
<ul>
<li>类似上一次突然断电则开机提示自检</li>
</ul>
</li>
<li>SPS防震技术</li>
</ul>
<h3 id="硬盘工作模式"> 硬盘工作模式</h3>
<ul>
<li>LBA（主流）</li>
</ul>
<h3 id="其他类型硬盘"> 其他类型硬盘</h3>
<ul>
<li>移动硬盘
<ul>
<li>伪移动硬盘：有的商家利用笔记本硬盘+USB转换接口套壳卖出，价格为正常移动硬盘的一半，且防护性非常低，且接口可能会有多个</li>
</ul>
</li>
<li>闪存
<ul>
<li>闪存卡</li>
<li><img src="./images/data_security/image-20200317111249553.png" alt="image-20200317111249553" /></li>
<li>记忆棒与早期MP3内存在的闪存</li>
</ul>
</li>
<li>U盘</li>
</ul>
<h3 id="常见硬盘介绍"> 常见硬盘介绍</h3>
<p>外观都差不多</p>
<ul>
<li>IBM（现为日立）-现为笔记本硬盘</li>
<li>迈拓</li>
<li>希捷 - 多为台式机机械硬盘</li>
<li>部数据 - 多为台式机机械硬盘</li>
<li>三星</li>
</ul>
<h3 id="硬盘的指标"> 硬盘的指标</h3>
<ul>
<li>转速</li>
<li>无故障连续时间MTBF</li>
</ul>
<h2 id="硬盘-数据恢复的基本知识"> 硬盘 - 数据恢复的基本知识</h2>
<p><a href="https://www.bilibili.com/video/BV11a4y1x7PC?from=search&amp;seid=14727328474968185319" target="_blank" rel="noopener noreferrer">硬盘的结构</a></p>
<p>sector - 扇区</p>
<h3 id="温盘结构特点如下"> 温盘结构特点如下：</h3>
<ul>
<li>磁头、盘片及运动机构密封在盘体内。</li>
<li>磁头在启动、停止时与盘片接触，在工作时因盘片高速旋转，带动磁头“悬浮”在盘片上面呈飞行状态（空气动力学原理）</li>
<li>磁头工作时与盘片不直接接触。</li>
<li>磁盘表面非常平整光滑，可以做镜面使用。</li>
</ul>
<h3 id="硬盘逻辑结构"> 硬盘逻辑结构</h3>
<p><img src="./images/data_security/image-20200421085922302.png" alt="image-20200421085922302" /></p>
<p><img src="./images/data_security/image-20200421085945176.png" alt="image-20200421085945176" /></p>
<p>磁头编号从0开始</p>
<h3 id="盘片"> 盘片</h3>
<ul>
<li>盘片一般用铝合金做基片，也有用玻璃做基片的。每个盘片都有两个盘面（上、下），都可以装上磁头存储数据，形成有效盘面。有效的盘面都有一个盘面号，从0开始；在硬盘系统中，盘面号又叫磁头号；</li>
<li>一般硬盘有2-3个盘片，所以磁头号为0-3或者0-5</li>
</ul>
<h3 id="磁道"> 磁道</h3>
<p>编号从0开始</p>
<ul>
<li>磁盘在格式化时被划分成许多同心圆，这些同心圆轨迹叫做磁道（ track）.磁道从外冋内从0开始顺序编号。一个盘面有300-1024个磁道，大容量的磁盘盘面磁道更多。</li>
<li>从外面开始一圈一圈往里面走</li>
</ul>
<h3 id="柱面"> 柱面</h3>
<p>为何每个文件管理中每个盘有的时候不是整数，而是少了那么一点，因为磁盘是以柱面为单位，分区的时候是将柱面划分给指定的分区，假如在哪个分区内刚好有个柱面小于一般，则默认忽略不算，所以就会出现59.9之类的情况</p>
<ul>
<li>所有盘面上的同一个磁道构成一个圆柱，称为柱面（ cylinder）.柱面上的磁头，从上而下从0开始编号。</li>
<li>数据的读写是按柱面进行的，即磁头首先在同个柱面内从0磁头开始读写操作，依次向下（1、2.…….）在同一个柱面的磁头上操作</li>
</ul>
<h3 id="扇区"> 扇区</h3>
<p>编号从1开始</p>
<ul>
<li>作为同心圆的磁道不是连续记录数据的，被划分成一段段的圆弧，这些圆弧叫做扇区（sector），从1开始编号。</li>
<li>操作系统以扇区形式存储信息。每个扇区为512字节（byte），分为两个部分：存储标识符和数据</li>
<li>交叉因子
<ul>
<li>若一个扇区，写着123456789扇区，此时磁头在扇区1的起始位置，当磁头读取扇区1的数据，由于磁头读取时需要时间导致磁头可能没有读取完数据1就已经”飞行“到了扇区2中间上了，于是就需要重新转一圈后才能到达2的起始位置，所以就出现交叉因子</li>
<li>交叉因子的扇区，就是交换了扇区编号，例如172839456，读取了1后再转多一点到达2的起始位置就不会出现上面那张情况</li>
</ul>
</li>
</ul>
<h3 id="容量"> 容量</h3>
<p>1KB是2个扇区，1个扇区是0.5KB</p>
<ul>
<li>
<p>硬盘的容量由盘面数（磁头数）、柱面数、扇区数决定，计算公式为：</p>
</li>
<li>
<p><strong>划分</strong> <code>容量=盘面数*柱面数*扇区数*512字节</code></p>
<div><pre><code>1KB=2^10B=1024Byte
1MB=2^10KB=2^20B=1048576Byte
1GB=2^10MB=2^20KB=2^30B=1073741824Byte
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
</ul>
<h4 id="磁盘容量大小计算"> 磁盘容量大小计算</h4>
<p>实际上就是得到十六进制后换算成十进制后*512/1024/1024/1024</p>
<p>在winhex中使用读取硬盘的十六进制数来计算硬盘容量的大小</p>
<p><img src="./images/data_security/image-20200421102754697.png" alt="image-20200421102754697" /></p>
<p>可以看到十六进制值为<code>8020210007FEFFFF0008000000F07F07</code></p>
<ul>
<li>前八位：起始的自举标志为80说明安装了操作系统，202100为CHS的起始地址，07为NTFS格式，FEFFFF为结束地址</li>
<li>后八位：winhex中的数据计算都需要反过来读
<ul>
<li>00080000分区的起始地址  --  00 00 08 00</li>
<li>00F07F07为分区的大小 -- 07 7F 0F 00
<ul>
<li>分区大小的计算，将十六进制为<code>125767424*512/1024/1024/1024</code>=59，结果却是为59GB</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="硬盘寻址"> 硬盘寻址</h3>
<p>硬盘寻址模式</p>
<ul>
<li>C/H/S（磁头+柱面数+扇区数）</li>
<li>LBA（扇区逻辑块地址）</li>
<li>C/H/S和LBA可以相互转换</li>
</ul>
<p><img src="./images/data_security/image-20200421092756132.png" alt="image-20200421092756132" /></p>
<h3 id="硬盘缺陷介绍"> 硬盘缺陷介绍</h3>
<ul>
<li>缺陷扇区
<ul>
<li>扇区若永久损坏则永久上不可修复，软件上也只是逻辑上标记出指定扇区为坏扇区而已，实际上不可修复</li>
</ul>
</li>
<li>磁道伺服缺陷
<ul>
<li>所有数据都是从0磁道开始读写，0磁道上放置的是系统引导信息，若0磁道损坏了则需要将其修复，将硬盘的起始位置挪一挪避开0磁道</li>
<li>windows磁道工具只能从默认0磁道开始</li>
</ul>
</li>
<li>磁头组件缺陷
<ul>
<li>更换电路板</li>
</ul>
</li>
<li>系统信息错乱
<ul>
<li>重装系统</li>
</ul>
</li>
<li>电子线路缺陷</li>
<li>综合新能缺陷</li>
</ul>
<h2 id="硬盘分区"> 硬盘分区</h2>
<h3 id="分区目前有两种方式"> 分区目前有两种方式</h3>
<ul>
<li>MBR
<ul>
<li>传统的使用方式，最大支持硬盘容量有限，最大支持为2TB，最多有4个主要分区，可以吧一个主分区变成扩展分区，扩展分区拥有无数个逻辑分区</li>
</ul>
</li>
<li>GPT</li>
</ul>
<h2 id="mbr"> MBR</h2>
<ul>
<li>
<p>在MBR上分区和启动信息都是保存在一起的，如果这部分数据被覆盖或者破坏就麻烦了</p>
</li>
<li>
<p>硬盘需要经过低格、分区、高级格式化后才能使用</p>
</li>
<li>
<p>低格</p>
<ul>
<li>作用：测试硬盘介质、为硬盘划分磁道、指定交叉因子，安排扇区、写入扇区i，完成扇区设置、对磁盘表面测试，标记损坏磁道和扇区</li>
<li>完成逻辑划分工作，检测每个逻辑扇区好坏，低格之后数据就<strong>全部丢失了</strong></li>
<li>厂商出厂或者使用纯DAO系统的format功能</li>
</ul>
</li>
<li>
<p>分区</p>
<p>便于硬盘的规划和文件的管理、有效的利用空间、提高系统效率、建立MBR</p>
<ul>
<li>分区粒度--分区最小单位是柱面</li>
<li>每个盘都会记录其分区信息</li>
<li>将硬盘划分为一个个逻辑区域。每个分区有确定的起、止位置</li>
<li>分区的信息记录在一个特殊位置的扇区，称为硬盘主引导记录（ Master boot recorder，MBR）或主引导扇区</li>
<li>MBR位于0磁头，0磁道，1扇区</li>
</ul>
</li>
<li>
<p>MBR区</p>
<ul>
<li>MBR，即主引导记录区，位于整个硬盘的0磁道0柱面1扇区。在总共<strong>512字节</strong>的主引导扇区中，MBR的引导程序占用其中的前446个字节（偏移0~偏移1BDH），随后的64个字节（偏移旧EH一偏移|FDH为 DPT（Disk PartitionTable，硬盘分区表），最后的两个字节“55AA&quot;（偏移EH一偏移1FFH）是分区有效结束标志。由它们共同构成硬盘主引导记录，也称主引导扇区。</li>
<li>其中第1-446个字节是用来调用操作系统的机器码的</li>
<li>第447-510个字节是分区表的位置</li>
<li>第511-512个字节是主引导记录签名，也就是0x55和0xAA，通过这种结尾方式判断从哪个应道设备进行应道</li>
<li>MBR一般占用63个扇区（实际只占用1个扇区）</li>
<li><img src="./images/data_security/image-20200421094822049.png" alt="image-20200421094822049" /></li>
</ul>
</li>
</ul>
<h3 id="mbr的主引导-分区表"> MBR的主引导：分区表</h3>
<p>主引导记录必须要知道我将控制权给谁，分区表的长度只有64个字节，里面分成4个项，每个项占16个字节，所以一个硬盘最多只能分四个以及的分区，这四个又叫主分区，在第13、14、15、16个Byte是主分区的扇区总数，这决定了主分区的容量，其中计算可以查看下面的磁盘查看，虽然可以使用扩展分区，但是还是推荐单碟机械硬盘超过2TB都推荐用GPT而不是MBR</p>
<h3 id="mbr构成"> MBR构成</h3>
<ul>
<li>一个扇区的硬盘主引导记录MBR由的4个部分组成
<ul>
<li>主引导程序</li>
<li>出错信息数据区</li>
<li>分区表</li>
<li>结束标志字</li>
</ul>
</li>
<li>分区表含义
<img src="./images/data_security/image-20200421102235680.png" alt="image-20200421102235680" />
前八位自举标志，要么00要么80，后八位为本分区之前已用扇区数，最后四位为整个分区的大小</li>
<li>分区类型
<ul>
<li><img src="./images/data_security/分区类型.png" alt="image-20200421102235680" /></li>
</ul>
</li>
</ul>
<h3 id="磁盘查看"> 磁盘查看</h3>
<p><img src="./images/data_security/image-20200421102754697.png" alt="image-20200421102754697" /></p>
<p>可以看到十六进制值为<code>8020210007FEFFFF0008000000F07F07</code></p>
<ul>
<li>
<p>前八位：起始的自举标志为80说明安装了操作系统，202100为CHS的起始地址，07为NTFS格式，FEFFFF为结束地址</p>
</li>
<li>
<p>后八位：winhex中的数据计算都需要反过来读</p>
<ul>
<li>00080000分区的起始地址  --  00 00 08 00</li>
<li>00F07F07为分区的大小 -- 07 7F 0F 00
<ul>
<li>分区大小的计算，将十六进制为<code>125767424*512/1024/1024/1024</code>=59，结果却是为59GB</li>
</ul>
</li>
</ul>
</li>
<li>
<p>假如在MBR系统中有这一串</p>
</li>
<li>
<div><pre><code>00 01 01 00 07 FE FF FF 3F 00 00 00 9A E5 3F 01
前八位：
00 - 起始的自举标志，80说明安装了操作系统，00表示没有
01 01 00 - CHS的其实位置
07 - NTFS格式
FE FF FF 3F - 结束地址
后八位：
3F 00 00 00 --- 00 00 00 3f
9A E5 3F 01 --- 01 3f e5 9a
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></li>
</ul>
<h3 id="虚拟分区技术"> 虚拟分区技术</h3>
<p>可以从winhex的十六进制中可以看出此表上只能分4个分区，多余4个分区的时候就需要采用虚拟分区表</p>
<ul>
<li>主引导记录最多记录4个分区，多于4个分区的时候，采用虚拟分区表的办法</li>
<li>即主分区在记录分区时，将多余容量记录为扩展分区</li>
<li>像是链式那样，一环接一环，要读取E盘就要先读取C和D盘，每个盘内都有一个MBR分区表，这样可以扩展出更多的硬盘，但缺点是假如D盘的MBR分区表出了问题，EF盘都不能读取！</li>
</ul>
<p><img src="./images/data_security/image-20200421105735527.png" alt="image-20200421105735527" /></p>
<h2 id="gpt"> GPT</h2>
<p>全局唯一标识分区表，GPT是一种基于计算机中可扩展固件接口（EFI）使用的磁盘分区架构，他与UEFI相辅相成，UEFI是用来替代BIOS的</p>
<h3 id="guid分区表"> GUID分区表</h3>
<p>这是一个随机生成的字符串，在MBR上分区和启动信息都是保存在一起的，如果这部分数据被覆盖或者破坏就麻烦了，相对的GPT在整个磁盘上保存了多个这部分信息的副本，他可以恢复被破坏的这部分信息，GPT还未这些信息保存了循环冗余校验码（CRC）以保证其完整和正确——如果数据被破坏GPT会发觉并从磁盘上的其他地方进行修复</p>
<h4 id="什么是-guid"> 什么是 GUID？</h4>
<p>全球唯一标识符 (GUID) 是一个字母数字标识符，用于指示产品的唯一性安装。在许多流行软件应用程序（例如 Web 浏览器和媒体播放器）中，都使用 GUID。</p>
<p>GUID 的格式为“xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx”，其中每个 x 是 0-9 或 a-f 范围内的一个十六进制的数字。例如：6F9619FF-8B86-D011-B42D-00C04FC964FF 即为有效的 GUID 值。</p>
<h4 id="为什么要用guid"> 为什么要用GUID</h4>
<p>世界上的任何两台计算机都不会生成重复的 GUID 值。GUID 主要用于在拥有多个节点、多台计算机的网络或系统中，分配必须具有唯一性的标识符。在 Windows 平台上，GUID 应用非常广泛：注册表、类及接口标识、数据库、甚至自动生成的机器名、目录名等。</p>
<h3 id="gpt分区表结构"> GPT分区表结构</h3>
<p>当头部丢失的时候可以在尾部读取镜像恢复</p>
<ul>
<li>保护MBR
<ul>
<li>保护MBR与正常的MBR区别不大，主要是分区表上的不同，在保护MBR中只要一个表示为0xEE的分区，一次来表示这块硬盘使用GPT分区表</li>
</ul>
</li>
<li>首要GPT头
<ul>
<li><img src="./images/data_security/image-20200421231051355.png" alt="image-20200421231051355" /></li>
</ul>
</li>
<li>首要GPT</li>
<li>磁盘数据区</li>
<li>备用GPT</li>
<li>备用GPT头</li>
</ul>
<p><img src="./images/data_security/image-20200421110937813.png" alt="image-20200421110937813" /></p>
<h3 id="lba0"> LBA0</h3>
<h3 id="lba1"> LBA1</h3>
<p>分区表头，最多可以创建128个分区</p>
<h2 id="总结"> 总结</h2>
<p>在装电脑中最好使用UEFI+GPT格式，更安全，支持的容量更大</p>
<h1 id="存储主要技术架构"> 存储主要技术架构</h1>
<h2 id="das直连存储"> DAS直连存储</h2>
<p>DAS需要得到服务器的许可才能操作</p>
<h3 id="存储设备直接加在到主机上"> 存储设备直接加在到主机上</h3>
<ul>
<li>在一个DAS模式中何一个存储设备是被直接连接到服务器上。服务器是访问连接其白身存储资源的唯一单点。</li>
<li>服务器连接到一个图地网终（LAN），个服务器就变成了在客户端工作站和存储资源之间的一个网关</li>
</ul>
<h3 id="直连存储架构"> 直连存储架构</h3>
<ul>
<li>内置DAS</li>
<li>外置DAS</li>
</ul>
<p>SCSI昂贵配置复杂不容易扩展，总线支持非常短
绝大多数直连存储环境使用小型计算机接口（SCSI）技术，</p>
<h3 id="直接存储的优势与劣势"> 直接存储的优势与劣势</h3>
<h4 id="优势"> 优势</h4>
<ul>
<li>相对廉价</li>
<li>使用熟练</li>
<li>广泛应用，使用简单</li>
</ul>
<h4 id="劣势"> 劣势</h4>
<ul>
<li>扩展性差
<ul>
<li>受硬件卡槽影响，普通卡槽只有4 个，服务器可能有8个</li>
</ul>
</li>
<li>性能差</li>
<li>与LAN和应用互相影响</li>
<li>不能轻易和经济性的扩展</li>
<li>受连接距离限制
<ul>
<li>因为连接线比较短所以物理主机在哪直接存储设备就必须在哪</li>
</ul>
</li>
<li>包括很多单点故障
<ul>
<li>当物理主机出了故障会导致存储设备带来直接影响</li>
</ul>
</li>
<li>管理困难
<ul>
<li>不能批量操作，只能登陆到指定的每一台物理设备上配置</li>
</ul>
</li>
</ul>
<h3 id="das的应用场景"> DAS的应用场景</h3>
<h3 id="das环境受制约"> DAS环境受制约</h3>
<ul>
<li>只有1台服务器可以直接连接一个指定的存储资源</li>
<li>存储资源访问必须与服务器中的其他应用共同竞争服务器的CPU、内存和ⅣO总线资源。这就降低了存储系统的性能</li>
<li>访问服务器的存储资源同样受可用的局域网（LAN）带宽的限制。局域网上的访问流量可以影响对存储访问的时间和速度，存储访问也可以影响使用局域网的其他应用的性能</li>
<li>每一台服务器可以支持数量非常有限的存储设备。当达到极限时，为了增加存储容量就需要添加额外的服务器。所以，DAS不能够很轻易和经济地扩展</li>
</ul>
<h3 id="das应用"> DAS应用</h3>
<ul>
<li>RAID（磁盘阵列）</li>
<li>JBOD/SPAN（磁盘簇）</li>
</ul>
<h2 id="nas"> NAS</h2>
<h3 id="网络连接存储-nas-概述"> 网络连接存储（NAS）概述</h3>
<p>NAS（Network Attached Storage）</p>
<p>网络连接存储、或称附属存储</p>
<ul>
<li>NAS设备基本上是指那些专门提供存储资源的专用服务器，他提供即插即用的存储扩展资源</li>
<li>NAS设诶可以直接介入LAN，客户端和服务器通过LAN访问NAS上的存储资源</li>
<li>NAS设备典型的使用一个独立的文件系统平台来存储数据</li>
</ul>
<h3 id="nas架构"> NAS架构</h3>
<p><img src="./images/data_security/image-20200324090849113.png" alt="image-20200324090849113" /></p>
<h3 id="nas特点"> NAS特点</h3>
<ul>
<li>与系统无关
<ul>
<li>支持多种文件及数据共享方式</li>
<li>支持windows、linux、unix等操作系统</li>
<li>支持不同系统间对同一份数据的共享
<ul>
<li>由于有自己的操作系统，所以可以存储为自己独立的格式，若win来则读取转换成win的格式，linux来则读取转换成linux的格式</li>
</ul>
</li>
</ul>
</li>
<li>简便的安装与管理
<ul>
<li>出厂预装OS及相关软件，并进行软硬件预设值</li>
<li>支持基于Web的GUI远程管理</li>
</ul>
</li>
<li>强大的系统备份与恢复功能</li>
<li>优化的系统</li>
<li>方便的容量扩充</li>
<li>整体拥有成本TCO低
<ul>
<li>前期采购成本高，管理成本低</li>
</ul>
</li>
</ul>
<h3 id="nas的优势与劣势"> NAS的优势与劣势</h3>
<h4 id="优势-2"> 优势</h4>
<ul>
<li>访问快</li>
<li>可扩展性能好</li>
<li>使用灵活</li>
<li>性能可靠</li>
<li>易于安装和管理</li>
<li>成本低、廉价</li>
</ul>
<h4 id="劣势-2"> 劣势</h4>
<ul>
<li>本身性能是瓶颈
<ul>
<li>由于NAS设备本来是专用的一台优化后的文件服务器，所以NAS服务器本身就是一个瓶颈</li>
</ul>
</li>
<li>一个NAS设别性能也受可用网络（LAN）宽带的限制
<ul>
<li>文件传输与应用服务所使用的宽带容易受影响会出现资源争夺现象</li>
</ul>
</li>
<li>不支持数据库
<ul>
<li>不适合块级数据应用的传输——不支持数据库</li>
</ul>
</li>
</ul>
<h3 id="使用场景"> 使用场景</h3>
<p>局域网内文件级的共享访问，由于可以远程操作可以进行远程备份</p>
<h2 id="nas与das"> NAS与DAS</h2>
<ul>
<li>NAS对文件和应用的访问快于DAS，没有资源竞争的情况，</li>
<li>多服务器可以访问同一个NAS设备，增加了应用的可扩展性</li>
<li>因为服务器和客户端都在LAN上访问，提高了灵活的、分布式的存储环境，提高了安全可靠</li>
<li>NAS比DAS更可靠</li>
<li>NAS即插即用</li>
<li>因为NAS设备使用一个独立平台文件系统，任何连接到网络的主机操作系统都可以访问到NAS存储资源</li>
</ul>
<h2 id="san-存储区域网"> SAN  存储区域网</h2>
<p>SAN（Storage Area Network）</p>
<ul>
<li>
<p>存储区域网络、或称第二网络、后端网</p>
</li>
<li>
<p>将存储设备独立分开，变成了网络当中的一个节点，故障不会互相影响，管理简单</p>
</li>
<li>
<p>将存储网络独立分开成一个存储业务网络，不会影响使用者本身上网的网络</p>
</li>
<li>
<p>性能上优于DAS与NAS常用于高端环境，但是由于设备的增加所以价格会有所增加</p>
</li>
<li>
<p>广义SAN</p>
<ul>
<li>支持多种协议的SAN</li>
</ul>
</li>
<li>
<p>狭义SAN</p>
<ul>
<li>FC-SAN（用光纤作为连接SAN，所以不支持TCP/IP协议）</li>
</ul>
</li>
</ul>
<p><img src="./images/data_security/image-20200324092517735.png" alt="image-20200324092517735" /></p>
<h3 id="概述"> 概述</h3>
<ul>
<li>存储区域网络是一个由专用网络连接起来的由服务器和独立存储设备组成的</li>
<li>不像NAS设备，存储区域网络存储设备不包含任何服务器功能，并且它们不是运行一个文件系统。</li>
<li>主机负责运行和管理文件系统。在这个环境中，任何一台服务器可以访问任何一个存储设备。</li>
<li>台服务器可以访问多个存储设备，并且多个服务器可以访问同一个存储设备</li>
<li>这允许服务器和存储设备各自独立地扩充。</li>
</ul>
<h3 id="光纤通道存储区域网架构"> 光纤通道存储区域网架构</h3>
<p>主机-交换设备-存储设备（其中交换介质都是用光纤连接起来）</p>
<p>光纤通道协议传输速度上快于SCSI</p>
<h3 id="san的组成"> SAN的组成</h3>
<ul>
<li>server（服务器）</li>
<li>storage（存储设备）
<ul>
<li>磁盘阵列、磁带设备</li>
</ul>
</li>
<li>SAN fabric（连接设备）
<ul>
<li>集线器、交换机、路由器、网关、HBA卡</li>
</ul>
</li>
<li>software （管理软件）</li>
</ul>
<h4 id="san管理"> SAN管理</h4>
<p>初期的投入大</p>
<ul>
<li>资产管理</li>
<li>容量管理</li>
<li>配置管理</li>
<li>性能管理</li>
<li>可用性管理</li>
</ul>
<h3 id="san的优势与劣势"> SAN的优势与劣势</h3>
<h4 id="优势-3"> 优势</h4>
<ul>
<li>SAN提供高可扩展性
<ul>
<li>服务器、存储和带宽可以独立的被扩展</li>
</ul>
</li>
<li>可以运行数据库</li>
</ul>
<h4 id="劣势-3"> 劣势</h4>
<ul>
<li>
<p>价格高（前期投入大）</p>
</li>
<li>
<p>异构环境下的互操作性</p>
</li>
<li>
<p>管理复杂</p>
</li>
<li></li>
</ul>
<h2 id="三种存储-架构"> 三种存储 架构</h2>
<p><img src="./images/data_security/image-20200324095300668.png" alt="image-20200324095300668" /></p>
<h3 id="可扩展性和可用性"> 可扩展性和可用性</h3>
<p>SAN&gt;NAS&gt;DAS</p>
<h3 id="成本比较"> 成本比较</h3>
<h4 id="运维成本"> 运维成本</h4>
<p>SAN&gt;DAS&gt;NAS</p>
<h4 id="一次性采购成本"> 一次性采购成本</h4>
<p>SAN&gt;DAS与NAS</p>
<h3 id="三种技术架构的比较"> 三种技术架构的比较</h3>
<p><img src="./images/data_security/image-20200324095949797.png" alt="image-20200324095949797" /></p>
<h3 id="san的主要应用"> SAN的主要应用</h3>
<p>用于容灾保护</p>
<h4 id="存储整合"> 存储整合</h4>
<p>客户端用网络与服务器相连，服务器通过光纤与交换机与存储设备（存储池）相连</p>
<h4 id="提供了高性能"> 提供了高性能</h4>
<h4 id="提供了数据安全的访问"> 提供了数据安全的访问</h4>
<h4 id="高性能数据备份"> 高性能数据备份</h4>
<h5 id="lan-free备份"> LAN Free备份</h5>
<p>服务器启到中转功能，对服务器有一定影响</p>
<ol>
<li>减少备份（恢复窗口）</li>
<li>优化磁带应用（目前可能不适用）</li>
<li>降低服务器负担</li>
<li>消除对业务网络的影响</li>
</ol>
<h5 id="server-less备份"> Server Less备份</h5>
<p>服务器只起到发起功能，不在参与后续操作，可以专心对前端持续工作</p>
<ol>
<li>实现不影响应用的备份</li>
<li>消除服务器负担</li>
</ol>
<h4 id="基于数据镜像的高级容灾数据保护"> 基于数据镜像的高级容灾数据保护</h4>
<p>分布式存储</p>
<h3 id="fibre-channel-fc-san"> Fibre Channel（fc SAN）</h3>
<h2 id="fc-san定义"> FC SAN定义</h2>
<p>一种完全光纤的传输</p>
<ul>
<li>高速</li>
<li>数据整合</li>
<li>支持差错检测</li>
<li>支持远距离传输</li>
<li>支持远距离管理</li>
</ul>
<h3 id="传统的san是基于光纤完成的"> 传统的SAN是基于光纤完成的</h3>
<h3 id="光纤通道协议"> 光纤通道协议</h3>
<p><img src="./images/data_security/image-20200324110927007.png" alt="image-20200324110927007" /></p>
<p><img src="./images/data_security/image-20200324110955921.png" alt="image-20200324110955921" /></p>
<h3 id="三种拓扑架构"> 三种拓扑架构</h3>
<ul>
<li>点对点
<ul>
<li>2</li>
</ul>
</li>
<li>环型拓扑
<ul>
<li>126</li>
</ul>
</li>
<li>星型连接（主流！）
<ul>
<li>一千六百万</li>
</ul>
</li>
</ul>
<p><img src="./images/data_security/image-20200324111031525.png" alt="image-20200324111031525" /></p>
<h3 id="点对点拓扑结构"> 点对点拓扑结构</h3>
<ul>
<li>点对点拓扑是指在一台服务器和一个存储设备之间专用连接</li>
<li>点对点以光纤通道协议代替SCSI的基础直连架构</li>
</ul>
<h3 id="仲裁环拓扑结构"> 仲裁环拓扑结构</h3>
<p>光纤通道设备以环路形式连接
物理表现为Hub上的星型连接
公有/私有仲裁环路协议
（Public/Private Arbitrated Loop）</p>
<h3 id="环形拓扑结构特点"> 环形拓扑结构特点</h3>
<ul>
<li>共享带宽</li>
<li>每个Loop最多支持126个节点和1个 FL Port</li>
<li>使用LIP给每个设备指定FCAL地址</li>
<li>使用仲裁环路协议控制对介质的访问</li>
<li>私有 Private和公共 Public环</li>
<li>若节点出现单点故障则会出现速率骤降</li>
</ul>
<h3 id="星型环路交换"> 星型环路交换</h3>
<ul>
<li>中心节点一旦出现问题整个网络坏掉，解决办法是接上冗余设备</li>
</ul>
<h3 id="交换fabric拓扑"> 交换Fabric拓扑</h3>
<ul>
<li>其中FC-SW最为常用</li>
<li>any to any的全带宽连接</li>
</ul>
<h4 id="特点"> 特点</h4>
<ul>
<li>设备独享带宽</li>
<li>支持一千六百万地址空间</li>
<li>可以直接连接节点或仲裁环路/集线器</li>
<li>支持各种高级服务，用于发现和监控设备</li>
</ul>
<h3 id="hba"> HBA</h3>
<ul>
<li>为服务器或客户机内部总线（PCI和SBUS等）提供与光纤网络的接口</li>
<li>HBA软件驱动为操作系统提供所需存储信息
<ul>
<li>对I/O进行操作 I/O同时对正常请求进行控制</li>
<li>铜/光介质支持（可以是双接口卡）</li>
</ul>
</li>
</ul>
<h3 id="光电转换器"> 光电转换器</h3>
<p>小型串行到串行热交换模块，主要功能是提供相应介质接口（铜或光）</p>
<h3 id="fc的优缺点"> FC的优缺点</h3>
<ul>
<li>信息孤岛
<ul>
<li>SAN一旦形成就是一个单纯的独立网络</li>
</ul>
</li>
<li>SAN管理权的滥用
<ul>
<li>由于其是在SAN内部，所以SAN拥有最高权限可以对其进行任意操作</li>
</ul>
</li>
<li>安全技术不易统一管理
<ul>
<li>有各种技术与各种兼容性问题</li>
</ul>
</li>
<li>管理的复杂性</li>
</ul>
<h3 id="fc适应环境"> FC适应环境</h3>
<ul>
<li>高数据传输带宽要求</li>
<li>高数据访问io要求</li>
<li>高数据安全级别</li>
<li>远距离数据传输</li>
<li>块数据传输</li>
<li>数据备份</li>
<li>灾难恢复</li>
<li>数据共亨</li>
</ul>
<h2 id="ip-san-iscsi"> IP SAN（ISCSI）</h2>
<p>由于FC SAN成本比较高，所以后期改用以太网替换光纤连接虽然速度上没有FC SAN快但是降低了成本</p>
<h3 id="iscsi定义"> ISCSI定义</h3>
<p>可以理解ISCSI是IP与SCSI的融合</p>
<ul>
<li>在 Interne协议（|P）统治着局域网和广域网。 Internet小型机系统接口（iSCSI）协议整合了存储和IP网络，使通过IP网络完成存储数据块的传输成为现实。它建立在两个已被广泛应用的技术之上-为存储而建立的SCS命令和为网络化而建立的|P协议。</li>
<li>iSCSI是一种端到端的协议，用于在IP网络中传输存I/O数据块。该协议被使用于服务器（ initiator）、存储设备（ target）和协议传输网关设备。</li>
<li>iSCS使用标准的以太网交换机和路由器，将数据从服务器转移到存储设备。它还使得IP和以太网基础设施可以被用于对SAN存储系统的扩展访问，跨过任意距离完成对SAN的扩展接入。</li>
</ul>
<h3 id="iscsi协议"> ISCSI协议</h3>
<p>iSCS协议是将SCS的远程过程调用（rpc）映射到IP协议的过程。isCS|协议提供了独立于他所携带的SCSI CDB的层的概念。isCSI请求传递SCS命令，iSCSI响应处理SCSI响应和状态。</p>
<p><img src="./images/data_security/image-20200324114333471.png" alt="image-20200324114333471" /></p>
<h3 id="iscsi设备"> ISCSI设备</h3>
<ul>
<li>Taget目标器
<ul>
<li>iSCSI的存储设备称为iSCSITarget</li>
</ul>
</li>
<li>initiator启动器
<ul>
<li>iSCSI允许使用一般 Ethernet NIC卡（网络卡，为了效率多半是GbE以上等级）与 Ethernet Switch（交换器），若使用一般GbE卡，则还需要搭配软件才能让GbE卡收发isCSI协议，此软件称为iSCSI Initiator，事实上iSCS HBA的角色也等同于iSCSI Initiator.</li>
</ul>
</li>
</ul>
<h3 id="iscsi工作流程"> ISCSI工作流程</h3>
<p>在Target端和Initiator端将SCSI命令重新TCP/IP封包和解包后，即可在普通的以太网内传输</p>
<p><img src="./images/data_security/image-20200324115320094.png" alt="image-20200324115320094" /></p>
<h3 id="iscsi特性"> ISCSI特性</h3>
<ul>
<li>连通性
<ul>
<li>使用IP全局地址表，iSCSI设备增加了两个类型的表示：一个是iSCSI设备名，一个是iSCSI地址</li>
</ul>
</li>
<li>数据传输
<ul>
<li>千兆、万兆以太网接口</li>
<li>千兆，1Gb单端口理论值1000Gb/s，即125MB/s</li>
<li>万兆，10GB，1.25GB/s</li>
</ul>
</li>
</ul>
<h3 id="常用组件"> 常用组件</h3>
<ul>
<li>交换设备
<ul>
<li>以太网交换机</li>
<li>iscsi智能交换设备</li>
<li>iscsi桥接器</li>
</ul>
</li>
<li>ISCSI HBA卡
<ul>
<li>iSCSI HBA卡就是采用内建SCSI指令及TOE引起的ASIC芯片的适配卡</li>
</ul>
</li>
</ul>
<h3 id="ip-san拓扑结构"> IP SAN拓扑结构</h3>
<h3 id="iscsi优点"> ISCSI优点</h3>
<ul>
<li>建置成本低廉</li>
<li>管理门槛及维护成本更</li>
<li>节省存储资源、做好集中管理</li>
<li>没有距离的限制</li>
<li>传输速度快</li>
<li>系统兼容性好</li>
<li>人才较多*</li>
</ul>
<h3 id="使用领域"> 使用领域</h3>
<ul>
<li>数据传输连续性</li>
<li>远距离数据传输</li>
<li>块数据传输</li>
<li>数据备份</li>
<li>灾难恢复</li>
<li>多主机数据访问</li>
</ul>
<h3 id="san的广域网技术"> SAN的广域网技术</h3>
<p>主要应用技术</p>
<ul>
<li>FCIP、iFCP、iSCSI</li>
<li>DWDM、SONET、IP</li>
</ul>
<h2 id="das、nas、san与iscsi的性能特点比较"> DAS、NAS、SAN与ISCSI的性能特点比较</h2>
<p><img src="./images/data_security/image-20200324112155970.png" alt="image-20200324112155970" /></p>
<h2 id="其他补充"> 其他补充</h2>
<h3 id="fcip"> FCIP</h3>
<p>由于FCSAN容易出现信息孤岛所以出现了将光纤通过IP连接起来</p>
<ul>
<li>在 FC SAN孤岛之间依赖基于IP的网络服务提供局域网、城域网和广域网的连接</li>
<li>依赖于TCP的拥塞控制和网络管理</li>
<li>数据纠错和丢失恢复依赖于TcP和FC双重机制</li>
<li>FciP视所有的FC帧于数据报等同</li>
</ul>
<p><img src="./images/data_security/image-20200324120603153.png" alt="image-20200324120603153" /></p>
<h3 id="ifcp"> iFCP</h3>
<p>一部分用FC SAN 一部分用IP SAN</p>
<ul>
<li>网关到网关的协议，用TCP/P交换和路由设备作为 FC Fabric设备的补充或替代，来实现 FC SAN</li>
<li>将已有的FC存储产品连接到IP网络的协议</li>
</ul>
<p><img src="./images/data_security/image-20200324120712731.png" alt="image-20200324120712731" /></p>
<h3 id="iscsi"> iSCSI</h3>
<ul>
<li>运行在TCP层上的SCSI传输协议</li>
<li>在IP网络上封装SCSI命令的新机制</li>
<li>在新一代内置支持TCP/IP的存储端节点设计的协议</li>
</ul>
<p><img src="./images/data_security/image-20200324120825304.png" alt="image-20200324120825304" /></p>
<h3 id="fcip、ifcp、iscsi拓扑区别"> FCIP、iFCP、iSCSI拓扑区别</h3>
<p><img src="./images/data_security/image-20200324112521255.png" alt="image-20200324112521255" /></p>
<h3 id="广域网技术"> 广域网技术</h3>
<p>DWDM</p>
<h2 id="虚拟化存储"> 虚拟化存储</h2>
<h3 id="存储虚拟化的目的"> 存储虚拟化的目的</h3>
<ul>
<li>
<p>抽象</p>
</li>
<li>
<p>隐藏</p>
</li>
<li>
<p>隔离</p>
</li>
<li>
<p>提高设备使用效率</p>
</li>
<li>
<p>统一数据管理功能</p>
</li>
<li>
<p>设备构件化</p>
</li>
<li>
<p>降低管理难度提高可扩展性</p>
</li>
<li>
<p>数据库跨设备流动</p>
</li>
</ul>
<h3 id="用虚拟化简化it架构"> 用虚拟化简化IT架构</h3>
<ol>
<li>融合：技术基础（更可靠、更可控、更灵活、更易扩展、更低成本）</li>
<li>开放：个性化基础（SOA的标准中间件架构和应用开发接口）</li>
<li>面向应用：以应用为先导，资源动态分配、统一管理</li>
</ol>
<h3 id="磁盘虚拟化"> 磁盘虚拟化</h3>
<ol>
<li>磁盘扇区的物理地址一般用CHS（柱面号-磁头号-扇区号）表示</li>
<li>磁盘虚拟化就是将扇区地址用LBA（逻辑块地址）表示，屏蔽底层物理磁盘的概念</li>
<li>磁盘虚拟由磁盘自身固件完成</li>
<li>磁盘虚拟化的结果是使磁盘的使用者无须了解磁盘的内部硬件细节，通过块地址就可以访问磁盘</li>
</ol>
<h3 id="块虚拟化"> 块虚拟化</h3>
<ol>
<li>块虚拟化是指对多块硬盘建立RAID，划分逻辑卷（LUN）.</li>
<li>每个逻辑卷对于使用者都完全等同于一块物理硬盘。物理上来说，这个逻辑卷的所有数据块，都是通过RAD处理，分布在不同的物理硬盘上。</li>
<li>块虚拟化的结果是使存储的使用者无须关心RAD实现的具体过程，只要象读写普通硬盘一样读写这个逻辑卷，就能获得RAID对数据的保护功能。</li>
</ol>
<h3 id="nas虚拟化"> NAS虚拟化</h3>
<p>NAS的虚拟化不同大多在于系统</p>
<p>特点：</p>
<ul>
<li>支持异构主机</li>
<li>成熟的网络拓扑结构</li>
<li>高度集成的存储子系统</li>
<li>设备简单化</li>
</ul>
<h3 id="基于主机的存储虚拟化"> 基于主机的存储虚拟化</h3>
<p>通常在中高端存储设备</p>
<p>主要用途：使服务器的存储空间可以跨越多个异构的磁盘阵列，常用于在不同磁盘阵列之间做数据镜像保护。
实现方式：一般由操作系统下的逻辑卷管理软件完成（安装客户端软件），不同操作系
统的逻辑卷管理软件也不相同。</p>
<h4 id="优点-2"> 优点</h4>
<ul>
<li>支持异构的存储系统。</li>
</ul>
<h4 id="缺点"> 缺点</h4>
<ul>
<li>占用主机资源，降低应用性能存在操作系统和应用的兼容性问题。</li>
<li>导致主机升级、维护和扩展非常复杂，而且容易造成系统不稳定性。</li>
<li>需要复杂的数据迁移过程，影响业务连续性</li>
</ul>
<h3 id="基于网络的存储虚拟化"> 基于网络的存储虚拟化</h3>
<p>主要用途：异构存储系统整合和统一数据管理。
实现方式：通过在存储域网（SAN）中添加虚拟化引擎实现。</p>
<h4 id="优点-3"> 优点：</h4>
<ul>
<li>与主机无关，不占用主机资源。</li>
<li>能够支持异构主机、异构存储设备。</li>
<li>使不同存储设备的数据管理功能统</li>
<li>构建统一管理平台，可扩展性好。</li>
</ul>
<h4 id="缺点-2"> 缺点：</h4>
<ul>
<li>部分厂商数据管理功能弱，难以达到虚拟化统一数据管理的目的。</li>
<li>部分厂商产品成熟度较低，仍然存在和不同存储和主机的兼容性问题。</li>
</ul>
<h3 id="存储虚拟化实现技术比较"> 存储虚拟化实现技术比较</h3>
<p><img src="./images/data_security/image-20200331091523806.png" alt="image-20200331091523806" /></p>
<h3 id="带内-与-带外"> “带内”与“带外”</h3>
<ul>
<li>
<p>根据存储虛拟化实现的机制，存储虛拟化可分为“带内”和“带外”两种基本类型。</p>
</li>
<li>
<p><strong>带内虛拟技术</strong>是在数据读写的过程中，在主机到<strong>存储设备的路径上实现存储虚拟化</strong>；</p>
</li>
<li>
<p>而<strong>带外虚拟技术</strong>，是在数据读写之前，就已经做好了虛拟工作，而且实现虛拟的<strong>部分并不在主机到存储设备的访问路径上</strong>。</p>
</li>
<li>
<p>所以带内虛拟技术可以基于主机、设备和网络实现而带外虚拟技术则只能是基于存储网络实现。</p>
</li>
<li>
<p>带外实现难度比带内难</p>
</li>
<li>
<p>带内是逻辑化存储设备，但是拥有瓶颈，带内几乎是一个数据中转器，就如同火车只有一个头带</p>
</li>
<li>
<p>带外在数据处理过程中不会产生瓶颈，在异构存储系统之间需要大规模整合（极其复杂），带内几乎是全部设备都是数据中转器，就如同火车每一节都是火车头在跑（均匀存储、拥有冗余、可靠性高、快速）</p>
</li>
</ul>
<h3 id="产品差异化"> 产品差异化</h3>
<ul>
<li>基于网络的带内虛拟化产品，一方面所有虛拟化数据都要通过该产品进行处理，因此它很容易成为路径中的一个瓶颈，另一方面如果用户需要高可用性那么需要额外増加设备数量。</li>
<li>带外虛拟化产品，在数据处理过程中不会产生瓶颈在异构存储糸统之间进行大规模整合，可以充分提高对存储资源的利用率</li>
</ul>
<h3 id="显示结果"> 显示结果</h3>
<ul>
<li>带内架构会在服务器与物理存储设备或SAN之间部署一个控制器，所有的存储请求和数据流都要经过这个控制器处理。而滞外模式的产品会在网络层部署一个元数据控制器，将所有的存储请求重定向到真实的物理位置，但<strong>其本身并不负责数据处理</strong>。</li>
<li>与带内模式相比，<strong>带外模式的处理流程更加复杂，但却可以减少CPU的负载</strong>。带外的存储虚拟化还可以避免潜在的糸统崩溃风险，<strong>因为帶内模式下存储是经过重新映射的，一旦带内控制器失效，客户端主机与后端存储的连接也将丢失。</strong></li>
<li>今天，大多数基于网络的存储虚拟化解决方案采用的都是<strong>带内模式</strong>（因为带内简单），其中主要的原因可能是现在CPU的处理能力更强，与过去相比不在是祭构的瓶颈。而带内虛拟化架构普及的另一个原因则是带内方案实现起来更容易，可以更快的推向市场，问题也更少。</li>
</ul>
<h3 id="带内虚拟化"> 带内虚拟化</h3>
<p>用途：</p>
<ul>
<li>异构存储系统整合</li>
<li>统一数据管理，在业务运行同时完成复制、镜像、CDP等各种数据管理功能</li>
</ul>
<h4 id="优点-4"> 优点</h4>
<ul>
<li>
<p>服务器、存储设备的兼容性好</p>
</li>
<li>
<p>虚拟化和数据管理功能由专用硬件实现，不占用主机资源</p>
</li>
<li>
<p>丰富的数据管理功能</p>
</li>
<li>
<p>配置简单，易于实施</p>
</li>
</ul>
<h4 id="缺点-3"> 缺点：</h4>
<ul>
<li>虚拟化设备发生故障，整个系统将中断</li>
</ul>
<h3 id="带外虚拟化"> 带外虚拟化</h3>
<p><em>OpenStack</em>：开源的云计算管理平台项目</p>
<p>用途：一般用于不同存储设备之间的数据复制</p>
<h4 id="优点-5"> 优点</h4>
<ul>
<li>虚拟化设备发生故障，整个系统将不会中断</li>
</ul>
<h4 id="缺点-4"> 缺点：</h4>
<ul>
<li>主机资源占用较大</li>
<li>大部分产品缺乏数据管理功能</li>
<li>主机和存储系统需要严格的兼容性认证</li>
<li>数据初始化同步复杂</li>
<li>配置复杂，实施难度高</li>
</ul>
<h3 id="计算云与存储云"> 计算云与存储云</h3>
<h3 id="存储云技术架构"> 存储云技术架构</h3>
<h3 id="存储云建设的考虑因素"> 存储云建设的考虑因素</h3>
<ul>
<li>高可用性</li>
<li>数据安全</li>
</ul>
<h3 id="存储虚拟化涉及的技术"> 存储虚拟化涉及的技术</h3>
<p><img src="./images/data_security/image-20200331095228472.png" alt="image-20200331095228472" /></p>
<h3 id="虚拟化技术的整合方案"> 虚拟化技术的整合方案</h3>
<p>将上面所述技术再整合进行使用</p>
<p>虚拟化的必要性：降低管理成本、提高利用率
虚拟化的本质：将物理资源映射成虚拟资源统一管理
例子：云盘...</p>
<h2 id="存储节能技术"> 存储节能技术</h2>
<ul>
<li>MAID技术</li>
<li>数据分级存储</li>
<li>自动精简配置</li>
<li>重复数据删除技术</li>
</ul>
<h3 id="maid技术"> MAID技术</h3>
<p>MAID技术在磁带库工作模式的基础上提出和发畏起来的。磁带庠的工作原理是正常状态下所有的磁带都放置在磁带庠的槽位中，需要某盘磁带肘才将它放在磁帶机中，然后进行数据读写。而在大部分肘间，大多数磁带是处在非工作状态的。MAID应用了同样的原理，只有需要肘才将一部分磁盘开机运转，而其他磁盘通常处于断电状态，就像磁带庠中的磁带一样。因此应用的MAID技术的磁盘存储也可以称之为磁盘庠。</p>
<h3 id="maid存储的功能"> MAID存储的功能</h3>
<ul>
<li>MAID节点功能工作方式分三个阶段，各个阶段时间间隔可以由用户自行定义</li>
<li>假设2分钟内没有读取资料肘，硬盘磁头就会自行停留到没有存取数据的地方，以节省磁头的功耗；过了10分钟后若仍没有读取，就会进入第二阶段，硬盘会降低转速至4000rpm；若过了15分钟后仍没有谈取资料，就会进入第三阶段，硬盘于是会停止运转，等到糸统呼叫肘再启动，但由于硬盘仍处于通电状态，因此还是在“准备状态”，再启动的肘间约为10~15秒。</li>
</ul>
<h3 id="maid存储的特点"> MAID存储的特点</h3>
<ul>
<li>MAID存储糸统中的磁盘或碩盘RAID组可以在没有读写访问肘依据策略下电</li>
<li>下电磁盘自动依策略进行故障检查；</li>
<li>碳盘在下电以后，一旦有读写请求，磁盘自动上电，RAID组可重新</li>
<li>提供正常访问</li>
<li>降低能耗，电能节约可到达30%</li>
<li>减少环境和管理成本；</li>
<li>更长的磁盘使用寿命。</li>
</ul>
<h3 id="maid存储的应用环境"> MAID存储的应用环境</h3>
<p>MAID存储的工作原理是使长肘间无访问请求的硬盘处于 Power oFF状态，以达到绿色节能和延长硬盘寿命，因此MAD存储适用于访问频率低、数据即肘可得性要求低的大容量近线存储（ Nearline Storage）设备和分级存储，尤其适用在以数据恢复为目的的数据备份和数据归档等应用上。并不适用于高性能实肘访问糸统，或访问肘间间隔较小的应用糸统。</p>
<h4 id="基于vtl-maid的数据备份解决方案"> 基于VTL+MAID的数据备份解决方案</h4>
<p>存储频率不高</p>
<h4 id="基于cdn-maid的视频网站存储解决方案"> 基于CDN+MAID的视频网站存储解决方案</h4>
<p>视频虽然数量大，但是一般分为点击率热门和非热门的数据</p>
<h4 id="基于存储策略-maid的视频监控存储解决方案"> 基于存储策略+MAID的视频监控存储解决方案</h4>
<p>视频监控系统设计规范要求各监控点采集的视频图像必需在线保存10-15天，甚至是30天才能删除</p>
<h3 id="数据分级存储"> 数据分级存储</h3>
<p>根据数据使用频率和价值高低分放到不同的存储介质中</p>
<p>其中数据迁移是一个较为重要的过程</p>
<ul>
<li>数据迁移的规则，例如数据使用的频率与数据价值</li>
</ul>
<h4 id="分级存储优点"> 分级存储优点</h4>
<ul>
<li>
<p>减少总体存储成本</p>
</li>
<li>
<p>性能优化：分级存储可使不同性价比的存储设备发挥最大的综合效益</p>
</li>
<li>
<p>改善数据可用性：分级存储把很少使用的历史数据迁移到辅助存储器中，或归档到离线存储池中，这样就无需反复保存，减少了存储的肘间，同肘提高了在线数据的可用性，使磁盘的可用空问维持在糸统要求的水平上。</p>
</li>
<li>
<p>数据迁移对应用透明：进行分级存储后，数据移动到另外的存储器</p>
<p>肘，应用程序不需要改变，使数据迁移对应用透明</p>
</li>
</ul>
<h3 id="自动精简配置"> 自动精简配置</h3>
<ul>
<li>自动精简配置是一种存储管理的特性，核心原理是**“欺骗”**標作糸统，让操作糸统认为存储设备中有很大的存储空间，而实际上的物理存储空间则没有那么大</li>
<li>服务器识别存储设备的肘候，看到的并不是真实空间，而是由自动精简配置虛拟出来的卷。而且只有当服务器写入存储的肘候，真实的空间才会被分配。</li>
<li>当使用量超过阀值的时候则会自动增加容量，其提高了存储空间的利用效率、降低了成本投入</li>
</ul>
<h4 id="技术优势"> 技术优势</h4>
<ul>
<li>可以自动扩畏已经分配的存储卷。</li>
<li>可以使用户使用接近100%的存储空间。</li>
<li>和远程镜像结合的肘候，可以节省镜像的空间和带宽</li>
<li>费用节省、空间利用率的提升
<ul>
<li>一个惊呆了的自动精简配置能大约减少20%的存储费用</li>
</ul>
</li>
</ul>
<h3 id="重复数据删除"> 重复数据删除</h3>
<ul>
<li>将数据集（在备份环境下，通常是备份教据流）划分为教据抉并将这些数据写入磁盘目标区城。为了识别传输教据流中的数据抉，重复数据删除引擎会为每个数据段创建一个数字签名（类似指紋），并为给定存储库的签名创建一个索引。</li>
<li>该索引可从所存储数据段中重建，并提供了引用列表，以确定数据块是否已处于存储库中。</li>
<li>在复制操作过程中，该索引可用来确定哪些数据段要被存储，哪些教据段要被复制。当重复数据删除软件发现某一教据块以前已被处理过，则会插入指向该数据集元数据中原始数据块的指针，而不是再次存储该数据块。</li>
</ul>
<h4 id="重复数据删除方法"> 重复数据删除方法</h4>
<ul>
<li>固定长度数据块切割（定长）
<ul>
<li>压缩效率低，简单，一块变化全部变化</li>
</ul>
</li>
<li>可变长度数据段切割（非定长/可变定长）
<ul>
<li>压缩效率高，复杂，一块变化其余不影响</li>
</ul>
</li>
</ul>
<h4 id="基于备份源基于目标端的重复数据删除"> 基于备份源基于目标端的重复数据删除</h4>
<ul>
<li>基于源端：性能依靠源端，会影响源端本身业务，网络过程中传输数据量降低，整个备份网络宽带也就降低了</li>
<li>基于目标端：目标端与源端隔离，源端可继续处理原有业务，降低了网络传输</li>
</ul>
<h4 id="从过程的角度分带内和带外"> 从过程的角度分带内和带外</h4>
<p>带内的方法比带外的效率高</p>
<h4 id="不同条件下重复数据删除效率"> 不同条件下重复数据删除效率</h4>
<p>越低越好</p>
<p>相同率最高的是 Windows文件，可以达到将近600：1的重复数据删除比率。比较低的应该是数据庠文件、LinuⅨX文件，可以达到75：1的重复数据删除比率。如果是NAS文件，比较好的情况下也可以实现135：1的比率</p>
<p><img src="./images/data_security/image-20200331111121020.png" alt="image-20200331111121020" /></p>
<h4 id="选择重复数据删除的原则"> 选择重复数据删除的原则</h4>
<ul>
<li>基本上认为大概正常的文件应用可以达到50%以上的重复数据删除。</li>
<li>对于定长的重复数据删除解决方案，切块越小，删除比率越高。</li>
<li>采用变长算法的重复数据删除解决方案，可以大大提高我们的重复数据删除率但也增加了糸统的消耗。</li>
<li>基于数据源的重复数据删除解决方案普遍比基于目标端的高，此外基于备份源的重复数据删除方案还能有效地降低备份网络的负担，但增加的是糸统的计算诮耗需要有相应的硬件解决方案。</li>
</ul>
<h1 id="数据备份-3"> 数据备份</h1>
<ul>
<li>拷贝不等于备份</li>
<li>磁盘阵列不等于备份</li>
<li>集群（Cluster）不等于备份</li>
<li>备份的特点
<ul>
<li>备份可保留档案的历史记录</li>
<li>备份可保存目录服务记录及重要的系统信息</li>
</ul>
</li>
<li>能够恢复的备份才叫备份</li>
</ul>
<h2 id="备份窗口"> 备份窗口</h2>
<p>一个工作周期内留给备份系统进行备份的时间长度，如果备份窗口过小，则要努力提高备份速度</p>
<h2 id="备份窗口-备份时间"> 备份窗口/备份时间</h2>
<ul>
<li>备份时间
<ul>
<li>数据从开始备份到完全结束所经历的时间</li>
</ul>
</li>
<li>数据恢复时间
<ul>
<li>即在出现灾难的时候，我们能够多快地恢复全部数据，重新开始
正常的业务。</li>
</ul>
</li>
</ul>
<h3 id="缩短备份时间"> 缩短备份时间</h3>
<p>对外服务的时长是不可能压缩的，所以一般是采用提高备份速度</p>
<ul>
<li>增量备份</li>
<li>日志备份</li>
<li>使用快速备份设备</li>
<li>提高网络宽带</li>
<li>使用特殊备份功能</li>
</ul>
<h3 id="缩短恢复时间的方法"> 缩短恢复时间的方法</h3>
<p>缩短恢复时间与缩短备份时间的备份策略是冲突的（不用花钱），硬件设备不冲突（要花钱）</p>
<ul>
<li>使用全备份</li>
<li>不使用日志备份</li>
<li>使用快速备份设备</li>
<li>提高网络宽带</li>
</ul>
<h2 id="备份的类型"> 备份的类型</h2>
<p>从备份数据的内容上区分：</p>
<ul>
<li>完全备份</li>
<li>对备份对象进行一次完全备份</li>
<li>增量备份
<ul>
<li>每次备份的数据只是相对于上一次备份后新增加的和修改过的数据</li>
</ul>
</li>
<li>差分备份
<ul>
<li>每次备份的数据是相对于上一次全备份之后增加的和修改过的数据</li>
</ul>
</li>
</ul>
<p><img src="./images/data_security/image-20200407091712892.png" alt="image-20200407091712892" /></p>
<p><img src="./images/data_security/image-20200407092230435.png" alt="image-20200407092230435" /></p>
<p>若要退回到星期五的备份状态：</p>
<ul>
<li>全备份只需要一个备份数据</li>
<li>差异备份需要星期天的全备份和星期五的备份两个备份数据</li>
<li>增量备份需要星期天的全备份与星期一至五的增量备份，共六个备份数据</li>
</ul>
<h2 id="备份比较"> 备份比较</h2>
<ul>
<li>速度上来说：增量备份&gt;差异备份&gt;全备份</li>
<li>可靠性来说：全备份&gt;差异备份&gt;增量备份</li>
<li>恢复时间来说：全备份&gt;差异备份&gt;增量备份</li>
</ul>
<h2 id="备份的方式"> 备份的方式</h2>
<ul>
<li>从使用的角度来看：
<ul>
<li>手工备份一功能最强、成本最高、最易出错</li>
<li>自动备份一使用方便、成功率高、降低成本</li>
</ul>
</li>
<li>从应用的角度来看：
<ul>
<li>离线备份一业务需要停顿</li>
<li>在线备份一业务不停顿</li>
</ul>
</li>
</ul>
<h3 id="本地备份"> 本地备份</h3>
<ul>
<li>什么是本地备份？
<ul>
<li>本地备份也叫手工备份，是每台服务器有自己的本地备份设备，这是最简单的备份方案。由于备份设备连接到每台服务器上，所了硬件投资，还增加了管理的费用。.这种备份方案不仅增加以每台服务器不得不单独管理备份进程</li>
</ul>
</li>
<li>本地备份的问题
<ul>
<li>手动，用户每次都要自己配置备份任务</li>
<li>无规律，没有策略</li>
<li>缺乏对备份数据的管理</li>
</ul>
</li>
</ul>
<h3 id="网络备份"> 网络备份</h3>
<ul>
<li>网络备份？
<ul>
<li>网络备份也叫做LAN备份，是一种流行的备份解决方案。通常，带有备份设备的备份服务器被放置在网络中。备份服务器负责整个系统的备份，它管理整个网络的备份策略、备份媒体和备份目标。所有的备份数据必须通过本地局域网进行传输</li>
</ul>
</li>
<li>网络备份的优点
<ul>
<li>实现了大容量自动化、集中式备份</li>
<li>备份过程有策略管理，无需管理员介入</li>
<li>网络内所有需要备份的服务器可共享一台备份设备</li>
</ul>
</li>
</ul>
<h3 id="server-less备份-2"> Server less备份</h3>
<ul>
<li>什么叫 Server less备份？
<ul>
<li>Server less备份是备份技术中最近的技术，它可以在 LAN Free备份的基础上节省有价值的服务器资源（CPU、内存等）.一些Server less备份设备放在服务器和存储子系统之间，这些设备负责备份数据的仝部责任，它从存储阵列向磁带设备直接发送数据。</li>
</ul>
</li>
<li>Server less备份的优点
<ul>
<li>实现不影响应用的备份</li>
<li>极大的减少服务器负担</li>
</ul>
</li>
</ul>
<h2 id="使用备份软件"> 使用备份软件</h2>
<ul>
<li>可以实现无人值守的计划自动备份</li>
<li>备份实现灵活，易于伸缩扩展</li>
<li>可以对媒体介质资源进行集中管理</li>
<li>可以对所有客户的备份任务进行集中管理</li>
<li>可以实现对异构平台的备份</li>
<li>对许多应用（数据库等）强大的支持功能</li>
<li>可以进行LAN-Free、 Server less等高级备份方式</li>
<li>完备的日志系统可以使管理员根据不同需求进行监控和查询</li>
</ul>
<h2 id="成功部署备份系统需要考虑的问题"> 成功部署备份系统需要考虑的问题</h2>
<p>您准备花多少时间恢复系统？
每次备份您最长给我多少时间？
备份的数据量有多大？
备份数据的类型是什么？
恢复时您能让我丢多少数据？
希望各种数据保留多长时间？
系统环境？主机/存储/带宽/应用
打算花多少钱？</p>
<h2 id="影响备份系统的因素"> 影响备份系统的因素</h2>
<ul>
<li>目标数据</li>
<li>目标数据的容量</li>
<li>备份时间</li>
<li>恢复时间</li>
<li>备份类型</li>
<li>设备类型</li>
<li>备份计划
<ul>
<li>全备份、差异备份、增量备份</li>
</ul>
</li>
<li>备份系统的结构的类型</li>
<li>在线备份</li>
</ul>
<h2 id="网络备份架构的组成"> 网络备份架构的组成</h2>
<ul>
<li>硬件组成
<ul>
<li>备份服务器（Backup Server）：负责管理整个系统的备份过程</li>
<li>备份客户端（Backup Client）：需要备份的应用服务器（Application Server）</li>
<li>备份设备：可以是磁盘阵列（Disk Array）、磁带库（Tape Library）或虚拟磁带库（VTL）</li>
</ul>
</li>
<li>软件组成
<ul>
<li>服务器端备份软件：安裝在备份服务器中，负责控制、监控、制定所有的备份任务。</li>
<li>客户端备份软件：安装在需要备份的应用服务器中，负责与备份服务器通讯，并将备份数据送出。</li>
<li>数据库代理软件：安装在需要备份的数据库服务器中，负责数据备份的一致性与完整性。</li>
<li>带库驱动模块：安装在备份服务器中，允许备份数据写入备份设备中</li>
</ul>
</li>
<li>备份网络
<ul>
<li>般为百兆或千兆以太网，备份服务器、备份客户端都需连接到备份网络，备份数据流及控制命令流都在该网络上传输</li>
</ul>
</li>
</ul>
<h2 id="备份及恢复流程"> 备份及恢复流程</h2>
<ul>
<li>备份流程
<ul>
<li>在备份服务器中设置备份任务及策略</li>
<li>备份服务器定时启动备份任务，通过以太网发送控制命令通知备份客户端开始备份。</li>
<li>备份客户端接收备份命令，启动数据库代理软件保证数据库的一致性，并开始发送备份数据通过以太网传输到备份服务器端</li>
<li>备份服务器接收备份数据，并将备份数据写入备份设备中。</li>
</ul>
</li>
<li>恢复流程
<ul>
<li>业务系统数据丢失，需要恢复数据的客户端停止业务应用。</li>
<li>在备份服务器端启动恢复任务，管理员手工选择需要恢复的备份数据版本</li>
<li>备份服务器在自身数据库中寻找需要恢复的数据版本，并在备份设备中定位查找</li>
<li>备份服务器通过以太网将数据传输给丢失数据的客户端，客户端接收待恢复的备份数据</li>
</ul>
</li>
</ul>
<h2 id="高级备份恢复技术"> 高级备份恢复技术</h2>
<h3 id="lan-free备份流程"> LAN Free备份流程</h3>
<ul>
<li>备份流程
<ul>
<li>备份客户端需安装备份媒体介质服务器端软件</li>
<li>在备份服务器中设置备份任务及策略。</li>
<li>备份服务器定时启动备份任务，通过以太网发送控制命令通知备份客户端开始备份。</li>
<li>备份客户端接收备份命令，启动数据库代理软件保证数据库的致性，并</li>
<li>开始发送备份数据通过SAN网络直接写入到连接在自身的备份设备中。
备份服务器接收客户端写入成功的信息，备份任务完成。</li>
</ul>
</li>
</ul>
<h3 id="server-less备份流程"> Server Less备份流程</h3>
<ul>
<li>备份流程
<ul>
<li>需要SAN交换机或备份设备支持此功能。</li>
<li>在备份服务器中设置备份任务及策略。</li>
<li>备份服务器定时启动备份任务，通过以太网发送控制命令通知备份客户端开始备份。</li>
<li>备份客户端接收备份命令，并传达备份命令给SAN交换机或备份设备开始备份，备份数据不通过备份客户端直接从磁盘阵列写入到连接在SAN网络的备份设备中。</li>
<li>备份客户端得到完成信息，并将该信息通过以太网传送给备份服务器，备份任务完成</li>
</ul>
</li>
</ul>
<h2 id="数据恢复应注意的问题"> 数据恢复应注意的问题</h2>
<ul>
<li>影响恢复时间的因素
<ul>
<li>系统重构的时间</li>
<li>是否具有快速恢复的功能</li>
<li>需要恢复的数据的大小</li>
<li>备份的类型</li>
<li>备份的介质</li>
<li>数据库恢复
<ul>
<li>数据恢复</li>
<li>日志恢复</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="数据库恢复分类"> 数据库恢复分类</h2>
<ul>
<li>数据库完全恢复</li>
<li>数据库部分恢复
<ul>
<li>恢复数据文件</li>
<li>恢复表空间</li>
<li>时间点恢复</li>
</ul>
</li>
<li>综合性恢复
<ul>
<li>表空间的时间点恢复</li>
</ul>
</li>
</ul>
<h2 id="备份-恢复系统的规划"> 备份/恢复系统的规划</h2>
<ul>
<li>备份系统的规划
<ul>
<li>设计适合的备份系统结构
<ul>
<li>对应用物理的影响</li>
<li>考虑备份窗口是否与实际备份时间匹配</li>
<li>备份介质容量</li>
</ul>
</li>
<li>定制合理的备份策略
<ul>
<li>保证备份的数据能够充分满足各种情况下数据恢复的需求</li>
<li>使可恢复数据尽量距灾难发生点间隔最小</li>
<li>能够充分满足数据保存时间的要求</li>
</ul>
</li>
<li>估计可容忍的故障恢复时间</li>
<li>估计实际数据恢复所需要的时间</li>
<li>定制恢复计划</li>
<li>具有恢复能力的专门恢复人员
<ul>
<li>有关备份的一切相关资料
<ul>
<li>备份系统的结构图</li>
<li>备份的执行情况</li>
<li>备份数据与备份介质的详细关系</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="备份"> 备份</h2>
<ul>
<li>
<p>需要根据保留的时间与价值分开存放</p>
</li>
<li>
<p>文件的复制与备份</p>
</li>
<li>
<p>window与linux系统的备份</p>
</li>
<li>
<p>备份软件与备份系统的备份</p>
</li>
<li>
<p>备份计划</p>
<ul>
<li>周期性备份
<ul>
<li>每日/周/月</li>
<li>每次开关机</li>
</ul>
</li>
</ul>
</li>
<li>
<p>备份报告</p>
<ul>
<li>备份报告的管理
<ul>
<li>备份报告应有专人定时编写</li>
<li>备份报告应存放在安全位置
<ul>
<li>不会因为灾难的原因而丢失</li>
<li>可以让数据恢复人员在最短的时间内取得报告</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>恢复指标</p>
<ul>
<li>恢复时间</li>
<li>恢复点
<ul>
<li>允许最大的数据损失量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="数据容灾"> 数据容灾</h2>
<p>灾难恢复是指发生灾难性事故的时候，利用系统恢复、数据备份等措施，及时对原系统进行恢复，以保证数据的安全性以及业务</p>
<ul>
<li>与备份的区别
<ul>
<li>灾难恢复包括系统恢复、数据恢复和应用恢复全过程</li>
<li>灾难恢复目标之一是保证业务的连续性</li>
<li>系统备份与数据备份不同，他需要备份系统中安装的应用程序、数据库系统、 用户设置、系统参数等。不是单纯的数据复制</li>
<li>容灾要求有异地数据备份，甚至系统应用的异地备份</li>
</ul>
</li>
</ul>
<h3 id="容灾与备份的关系"> 容灾与备份的关系</h3>
<h4 id="区别"> 区别</h4>
<p>从定义上看，备份是指用户为应用系统产生的重要数据（或者原有的重要数据信息）制作一份或者多份拷贝，以增强数据的安全性。因此，备份与容灾所关注的对象有所不同，备份关系数据的安全，容灾关心业务应用的安全，我们可以把备份称作是“数据保护”，而容灾称作“业务应用保护”.</p>
<h4 id="联系"> 联系</h4>
<ul>
<li>备份与容灾是存储领域两个极其重要的部分，二者有着紧密的联系</li>
<li>首先，在备份与容灾中都有数据保护工作。其次，备份是存储领域的一个基础，在一个完整的容灾方案中必然包括备份的部分；</li>
<li>同时备份还是容灾方案的有效补充，因为容灾方案中的数据始终在线，因此存储有完全被破坏的可能，而备份提供了额外的一条防线，即使在线数据丢失也可以从备份数据中恢复。</li>
</ul>
<h3 id="容灾指标"> 容灾指标</h3>
<ul>
<li>以恢复点为目标（RPO -- Recovery Point Object）
<ul>
<li>数据的完整性（无数据丢失）</li>
<li>数据的一致性（数据正确却可用）</li>
</ul>
</li>
<li>以恢复时间为目标（RTO -- Recovery Time Object）</li>
<li>以网络恢复为目标（NRO -- Network Recovery Object）</li>
<li>以服务支持能力为目标（SDO -- Serviceability Degrade Object）
<ul>
<li>性能</li>
<li>地域/支持的客户总数</li>
<li>功能的限制</li>
</ul>
</li>
</ul>
<h3 id="灾难恢复与容灾规划"> 灾难恢复与容灾规划</h3>
<h4 id="灾难恢复等级"> 灾难恢复等级</h4>
<p>支持灾难恢复各个等级所需的资源分为7个要素</p>
<ol>
<li>数据备份系统</li>
<li>备用数据处理系统</li>
<li>备用网络系统</li>
<li>备用基础设施</li>
<li>技术支持能力</li>
<li>运行维护管理能力</li>
<li>灾难恢预案</li>
</ol>
<h4 id="共划分6个等级"> 共划分6个等级</h4>
<table>
<thead>
<tr>
<th>等级</th>
<th>详细</th>
</tr>
</thead>
<tbody>
<tr>
<td>第1级</td>
<td>基本支持</td>
</tr>
<tr>
<td>第2级</td>
<td>备用场地支持</td>
</tr>
<tr>
<td>第3级</td>
<td>电子传输和部分设备支持</td>
</tr>
<tr>
<td>第4级</td>
<td>电子传输及完整设备支持</td>
</tr>
<tr>
<td>第5级</td>
<td>实时数据传输及完整设备支持</td>
</tr>
<tr>
<td>第6级</td>
<td>数据零丢失和远程集群支持</td>
</tr>
</tbody>
</table>
<h4 id="容灾的7个层次"> 容灾的7个层次</h4>
<ul>
<li>备份/恢复的范围</li>
<li>恢复计划的状态</li>
<li>在应用中心与备份中心之间的距离</li>
<li>应用中心与备份中心之间是如何相互连接的</li>
<li>数据怎样在两个中心之间传送的</li>
<li>有多少数据被丢失</li>
<li>怎样保证更新的数据在备份中心被更新</li>
<li>备份中心可以开始备份工作的能力</li>
</ul>
<h5 id="_0层"> 0层</h5>
<p>无异地备份数据（No off——site Data）</p>
<h5 id="_1层"> 1层</h5>
<p>有数据备份，无备用系统（Data Backup with No Hot Site）</p>
<h5 id="_2层"> 2层</h5>
<p>有数据备份，有备用系统（Data Backup with Hot Site）</p>
<h5 id="_3层"> 3层</h5>
<p>电子链接（Electronic Baulting）</p>
<h5 id="_4层"> 4层</h5>
<p>使用快照技术拷贝数据（Point-in-time Copies）</p>
<h5 id="_5层"> 5层</h5>
<p>交易的完整性（Transaction Integrity）</p>
<h5 id="_6层"> 6层</h5>
<p>0数据丢失（Zero Data Loss），自动系统故障切换</p>
<h4 id="容灾恢复与容灾规划"> 容灾恢复与容灾规划</h4>
<p>对于倚仗厅系统的企业来说，从确保业务连续能力的角度出发，可以依据下列容灾规划步骤</p>
<ul>
<li>灾难类型分析</li>
<li>业务冲击分析</li>
<li>当前业务环节及恢复能力分析</li>
<li>容灾策略制订</li>
<li>容灾方案设计</li>
<li>业务连续性流程设计</li>
<li>业务连续性流程及容灾方案管理和测试</li>
</ul>
<h4 id="容灾的it实现"> 容灾的IT实现</h4>
<ul>
<li>除了详尽的容灾计划，实际上还需要合理的系统架构来确保企业的容灾计划得以实现</li>
<li>对于IT系统而言，在技术层面上，容灾需要考虑：
<ul>
<li>数据版本保护 - 建立容灾的多版本保护底线（Bottom Line）</li>
<li>实时数据保护 - 数据复制，近乎0的数据丢失，数据一致性</li>
<li>应用系统恢复 - 恢复时间（包括数据库恢复）、应用版本的一致性（PTF）等</li>
<li>网络系统恢复 - 数据访问点变化、建立新网络路径、动态路由（收敛时间/稳定性）</li>
<li>容灾切换决策 - 即使发现灾难（容灾系统管理）、容灾切换的损失和补救方法</li>
<li>容灾切换过程 - 变换管理</li>
</ul>
</li>
</ul>
<p>通常情况下IT系统相关的灾难备份方案设计都必须考虑的五大因素</p>
<ul>
<li>灾难类型：需要考虑哪些灾难？怎样的灾难？会使业务中断多久？</li>
<li>恢复速度：灾难发生后需要多久来启动及运行系统？能否承受数天或数分钟的等待？</li>
<li>恢复程度：需要恢复每条记录和交易吗？可以使用上星期或昨天的数据吗？需要恢复一切吗？有不相关的文件吗？什么是合法隐含的要求？有少数的一组人输入交易吗？他们可以重新输入灾难期间丢失的交易吗？这些交易十分重要而不容许丢失吗？</li>
<li>可用的技术：必须结合考虑所选技术在本地区的适用性、实现条件以及在实施时是否受某些现有条件的制约？</li>
<li>方案总体成本：实现灾难备份需要多少投资？不实现灾难备份会损失多少钱？</li>
</ul>
<h4 id="容灾涉及的恢复技术"> 容灾涉及的恢复技术</h4>
<ul>
<li>应用恢复</li>
<li>网络恢复</li>
<li>数据恢复</li>
</ul>
<h4 id="同城容灾和异地容灾"> 同城容灾和异地容灾</h4>
<ul>
<li>同城容灾
<ul>
<li>同城容灾是在相近区域建立两个数据中心：一个为生产中心，负责日常生产运行；一个为灾难备份中心。</li>
<li>同城容灾由于距离近，带宽大，经常采用同步镜像</li>
<li>可以防范火灾，建筑物倒塌等灾害；</li>
</ul>
</li>
<li>异地容灾
<ul>
<li>生产中心与灾难备份中心至少相距100Km以上</li>
<li>经常采用同步镜像</li>
<li>可以防范地震、水灾和战争等</li>
</ul>
</li>
<li>同城容灾和异地容灾各有所长，建议银行等特殊企业，可以考虑同时构建同城容灾和异地容灾。</li>
</ul>
<h1 id="固态硬盘"> 固态硬盘</h1>
<p>不像机械硬盘，一旦有一个位置损坏整个固态硬盘就损坏无法使用了</p>
<ul>
<li>
<p>由主控芯片控制，为了保证不让某个地方损坏所以芯片的使用寿命次数需要保证平衡</p>
</li>
<li>
<p>SLC复写次数：10w次</p>
</li>
<li>
<p>MLC复写次数：1W次（只有SLC的十分之一）</p>
</li>
<li>
<p>TLC复写次数：500次</p>
</li>
</ul>
<h2 id="固态分类"> 固态分类</h2>
<ul>
<li>基于DRAM的固态硬盘
<ul>
<li>采用DRAM作为存储介质，目前应用范围较窄</li>
<li>不能断电，需要永久通电，通常会有独立电源供电保证数据安全</li>
</ul>
</li>
</ul>
<h2 id="固态接口类型"> 固态接口类型</h2>
<ul>
<li>SSD固态硬盘主流接口类型分为：
<ul>
<li>SATA</li>
</ul>
</li>
</ul>
<h2 id="ssd性能优势"> SSD性能优势</h2>
<ul>
<li>响应时间短</li>
<li>读写效率高</li>
</ul>
<h2 id="功耗优势"> 功耗优势</h2>
<ul>
<li>SSD功耗小于机械硬盘</li>
<li>两块SSD=250块机械硬盘的功耗</li>
</ul>
<h2 id="ssd的环境适应优势"> SSD的环境适应优势</h2>
<ul>
<li>SSD不含高速旋转的机械结构部件，可经得住严苛的环境考验
<ul>
<li>SSD可承受加速度16.4G，机械硬盘一般为0.5G以下</li>
<li>SSD抗冲击150G，机械硬盘一般为70G左右</li>
</ul>
</li>
<li>SSD使用专用设备做过如下测试：
<ul>
<li>静压试验、跌落试验、随机振动试验、冲击试验、碰撞试验</li>
</ul>
</li>
</ul>
<h2 id="固态硬盘优点"> 固态硬盘优点</h2>
<ul>
<li>启动快
<ul>
<li>没有电机加速旋转的过程</li>
</ul>
</li>
<li>快捷，读取延迟小
<ul>
<li>不用磁头，快速随机读取，读延迟极小</li>
</ul>
</li>
<li>轻量</li>
<li>碎片不影响读取时间
<ul>
<li>相对固定的读取时间</li>
</ul>
</li>
<li>写入速度快
<ul>
<li>基于DRAM的固态硬盘写入速度极快</li>
</ul>
</li>
<li>无噪音
<ul>
<li>因为没有机械马达和风扇</li>
</ul>
</li>
<li>发热量较低
<ul>
<li>低容量的基于闪存的固态硬盘在工作状态下能耗和发热量较低</li>
</ul>
</li>
<li>不会发生机械故障
<ul>
<li>内部不存在任何机械活动部件</li>
</ul>
</li>
<li>省电
<ul>
<li>工作环境可在，典型：5-55°，工业：-10°~70°工作环境</li>
</ul>
</li>
<li>工作温度范围更大</li>
<li>体积小重量轻</li>
<li>抗震动</li>
</ul>
<h2 id="固态硬盘缺点"> 固态硬盘缺点</h2>
<ul>
<li>成本高
<ul>
<li>每单位容量价格是传统硬盘的5-10倍（基于闪存）</li>
</ul>
</li>
<li>容量低
<ul>
<li>目前固态硬盘最大容量远低于传统硬盘</li>
</ul>
</li>
<li>易受外界影响</li>
<li>写入寿命有限</li>
<li>数据难以恢复
<ul>
<li>数据损坏后难以恢复，一旦硬件上发生损坏，要想在碎成几片或被电流击穿的情况下恢复几乎不可能</li>
</ul>
</li>
<li>电池航程较短</li>
<li>能耗较高</li>
</ul>
<h2 id="ssd各种指标"> SSD各种指标</h2>
<ul>
<li>顺序读取/写入速度</li>
<li>4K性能
<ul>
<li>4K是大小，4096字节</li>
</ul>
</li>
<li>SSD读写原则和预留空间
<ul>
<li>按页存储数据，写数据时需要先檫除整块区块才能更新写入</li>
<li>为了让用户随时都能覆盖数据，所以需要保存一些空白空间或者是预留空间</li>
<li>一般制造商会预留远高于最低7.73%的空间，高端的SSD会预留高达28%的空间（512GB实际只有400GB可用）</li>
</ul>
</li>
</ul>
<h2 id="ssd存储颗粒"> SSD存储颗粒</h2>
<ul>
<li>从成本上来说NAND闪存大概能占SSD硬盘物料成本的70%或更多</li>
<li>大部分来自山西、东芝、美光、西数、英特尔</li>
<li>四大阵营：三星、SK Hynix、东芝/西数、美光/英特尔</li>
</ul>
<h2 id="主控芯片"> 主控芯片</h2>
<ul>
<li>一般来说主控芯片的成本占据SSD硬盘10-15%</li>
<li>主控芯片是固态硬盘的大脑</li>
</ul>
<h2 id="早期主控产品"> 早期主控产品</h2>
<ul>
<li>早期主流是：Intel、SandForce、Marvell</li>
<li>SandForce由于比较好一直被收购最终被希捷收购，目前由于频繁收购已经没落了</li>
<li>JMicron：性能不好功耗大，属于垃圾物品，但是廉价，所以撬动了大部分市场并受大部分山寨青睐</li>
</ul>
<p><img src="./images/data_security/image-20200414091907615.png" alt="image-20200414091907615" /></p>
<h2 id="主控发展情况"> 主控发展情况</h2>
<ul>
<li>目前可划分为美系、台系、陆系</li>
</ul>
<h2 id="主控品牌分系"> 主控品牌分系</h2>
<h3 id="美系主控品牌"> 美系主控品牌</h3>
<ul>
<li>美满电子</li>
<li>慧荣科技 SMI</li>
<li>Marvell 马牌，大众认知上也是顶级的主控品牌</li>
<li>SandForce 由于被多次收购开始衰落</li>
</ul>
<h3 id="台系主控品牌"> 台系主控品牌</h3>
<ul>
<li>JMicron 便宜功耗大，受山寨青睐所以推动了市场</li>
<li>目前风头最劲的是群联电子</li>
<li>点序科技也是台系不可忽视的一直中坚力量</li>
</ul>
<h2 id="大陆系主控品牌"> 大陆系主控品牌</h2>
<ul>
<li>江坡龙、忆芯科技、联芸科技...</li>
<li>国产主控还有一个特别的优势，那就是支持国内认证的安全加密</li>
</ul>
<h1 id="数据恢复工具使用"> 数据恢复工具使用</h1>
<h2 id="winhex"> WinHex</h2>
<ul>
<li>对系统要求低、方便携带</li>
</ul>
<h2 id="pc3000"> PC3000</h2>
<p>俄罗斯</p>
<h2 id="效率员"> 效率员</h2>
<h1 id="硬盘数据组织"> 硬盘数据组织</h1>
<ul>
<li>硬盘需要经过低格、分区、高级格式化后才能使用
<ul>
<li>低格
<ul>
<li>作用：测试硬盘介质、为硬盘划分磁道、指定交叉因子，安排扇区、写入扇区id，完成扇区设置、对磁盘表面测试，标记损坏磁道和扇区</li>
</ul>
</li>
<li>分区：便于硬盘的规划和文件的管理、有效的利用空间、提高系统效率、建立MBR
<ul>
<li>分区粒度一一分区最小单位是柱面</li>
</ul>
</li>
</ul>
</li>
<li>分区
<ul>
<li>
<p>将硬盘划分为一个个逻辑区域。每个分区有确定的起、止位置</p>
</li>
<li>
<p>分区的信息记录在一个特殊位置的扇区，成为硬盘主引导记录（ Master boot recorder,MBR或主引导扇区</p>
</li>
<li>
<p>MBR位于0磁头，0磁道，1扇区</p>
</li>
</ul>
</li>
</ul>
<h1 id="fat文件系统"> FAT文件系统</h1>
<h2 id="概念-2"> 概念</h2>
<h3 id="mbr-2"> MBR</h3>
<p><img src="./images/data_security/image-20200514225821891.png" alt="image-20200514225821891" /></p>
<p>FAT的第一扇区是MBR（占63扇区，第6个扇区用作备份），结束标志是55AA、前64个字节是分区表，16个字节为一个分区，上图只有一个分区</p>
<p><img src="./images/data_security/image-20200514230605262.png" alt="image-20200514230605262" /></p>
<ul>
<li>
<p>第一个字节是自举标志，所有分区的第一字节要么是00或80</p>
</li>
<li>
<p>后面三个字节是CHS起始位置</p>
</li>
<li>
<p>后面的字节应该是07，表明是分区类型NTFS（虚拟机上可能不一样）</p>
</li>
<li>
<p>后面三个字节是CHS结束位置</p>
</li>
<li>
<p>后面八个字当前四个是分区其实位置，后四个是分区大小</p>
</li>
<li>
<p>文件分配表FAT是dos文件管理系統用来记录每个文件的在储位置的表格，它叫链的方式存放簇号</p>
</li>
<li>
<p>根目录下所有文件和子目录，在根目录的文件目录表中都有一个记录-“目录登记项”。每个目录登记项占32个字节</p>
</li>
</ul>
<h4 id="计算"> 计算</h4>
<ul>
<li>
<p>在winhex中的值都需要反过来</p>
<div><pre><code># 例如
3F 00 00 00 -&gt; 00 00 00 3F
9A E5 3F 01 -&gt; 01 3F E5 9A
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p>高位的0可以省略，十六进制的3f转换成十进制63（MBR大小占63个扇区，C盘是紧接着MBR的扇区）</p>
</li>
<li>
<p>将13FE59A转换成十进制20964762（表明C盘这个分区占了20964762个扇区），再</p>
</li>
</ul>
<h3 id="高级格式化-fat格式"> 高级格式化（FAT格式）</h3>
<p>低格→分区后就会有MBR（63个扇区），然后进行FAT32格式化（高级格式化）。在硬盘中建立DBR（32个扇区），记录着分区的重要信息（如果被破坏，数据就丢失）；在此基础上建立FAT1（FAT2是备份，两个FAT一模一样），DIR是根目录（资源管理器打开显示的磁盘）,最后是数据区域。</p>
<ul>
<li>
<p>在分区内，对扇区进行逻辑编号</p>
</li>
<li>
<p>在基本分区建立DOS引导记录DBR</p>
</li>
<li>
<p>在逻辑盘建立文件分配表FAT</p>
</li>
<li>
<p>建立文件目录表FDT及数据区</p>
</li>
<li>
<p><img src="./images/data_security/image-20200428085021863.png" alt="image-20200428085021863" /></p>
</li>
<li>
<p>FAT表有2个</p>
</li>
<li>
<p>DBR区<a href="https://www.dgxue.com/huifu/141.html" target="_blank" rel="noopener noreferrer">可参考项</a></p>
<ul>
<li>DBR( DOS Boot Record),操作系统引导记录区。通常位于硬盘0柱1面1扇区，是操作系统可以直接访问的第一个个扇区。它包括引导程厅和一个被称为BPB( BIOS Parameter Block）的本分区参数记录表</li>
<li>高级格式化将DOS引导记录写到该扇区。引导程序的主要任务是，当MBR将系统控制权交给它时，判断本分区根目录前两个文件是不是操作系统的引导文件。以DOS为例，即是O.SYS和 MSDOS.SYS。低版本的DOS要求这两个文件必须是前两个文件，即位于根目录的起始处，占用最初的两个目录项，高版本已没有这个限制。另外， Windows与DOS是一个家族，所以Windows也沿用这种方式，只是文件名不一样。</li>
</ul>
</li>
</ul>
<p><img src="./images/data_security/image-20200428105459942.png" alt="image-20200428105459942" /></p>
<h3 id="dbr结构"> DBR结构</h3>
<p>DBR是操作系统可以直接访问的第一个扇区，结束标志和MBR的一样，区别：</p>
<ol>
<li>MBR是在硬盘的起始处，而DBR是在分区的起始处。</li>
<li>MBR有分区表，DBR没。</li>
<li>winhex打开C盘没有MBR,打开硬盘才有。</li>
</ol>
<p><img src="./images/data_security/image-20200515003252313.png" alt="image-20200515003252313" /></p>
<ul>
<li>5部分，操作系统可以直接访问的第一个扇区是DBR，FAT的第0、1簇为保留簇，其中，首字节表示DBR</li>
<li>跳转指令
<ul>
<li>两个字节，将程序跳转到自举代码处，EB3C;EB58等（EB代表汇编语言的JMP）。由于本身占两个字节，所以实际位置是3E,5A。其后是空指令NOP(90)</li>
</ul>
</li>
<li>厂商标志和Dos版本号
<ul>
<li>8个字节（03-0A）</li>
</ul>
</li>
<li>BPB(BIOS Parameter Block)
<ul>
<li>从第12个字节开始，占用52(0B-3E,FAT12/16)或80(0B-5A,FAT32)个字节</li>
</ul>
</li>
<li>Dos引导程序
<ul>
<li>448字节（3E-1FD）或420字节（5A-1FD):负责Dos系统文件装入</li>
</ul>
</li>
<li>结束标志
<ul>
<li>55AA</li>
</ul>
</li>
<li>5个部分共有512字节，正好是一个扇区，所以成为dos引导扇起或bot扇区；除了结束标志是固定不变的，其他4个部分随着dos版本不同而变化</li>
<li>DBR占用32个扇区（实际只占用第1和第6两个扇区，第1扇区起作用，第6扇区为第一扇区的备份）</li>
</ul>
<p><img src="./images/data_security/image-20200428085540744.png" alt="image-20200428085540744" /></p>
<ul>
<li>
<p>用winhex打开磁盘首先看到的是DBR的跳转指令 EB 3C;EB 58
<img src="./images/data_security/image-20200515003553030.png" alt="image-20200515003553030" /></p>
</li>
<li>
<p>结束标记
<img src="./images/data_security/image-20200515003606815.png" alt="image-20200515003606815" /></p>
</li>
<li>
<p>如果跳转第六个扇区（备份扇区）也是一模一样的（如果第一个扇区被破坏，可以从这复制）</p>
</li>
<li>
<p>在winhex右边点击引导扇区（模板）可以将数据用列表的形式表现
<img src="./images/data_security/image-20200515003803442.png" alt="image-20200515003803442" /></p>
</li>
<li>
<p>跳转指令
<img src="./images/data_security/image-20200515003827877.png" alt="image-20200515003827877" /></p>
</li>
<li>
<p>只要是有数据，起码占8个扇区（即一个簇）。簇是文件系统中读写数据的最小的单位（硬盘的逻辑划分最小单位是扇区）（分区的划分最小单位是柱面）
<img src="./images/data_security/image-20200515003842857.png" alt="image-20200515003842857" /></p>
</li>
<li>
<p>虽然大小只有10个字节，但以簇的形式可以提高管理的效率，但利用率下降，所以占用空间虽不满，但别人也不能用。如果大小变大了，管理效率调高了但是占用空间就大了，如果小了占用空间就小了但管理效率就低了
<img src="./images/data_security/image-20200515003859560.png" alt="image-20200515003859560" /></p>
</li>
<li>
<p>此处F8说明访问的是硬盘
<img src="./images/data_security/image-20200515004013886.png" alt="image-20200515004013886" /></p>
</li>
</ul>
<h2 id="fat32"> FAT32</h2>
<p><a href="https://www.dgxue.com/huifu/142.html" target="_blank" rel="noopener noreferrer">可参考项1</a> <a href="https://blog.csdn.net/yangyang031213/article/details/79030247" target="_blank" rel="noopener noreferrer">可参考项2</a></p>
<p><img src="./images/data_security/image-20200515004107342.png" alt="image-20200515004107342" /></p>
<ul>
<li>以链的方式存放簇号，前一个记住后一个。0<sub>11（F8</sub>0F）为默认，从这之后是数据
<img src="./images/data_security/image-20200515004141324.png" alt="image-20200515004141324" /></li>
<li>FAT32 - 32位，4个字节记录一个簇，因为用四个字节记录一个簇（所以*4），一个字节8bit，所以叫FAT32.
<img src="./images/data_security/image-20200515004212221.png" alt="image-20200515004212221" /></li>
<li>文件名</li>
<li>占8位</li>
<li>文件后缀名
<ul>
<li>占3位，早期文件后缀名只有三个字节的位置，所以都是3个为主（exe、txt、ini、 jpg、png...），虽然现在扩展了4个</li>
</ul>
</li>
<li>属性
<ul>
<li>占一位，</li>
<li>20表示文件，10表示目录</li>
<li>06代表系统文件，病毒常常会将自己修改成系统文件，若将其属性修改了也会自动刷成系统文件</li>
</ul>
</li>
<li>存储的起始位置
<ul>
<li>高位取反+地位取反，高位正数 56，地位倒数56</li>
<li>00 05 00 0C（真正的其实位置）</li>
</ul>
</li>
<li>文件大小
<ul>
<li>取反 00 00 0B FD -&gt;转换十进制得到的数就是文件大小，单位位字节</li>
</ul>
</li>
</ul>
<p><img src="./images/data_security/image-20200428095227484.png" alt="image-20200428095227484" /></p>
<div><pre><code>2E - .（点号
20 -  （空格
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>一个目录项作为长文件名目录项使用时，其属性字节（0BH字节）值为0F</li>
<li>若文件名过长则使用分段存储，分段存的长度为562562562...的分段存储，存储的编码也改变了，为Unioncode</li>
<li>属性一共八位： <code>0000 0000</code>
<ul>
<li>高四位
<ul>
<li><code>0010 0000</code> = 20 当前的记录是一个文件</li>
<li><code>0001 0000</code> = 10  当前的记录是一个目录</li>
</ul>
</li>
<li>第四位
<ul>
<li><code>0000 0001</code> = 01 只读文件</li>
<li><code>0000 0010</code> = 02 隐藏文件</li>
<li><code>0000 0100</code> = 04 系统文件</li>
</ul>
</li>
<li>如果属性位为22，则记录为隐藏的文件</li>
</ul>
</li>
</ul>
<h3 id="文件恢复"> 文件恢复</h3>
<ul>
<li>将文件delete，文件放到了回收站，则在资源管理器中，文件以E5开头，若文件以此开头则会默认略过他，此标记是作为废弃文件使用</li>
<li>文件删除其实只是将文件改为E5开头，并在回收站中产生一个文件链接的记录，如果是将磁盘格式化，也只是将文件记录和fat表给清除，但目录下的文件夹子目录记录还会在扇区中所以可以跳转至起始蔟，但是如果格式化的文件没有放入文件夹的话，那文件记录就会丢失</li>
</ul>
<p>如果需要查找中文名的文件夹，假设为<code>新的文件.TXT</code>则需要先创建一个txt，在里面输入<code>新的文件</code>保存为<code>unicode</code>编码后在winhex打开，以unicode保存的文件开头为FFFE后八位为编码后的<code>新的文件</code>文件名--<code>B065FA5E87652C67</code></p>
<h3 id="恢复一个文件"> 恢复一个文件</h3>
<p>这里以一张jpg为例子，文件名为<code>abc.jpg</code>，为了好观察，首先我们截一张图存放在一个空的盘，然后打开winhex选择指定的磁盘后打开根目录，找到<code>abc.jpg</code>这个文件名，找到之后这两行都是被这个文件占用了的，第二行从做左往右数第5、6位是文件的其实存储位，第二行倒数第56位是结束存储的位置，第二行最后四位是文件的大小</p>
<ul>
<li>正数：00 00</li>
<li>倒数：08 00</li>
<li>文件存储簇：00 00 00 08</li>
<li>EC BB 00 00</li>
<li>文件大小00 00 B8 EC
<ul>
<li>转换十进制大小：48108</li>
<li>末尾的偏移位：5D（十进制数除以512=93转16进制）</li>
</ul>
</li>
<li>移动到簇8后选择为起始，再偏移至5D sec后选择为结束，将所选的内容保存为文件导出则为<code>abc.jpg</code> 图片</li>
</ul>
<h2 id="winhex中分析fat32文件"> winhex中分析FAT32文件</h2>
<p>系统读取文件会首先查看0x0B位，这一位说明了此文件为长文件名文件还是短文件名文件，短目录项就是文件名长8位、后缀为3位的文件，更长的文件名需要长文件名，一般0F表示为长文件名</p>
<img src="./images/data_security/image-20200514212309065.png" alt="image-20200514212309065" style="zoom: 80%;" />
<ul>
<li>长文件名部分<code>0009D020-0009D030</code>
<ul>
<li>0x01中的41代表了0009D020-0009D030放置着unicode文件名，41的1字表示他是第一段，如果还有更长的则在个位数上叠加</li>
<li>0x0B中0F是长文件名的表示</li>
<li>0x0C的00是用作保留</li>
<li>0x0D的D2则是用于校验</li>
<li>其余部分用于存储unicode，其中的长文件名一直到00 00作为字符串结束标志，多余部分的用FF填充</li>
<li>为了检验其中的unicode码内容，我们用文本编辑器输入新建 文本文档.txt保存为unicode的格式用winhex打开，可以看到从FFFE开始后面的十六进制数与从04行开始的65FA5E....一致，而文件的格式名740078007400则在0009D020的0x0d-0x09
<img src="./images/data_security/image-20200515000006093.png" alt="image-20200515000006093" /></li>
</ul>
</li>
<li>短文件名部分<code>0009D040-0009D050</code>
<ul>
<li>0x00-0x07表示这其文件名</li>
<li>0x08-0x0A的54 58 54则代表文件后缀名txt文件</li>
<li>0x0B的20记录代表了这是一个文件</li>
<li>0x0C的00为保留所用</li>
<li>0x0D列为创建时间的10毫秒位</li>
<li>0x0E-0x0F列表示文件的创建时间，如果要对其计算则需要翻转，也就变成A6 E6，再对其进行换算</li>
<li>0x10-0x11表示文件的创建日期，也是需要对其进行翻转，变成50 AE</li>
<li>0x12-0x13表示文件的最后访问日期，计算的时候需要翻转为50 AE</li>
<li>0x14-0x15表示起始簇高字节，计算的时候需要翻转为00 00</li>
<li>0x16-0x17表示文件最后的修改时间，计算的时候需要翻转为A6 37</li>
<li>0x18-0x19表示文件最后的修改日期，计算的时候需要翻转为50 AE</li>
<li>0x1A-0x1B表示起始簇低字节，计算的时候需要翻转为00 03，将高位和低位加起来：00 00 00 03，将其转换成<strong>十进制</strong>也就表示这个文件存放在03簇</li>
<li>0x1C-0x1F表示文件的大小，计算的时候需要将18 00 00 00翻转为00 00 00 18，转换十进制为24个字节</li>
</ul>
</li>
</ul>
<h3 id="查看存储的簇"> 查看存储的簇</h3>
<ul>
<li>首先我们从上面得到了此文件在03簇，在<code>位置-&gt;跳转至扇区</code>
<img src="./images/data_security/image-20200515000521165.png" alt="image-20200515000521165" /></li>
<li>可以看到其中存储的内容与E盘文本文件中的内容一致
<img src="./images/data_security/image-20200515000613030.png" alt="image-20200515000613030" /></li>
</ul>
<h3 id="恢复文件"> 恢复文件</h3>
<p>上面你已经学会了查看簇与计算文件大小，接下来会用到的！</p>
<ul>
<li>
<p>首先我们将桌面截图保存jpg图片文件到E盘中
<img src="./images/data_security/image-20200515002740150.png" alt="image-20200515002740150" /></p>
</li>
<li>
<p>然后将他删除，从winhex中打开E盘
<img src="./images/data_security/image-20200515000909347.png" alt="image-20200515000909347" /></p>
</li>
<li>
<p>0009D0A0中0x0B为0F所以这是一个长文件，0009D0C0的0x0B为02所以这部分是表示这是一个文件，其余我们可以不管这里只做恢复所以重要的是看0009D0D0这一行</p>
<ol>
<li>
<p>簇</p>
<ul>
<li>起始簇高字节：<code>0x15-0x16</code> -&gt; <code>00 00</code></li>
<li>起始簇低字节：<code>0x1A-0x1B</code> -&gt; <code>04 00</code></li>
<li>汇总(高 低)：<code>00 00 04 00</code> 分别翻转后得到-&gt; <code>00 00 00 04</code></li>
</ul>
</li>
<li>
<p>文件大小</p>
<ul>
<li><code>0x1C-0x1F</code> -&gt; <code>BA 55 00 00</code></li>
<li>翻转后得到 ：<code>00 00 55 BA</code></li>
<li>转换成十进制后除以512=42(字节)再转换成十六进制数得：2A（偏移所用）</li>
</ul>
</li>
<li>
<p>这里得到了簇是用于定位被删除文件的起始位置，文件大小计算所得的2A是用于定位被删除文件的结束位置</p>
<ul>
<li>
<p>选择菜单栏的<code>位置-&gt;跳转至扇区</code>输入簇值为<code>4</code>，此时我们定位到了被删除文件的其实位置，右键选择<code>选快其实位置</code>
<img src="./images/data_security/image-20200515001848451.png" alt="image-20200515001848451" /></p>
</li>
<li>
<p>然后选择菜单栏的<code>位置-&gt;跳转偏移量</code>，输入刚刚计算得到的十六进制数2A，将后面的单位改为<code>Sectors</code>，并选择从当前位置开始
<img src="./images/data_security/image-20200515002034473.png" alt="image-20200515002034473" /></p>
</li>
<li>
<p>跳转后选择其前一次字节，右键并选择<code>选快尾部</code></p>
<p><img src="./images/data_security/image-20200515002323398.png" alt="image-20200515002323398" /></p>
</li>
<li>
<p>此时我们就选择了一块区域，这块区域就是图片的内容，在蓝色的区域右键<code>编辑-复制选快-至新文件</code>，将其保存到任何地方都行，记得后缀别弄错了是jpg
<img src="./images/data_security/image-20200515002511829.png" alt="image-20200515002511829" /></p>
</li>
<li>
<p>完成！
<img src="./images/data_security/image-20200515002557563.png" alt="image-20200515002557563" /></p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h1 id="ntfs"> NTFS</h1>
<p><a href="https://www.write-bug.com/article/1889.html" target="_blank" rel="noopener noreferrer">参考</a></p>
<ul>
<li>NTFS是windows想抢占服务器行业所做的新文件系统，参照了Unix和linux，一切都是文件不想FAT中有其他的东西</li>
<li>一个文件记录的大小是1KB=1024个字节，占用两个扇区</li>
<li>新特性
<ul>
<li>容错：NTFS可自动修复磁盘错误而不显示出错信息Windows在向NTFS分区写入文件时，在内存中保留一份文件拷贝，然后检査写入的文件与拷贝是否一致，如不一致， windows就把相应的扇区标为坏扇区，然后用内存拷贝重新向磁盘写文件。</li>
<li>安全：支持加密文件系统EFS，授权用户访问文件可以在本机和远程保护文件</li>
<li>文件压缩：支持文件压缩，单个文件或整个文件夹</li>
<li>磁盘配额：允许系统管理员给用户分配磁盘空间，用户只能访问自己的文件</li>
</ul>
</li>
<li>在NTFS中，文件的所有信息，包括文件名所有者、时间、内容等，都是作为NTFS对象的属性来实现的；所以NTFS文件可包含多个数据流</li>
<li>NTFS文件有默认的数据流，没有名称。应用程序可以创建具有名称的数据流，并且通过名称来访问这些数据流：通过在文件名后加上“：”再加上数据流名称来完成。
例如： Myfile.txt: Stream1</li>
</ul>
<h2 id="ntfs的dbr的bpb参数表"> NTFS的DBR的BPB参数表</h2>
<p><img src="./images/data_security/image-20200512090658195.png" alt="image-20200512090658195" /></p>
<h2 id="ntfs分区的区域结构"> NTFS分区的区域结构</h2>
<p><img src="./images/data_security/image-20200512090412051.png" alt="image-20200512090412051" /></p>
<ul>
<li>在NTFS文件系统中，文件也是按簇分配的，一个簇总是扇区数的2的整数次方；磁盘上的任何事物都是文件，文件通过主文件表来确定存储位置</li>
<li>主文件表是一个与文件对应的数据库，由一系列文件记录组成。主文件表也有自身的记录文件</li>
<li>MFT仅供系统本身组织、构架文件系统使用，在NTFS中称为元数据（ Metadata，是存储在卷上支持文件系统格式管理的数据，不能被应用程序访问，只能为系统服务）</li>
<li>最基本的前16个记录是操作系统使用的非常重要的元数据文件。这些元文件名字都以“$”开始，是隐藏文件（通过NFI.EXE可显示）</li>
</ul>
<h2 id="mft"> MFT</h2>
<ul>
<li>MFT中的文件记录大小是固定的，不管簇的大小是多少，均为1KB.(相当于 Linux中的一个 inode</li>
<li>文件记录在MFT文件记录中是物理上连续的，从0开始编号</li>
</ul>
<h2 id="ntfs元文件"> NTFS元文件</h2>
<p><img src="./images/data_security/image-20200512090518071.png" alt="image-20200512090518071" /></p>
<ul>
<li>
<p>文件记录长度可变，末尾以4个<code>FFFF</code>结束</p>
</li>
<li>
<p>文件记录头的结构</p>
<table>
<thead>
<tr>
<th>二进制</th>
<th>数值</th>
<th>表示</th>
</tr>
</thead>
<tbody>
<tr>
<td>0000 0000</td>
<td>0</td>
<td>该记录为文件</td>
</tr>
<tr>
<td>0000 0001</td>
<td>1</td>
<td>正在使用的文件</td>
</tr>
<tr>
<td>0000 0010</td>
<td>2</td>
<td>该记录为目录</td>
</tr>
<tr>
<td>0000 0011</td>
<td>3</td>
<td>这种使用的目录</td>
</tr>
</tbody>
</table>
<h2 id="属性结构"> 属性结构</h2>
</li>
<li>
<p>整体结构可分为两个部分</p>
<ul>
<li>属性头 - 常驻属性头、非常驻属性头
<ul>
<li>常驻 10 30 50 80 90
<ul>
<li>常驻属性头偏移位0x00-0x18，在winhex中为一行半，所以属性头如果没有超过两行则为常驻属性头</li>
</ul>
</li>
<li>非常驻 80 A0
<ul>
<li>如果属性头长度超过两行则为为非常驻属性头</li>
<li>如果此条记录为非常驻，则末尾会有一条深色的记录，记录着属性的运行地址</li>
</ul>
</li>
<li>80为文件数据属性
<ul>
<li>可变属性头（特殊的）</li>
<li>具体看浅色部分的行数
<ul>
<li>未超过两行的常驻属性，深色的部分为存储的数据，将其复制至新文件即可恢复，如果是</li>
<li>超过两行的非常驻属性，深色部分需要计算，计算后得到的即是存储的数据</li>
</ul>
</li>
</ul>
</li>
<li>10 标准信息属性</li>
<li>30 文件名属性头
<ul>
<li>如果一个文件有两个30文件名属性，则表示这个文件为长文件名，第一个为长文件名，第二个为短文件名，由于历史原因短文件名是系统默认保留的</li>
<li>如何区分短文件名和长文件名？看十六进制数中是否出现了<code>7E 00 31</code>代表这<code>~ 1</code></li>
</ul>
</li>
<li>90 索引根属性
<ul>
<li><img src="./images/data_security/image-20200525223229902.png" alt="image-20200525223229902" /></li>
</ul>
</li>
<li>A0索引分配属性</li>
</ul>
</li>
<li>属性内容
<ul>
<li>程序运行，本质上是一个连续存储的空间，运行的时候本来使用的空间不足则会到存储空间中划分一块空间继续使用，不够则继续划分</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="./images/data_security/image-20200525210456717.png" alt="image-20200525210456717" /></p>
<h3 id="非常驻文件分析与文件恢复"> 非常驻文件分析与文件恢复</h3>
<p>如果80属性中浅色部分超过两行，则表示这是一个非常驻属性</p>
<ul>
<li>所有的文件或文件夹都从FILE开始，即<code>46 49 4C 46 30</code></li>
<li>每个文件的第三行的C列都记录着是第几个文件记录（编号），假如是<code>1D</code>那就是第29个文件夹记录</li>
<li>在ntfs中如果文件被删除，出了第二行的第六列会从01改为00，其他都不会变，0表示文件，0是偶数表示被删除的</li>
<li>在ntfs中硬盘格式化并没有将文件数据删除，但文件记录会被删除</li>
</ul>
<div><pre><code>起始的第一个字节的高位+低位是运行记录的大小：3+2 = 5
32 1F 01 F8 52 07 00 00
32:1F 01 F8 52 07
# 高位3 表示后三位是运行的起始簇号
3:F8 52 07 -- 07 52 F8 --479992 起始位置
# 低位2 表示前两位是运行的簇大小
2:1F 01 -- 01 1F - 287簇(cluster) * 8 = 2296 扇区(sector)
----------案例二
31 5D A2 63 04 00 01 00
31 5D A2 63 04 
3:A2 63 04 -- 04 63 A2 -- 287650
2:5D -- 5D -- 93 *8=744 -- 2E8
将起始位置簇为287650，也可以跳转至扇区/8=35956扇区选中，然后再偏移2E8个扇区后将文件复制保存到新文件即可
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><pre><code># 多运行地址的情况：31，3+1=4第五个数后面还是有值，所以继续相加
31 09 5A FE 13 31 03 87 01 FD 00 00 00 70 48 E1
FD后面都是废弃数据
31:09 5A FE 13 -- 
3:13 FE 5A - 1310298（相对位置，相对于硬盘的起始位置）
1:09
-----
31:03 87 01 FD -- 
3:FD 01 87 -16580999（相对位置，相对于上一个位置的起始位置，所以需要加起来） +1310298 = 17891297
1:03
# 需要将这两个文件数据拼起来才能变成一个完整的文件
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="常驻文件的恢复"> 常驻文件的恢复</h3>
<p>常驻文件只需要找到文件所在的簇，常驻文件的80属性头部分（浅色）是不超过两行的，后面的深色部分都是数据，将其复制至新文件保存即可</p>
<h3 id="文件夹分析与恢复"> 文件夹分析与恢复</h3>
<ul>
<li>一开始创建目录的时候只有90属性，文件下的文件记录放置在90中，如果文件夹内的东西越来越多，90索引根属性放不下了，就会创建一个A0索引分配属性，将90的东西放到A0中</li>
<li>长文件名会有两个30，十六进制数<code>7E 00 31</code>代表的~ 1<code>是短文件名的标志，</code>$I30`是90和A0属性文件名特有的名字</li>
<li>如果文件夹内索引内容超过2个扇区，则会放到索引扇区，以<code>INDX</code>开头</li>
<li><img src="./images/data_security/image-20200524215604249.png" alt="image-20200524215604249" /></li>
</ul>
<h4 id="新建一个文件夹"> 新建一个文件夹</h4>
<p><img src="./images/data_security/image-20200520232440692.png" alt="image-20200520232440692" /></p>
<h4 id="添加一个文件"> 添加一个文件</h4>
<p><img src="./images/data_security/image-20200520232853158.png" alt="image-20200520232853158" /></p>
<ul>
<li>如何查看b.txt所在位置？首先看文件的文件记录号：<code>21 00</code>，将其翻转则为<code>00 21</code>，注意这是十六进制数，要转换为十进制数得<code>33*2=66</code>再转十六进制数为42，然后从主文件记录开始向后跳转42个sectors跳转到记录着b.txt的文件记录区域，再找到高光区域的数字对其计算即可找到</li>
</ul>
<h4 id="添加第二个文件"> 添加第二个文件</h4>
<p><img src="./images/data_security/image-20200520234231858.png" alt="image-20200520234231858" /></p>
<h4 id="添加一个长文件名"> 添加一个长文件名</h4>
<p><img src="./images/data_security/image-20200520235013825.png" alt="image-20200520235013825" /></p>
<h4 id="当文件夹下文件过多时"> 当文件夹下文件过多时</h4>
<p>如果文件记录2两个扇区放不下了，就会将90属性值内的记录项移动到了A0属性值内</p>
<p><img src="./images/data_security/image-20200520235539760.png" alt="image-20200520235539760" /></p>
<p>这里计算一次非常驻属性的A0，将其其实位置计算出来，然后跳转到A0的其实簇：39161簇</p>
<div><pre><code>31 01 F9 98 00
3:00 98 F9 - 39161
1:01
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src="./images/data_security/image-20200521000148339.png" alt="image-20200521000148339" /></p>
<h1 id="raid"> RAID</h1>
<h2 id="概念-3"> 概念</h2>
<ul>
<li>是独立冗余磁盘阵列的英文缩写，人们在开发RAID时主要是基于以下设想：即几块小容量的使盘的价格总和要低于一块大容量的硬盘。</li>
<li>虽然RAID在节约成本方面的作用不是很明显，但是RAID可以充分发挥多块硬盘的优势，实现远远超出一块单独硬盘的速度和吞吐量或提供远超过一块硬盘的容错能力</li>
</ul>
<h3 id="原理图"> 原理图</h3>
<p>与单盘系统不同，单盘系统数据是写在单独的硬盘，RAID是同时读写，在读写的时候会将数据进行切片</p>
<p><img src="./images/data_security/image-20200526090502095.png" alt="image-20200526090502095" /></p>
<h3 id="常用的raid级别与分类标准"> 常用的RAID级别与分类标准</h3>
<ul>
<li>RAID技术将多个单独的物理硬盘以不同的方式组合成一个逻辑硬盘，提高了硬盘的读写性能和数据安全性，根据不同的组合方式可以分为不同的RAID级别。</li>
<li><img src="./images/data_security/image-20200526085104435.png" alt="image-20200526085104435" /></li>
</ul>
<h3 id="raid的几种状态"> RAID的几种状态</h3>
<p>若进入降级速度会骤降，如果进入这个状态则需要注意设备更换或修复，否则RAID失效很难进行数据恢复</p>
<p><img src="./images/data_security/image-20200526085345144.png" alt="image-20200526085345144" /></p>
<h3 id="raid0"> RAID0</h3>
<ul>
<li>RAID 0是最早出现的RAID模式</li>
<li>读写时全部硬盘同时运作，由于没有冗余如果其中一块硬盘损坏，则全部数据损坏
<ul>
<li><img src="./images/data_security/image-20200526085426057.png" alt="image-20200526085426057" /></li>
</ul>
</li>
<li>若数据损坏需要将损坏的盘换上，支持热拔插的设备拔下则需要一分钟内更换</li>
<li>整个逻辑盘的数据被分散分布在多个物理盘上，并行读写。（没有冗余能力）</li>
<li>特点
<ul>
<li>利用率100%</li>
<li>读写效率高，理论上为单盘的N倍</li>
<li>无容错能力，安全性低于单盘</li>
</ul>
</li>
<li>DAID需要注意的参数
<ul>
<li>盘序
<ul>
<li>数据先写在哪那个块就是第一个块，如果要恢复数据就需要先找到数据的读写顺序</li>
</ul>
</li>
<li>块大小
<ul>
<li>一个D0叫块</li>
<li>D0和D1叫条块</li>
</ul>
</li>
<li>RAID信息</li>
</ul>
</li>
</ul>
<p><img src="./images/data_security/image-20200526090133959.png" alt="image-20200526090133959" /></p>
<h3 id="raid1"> RAID1</h3>
<ul>
<li>数据读写同时分别写在两块硬盘中，如果其中一块硬盘损坏或数据损坏，可以直接从另一块硬盘中恢复
<ul>
<li><img src="./images/data_security/image-20200526091208683.png" alt="image-20200526091208683" /></li>
</ul>
</li>
<li>把一个磁盐的数据镜像到另一个硬盐上，通常在两块盘上实施</li>
<li>特点
<ul>
<li>利用率低：1/N</li>
<li>读写效率好，写效率一般</li>
<li>容错性好</li>
</ul>
</li>
<li>RAID1需要注意参数
<ul>
<li>RAUD信息</li>
</ul>
</li>
</ul>
<h3 id="raid3"> RAID3</h3>
<ul>
<li>需要三块硬盘，不能自动恢复数据若数据损坏需要将损坏的盘换上，支持热拔插的设备拔下则需要一分钟内更换</li>
<li>工作原理使用上了异或校验码，拿出其中一块硬盘做异或运算，因为<code>0^0=0</code>、<code>0^1=1</code>、<code>1^0=1</code>、<code>0^0=0</code>，若第一块硬盘坏了则通过异或校验可以反向得出损坏的那块硬盘的数据,但两块就不行了
<ul>
<li><img src="./images/data_security/image-20200526091432298.png" alt="image-20200526091432298" /></li>
</ul>
</li>
</ul>
<h3 id="raid5-应用最广泛"> RAID5  （应用最广泛）</h3>
<ul>
<li>需要三块硬盘以上，读写的时候将校验码分别存储在不同的硬盘中，比如写入D0和D1时会生成P0校验值再存储，若其中一块硬盘损坏会自动恢复不需要更换硬盘，但两块就不行了，RAID 5 (可以<em>理解为是RAID 0和RAID 1的</em>折衷方案</li>
<li>写入速度会稍微慢，因为需要生成校验快，读取则很快，因为不设计校验码</li>
<li><img src="./images/data_security/image-20200526092302925.png" alt="image-20200526092302925" /></li>
<li>如果有三块500g的硬盘组成RAID5，则构成的空间是1T，因为其中一块（分别加起来）用作校验</li>
<li>RAID5是应用最广泛的，但是最难恢复数据的，因为不知道数据的读写顺序，整个逻辑盘的数据以条带方式被分散分布在多个物理盘上（3块以上），每个条带中设置专门一个数据块存储该条带的异或校验。</li>
<li>特点
<ul>
<li>利用率：（N-1)/N</li>
<li>读效率稍高，写效率稍差</li>
<li>容错性：允许一块硬盘故障</li>
</ul>
</li>
<li>需要注意的参数
<ul>
<li>盘序</li>
<li>块大小</li>
<li>校验方式</li>
<li>RAID信息</li>
</ul>
</li>
</ul>
<h3 id="raid6"> RAID6</h3>
<p>虽然安全性好允许两块硬盘损坏，但由于需要进行计算，性能不搞，使用人也不多</p>
<ul>
<li>RAID6是带有两种校验的独立磁盘结构，采用两种奇偶校验方法，需要至少N+2(N&gt;2)个磁盘来构成阵列，一般用在数据可靠性、可用性要求极高的应用场合</li>
<li>常用的RAID6技术有<code>RAID6 P</code>+<code>Q</code>和<code>RAID6 DP</code></li>
<li>原理
<ul>
<li>RAID6 P的工作原理，P作横向校验，Q作斜向校验
<img src="./images/data_security/image-20200526093222260.png" alt="image-20200526093222260" /></li>
<li>RAID6 DP的工作原理，可以通过斜向校验得到其中一个数据，也可以通过横向校验得到其中一个数据
<img src="./images/data_security/image-20200526093309512.png" alt="image-20200526093309512" /></li>
</ul>
</li>
</ul>
<h3 id="raid10"> RAID10</h3>
<ul>
<li>混合阵列，性能好，但一旦出现数据损坏则会难以修复</li>
</ul>
<p><img src="./images/data_security/image-20200526093857505.png" alt="image-20200526093857505" /></p>
<h3 id="raid50"> RAID50</h3>
<ul>
<li>混合阵列，性能好，但一旦出现数据损坏则会难以修复</li>
<li>RAID50是将RAID5和RAID0进行两级组合的RAID级别，第一级RAID5,第二级为RAID0.</li>
</ul>
<p><img src="./images/data_security/image-20200526093924924.png" alt="image-20200526093924924" /></p>
<h3 id="常用raid级别的比较"> 常用RAID级别的比较</h3>
<p><img src="./images/data_security/image-20200526094037114.png" alt="image-20200526094037114" /></p>
<h3 id="应用场景"> 应用场景</h3>
<p><img src="./images/data_security/image-20200526094804868.png" alt="image-20200526094804868" /></p>
<h2 id="文件恢复-2"> 文件恢复</h2>
<p><code>((差值的十六进制)*4后转十进制)/512</code></p>
<ol>
<li>确定盘序</li>
<li>确定块大小</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>linux课记</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/notes/linux_note/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/notes/linux_note/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">linux课记</source>
      <category>笔记</category>
      <pubDate>Sun, 05 Jul 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="导"> 导</h1>
<p>这篇笔记始于2020/3/10</p>
<h2 id="介绍"> 介绍</h2>
<p>Linux操作系统是UNIX操作系统的一种克隆系统，它诞生于1991 年的10 月5 日（这是第一次正式向外公布的时间）。以后借助于Internet网络，并通过全世界各地计算机爱好者的共同努力，已成为今天世界上使用最多的一种UNIX 类操作系统，并且使用人数还在迅猛增长。
Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。它主要用于基于Intel x86系列CPU的计算机上。这个系统是由全世界各地的成千上万的程序员设计和实现的。其目的是建立不受任何商品化软件的版权制约的、全世界都能自由使用的Unix兼容产品。
Linux以它的高效性和灵活性著称，Linux模块化的设计结构，使得它既能在价格昂贵的工作站上运行，也能够在廉价的PC机上实现全部的Unix特性，具有多任务、多用户的能力。Linux是在GNU公共许可权限下免费获得的，是一个符合POSIX标准的操作系统。Linux操作系统软件包不仅包括完整的Linux操作系统，而且还包括了文本编辑器、高级语言编译器等应用软件。它还包括带有多个窗口管理器的X-Windows图形用户界面，如同我们使用Windows NT一样，允许我们使用窗口、图标和菜单对系统进行操作。</p>
<h2 id="自学站点推荐"> 自学站点推荐：</h2>
<ol>
<li>https://www.icourse163.org/（慕课）
<ol>
<li>https://www.icourse163.org/search.htm?search=linux#/</li>
</ol>
</li>
<li>https://cn.netacad.com/（思科）</li>
<li>https://www.educoder.net/（在线实训）
<ol>
<li>https://www.educoder.net/shixuns?id=16&amp;type=sub&amp;palce=6</li>
</ol>
</li>
<li>https://www.linuxprobe.com/（Linux培训，Linux就该这么学，资源多）</li>
<li>https://www.fujieace.com/linux/man/china-man.html（命令查找）</li>
</ol>
<h2 id="开源协议"> 开源协议</h2>
<p>主要流行的开原协议有六种：GPL、BSD、MIT、MPL（Mozilla）、Apache和LGPL，需要记住的是开源不等于免费，开源也不等于没有约束</p>
<p><img src="./images/linux_notes/image-20200310152131280.png" alt="廖雪峰" /></p>
<ol>
<li>
<p>简单宽松的协议
如果你怕麻烦只想要一个简单协议，MIT协议相对宽松但抓住了要点，此协议允许别人以任何方式使用你的代码同时署名原作者，但原作者不承担代码使用后的风险，当然也没有技术支持的义务，jQuery和Rails就是MIT协议。</p>
</li>
<li>
<p>有专利的需求
如果你的作品中涉及到专利相关，Apache协议也是个相对宽松与MIT类似的协议，但它简单指明了作品归属者的著作权，Apache服务器，SVN还有NuGet等是使用的Apache协议。</p>
</li>
<li>
<p>代码分享与促进</p>
<p>如果你在乎作品的传播和别人的修改，希望别人也以相同的协议分享出来。GPL（V2或V3）是一种版本自由的协议（可以参照copy right来理解，后者是版本保留，那copyleft便是版权自由，或者无版权，但无版权不代表你可以不遵守软件中声明的协议）。此协议要求代码分发者或者以此代码为基础开发出来的衍生作品需要以同样的协议来发布。</p>
</li>
</ol>
<p><img src="./images/linux_notes/image-20200310152131300.jpg" alt="不同协议的详细比较" /></p>
<p>参考资料：</p>
<ol>
<li>http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html</li>
<li>https://www.zhihu.com/question/28292322/answer/222922925</li>
<li>https://choosealicense.com/</li>
</ol>
<h2 id="三种软件模式"> 三种软件模式</h2>
<ul>
<li>商业软件
<ul>
<li>由开发者出售拷贝并提供软件技术服务，用户只有使用权， 但不得进行非法拷贝、扩散和修改</li>
</ul>
</li>
<li>共享软件
<ul>
<li>共享软件由开发者提供试用程序拷贝授权，用户在使用该程序拷贝一段时间之后，必须向开发者缴纳使用费，开发者则提供相应的升级和技术服务</li>
</ul>
</li>
<li>自由软件
<ul>
<li>自由软件所指称的软件，其使用者有使用、复制、散布、研究、改写、再利用该软件的自由</li>
<li>自由软件的创始人：Richard M.Stallman，他是黑客历史上最伟大的黑客，被称为黑客中的圣者</li>
</ul>
</li>
</ul>
<h2 id="什么是操作系统"> 什么是操作系统</h2>
<p>操作系统（Operating Ststem，简称OS）传统上是负责对电脑硬件直接控制及管理的系统软件</p>
<ul>
<li>操作系统的功能一般包括处理器管理、存储管理、文件管理、设备管理和作业管理等</li>
<li>当多个程序同时运行时，操作系统负责规划以及优化每个程序的处理时间</li>
</ul>
<p>对计算机系统而言，操作系统是对所有系统资源进行管理的程序的集合；对用户而言，操作系统提供了对系统资源进行有效利用的简单抽象的方法</p>
<h1 id="linux系统"> Linux系统</h1>
<p>Linux是个类Unix的系统，同时他是一个自由软件，是免费的、源代码开放的，编制他的目的是简历不受任何商业化软件版权制约的、全世界都能自由使用的UNIX兼容产品，稳定可靠本课主要以centos为主</p>
<p>虽然常被称为Linux，但他们应该更准确的被称为GNU/Linux</p>
<h2 id="特点"> 特点</h2>
<ul>
<li>开放性的系统</li>
<li>多用户多任务的系统</li>
<li>具有出色的稳定性和速度性能</li>
<li>具有可靠的系统安全性</li>
<li>提供了丰富的网络功能</li>
<li>标准兼容性和可移植性</li>
<li>提供了良好的用户界面</li>
</ul>
<h2 id="组成"> 组成</h2>
<ul>
<li>
<p>Linux内核</p>
<p>内核源代码：https://www.kernel.org/，内核（Kernel）是系统的心脏，实现操作系统的基本功能</p>
</li>
<li>
<p>Linux Shell：shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口</p>
</li>
<li>
<p>LInux应用程序：包括文本编辑器、编程语言、window、办公套件、Internet工具、数据库等</p>
</li>
<li>
<p>Linux文件系统：文件系统是文件存放在磁盘等存储设备上的组织办法。通常是按照目录层次方式进行组织。系统以/为根目录</p>
</li>
</ul>
<h2 id="内核版本"> 内核版本</h2>
<p><img src="./images/linux_notes/image-20200312134542643.png" alt="image-20200312134541891" /></p>
<h2 id="主流linux发行套件"> 主流Linux发行套件</h2>
<p>主要分redhat红帽类和debian类，目前主流为红帽7</p>
<ul>
<li>
<p>redhat（服务器）</p>
<p>redhat.com</p>
<p>免费开放下载安装，但不能自动更新以及后期问题技术解决支持</p>
<p>收费项目：</p>
<ul>
<li>自动更新漏洞</li>
<li>后期问题技术解决支持</li>
</ul>
</li>
<li>
<p>centos（服务器）</p>
<p>北美Linux爱好者们制作而成，与红帽几乎相等，支持自动更新，但无技术支持（已被红帽收购）</p>
</li>
<li>
<p>defora（个人）</p>
<p>界面友好，常用作进入软件redhat前的测试（红帽旗下）</p>
</li>
<li>
<p>Ubuntu</p>
<p>界面友好（debian类）</p>
</li>
</ul>
<p>课后作业：站点推荐的查看与环境下载与搭建centos7</p>
<p>安装使用：virtualbox 或 vmware workstation</p>
<h2 id="具体文件结构"> 具体文件结构</h2>
<ol>
<li><code>/</code>：根目录，所有的目录、文件、设备都在/之下，/就是Linux文件系统的组织者，也是最上级的领导者。</li>
<li><code>/bin</code>：bin 就是二进制（binary）英文缩写。在一般的系统当中，都可以在这个目录下找到linux常用的命令。系统所需要的那些命令位于此目录。</li>
<li><code>/boot</code>：Linux的内核及引导系统程序所需要的文件目录，比如 vmlinuz initrd.img 文件都位于这个目录中。在一般情况下，GRUB或LILO系统引导管理器也位于这个目录。</li>
<li><code>/cdrom</code>：这个目录在刚刚安装系统的时候是空的。可以将光驱文件系统挂在这个目录下。例如：mount /dev/cdrom /cdrom</li>
<li><code>/dev</code>：dev 是设备（device)的英文缩写。这个目录对所有的用户都十分重要。因为在这个目录中包含了所有linux系统中使用的外部设备。但是这里并不是放的外部设备的驱动程序。这一点和常用的windows,dos操作系统不一样。它实际上是一个访问这些外部设备的端口。可以非常方便地去访问这些外部设备，和访问一个文件，一个目录没有任何区别。</li>
<li><code>/etc</code>：etc这个目录是linux系统中最重要的目录之一。在这个目录下存放了系统管理时要用到的各种配置文件和子目录。要用到的网络配置文件，文件系统，x系统配置文件，设备配置信息，设置用户信息等都在这个目录下。</li>
<li><code>/home</code>：如果建立一个用户，用户名是&quot;xx&quot;,那么在/home目录下就有一个对应的/home/xx路径，用来存放用户的主目录。</li>
<li><code>/lib</code>：lib是库（library）英文缩写。这个目录是用来存放系统动态连接共享库的。几乎所有的应用程序都会用到这个目录下的共享库。因此，千万不要轻易对这个目录进行什么操作，一旦发生问题，系统就不能工作了。</li>
<li><code>/lost+found</code>：在ext2或ext3文件系统中，当系统意外崩溃或机器意外关机，而产生一些文件碎片放在这里。当系统启动的过程中fsck工具会检查这里，并修复已经损坏的文件系统。有时系统发生问题，有很多的文件被移到这个目录中，可能会用手工的方式来修复，或移到文件到原来的位置上。</li>
<li><code>/mnt</code>：这个目录一般是用于存放挂载储存设备的挂载目录的，比如有cdrom等目录。可以参看/etc/fstab的定义。</li>
<li><code>/media</code>：有些linux的发行版使用这个目录来挂载那些usb接口的移动硬盘（包括U盘）、CD/DVD驱动器等等。</li>
<li><code>/opt</code>：这里主要存放那些可选的程序。</li>
<li><code>/proc</code>：可以在这个目录下获取系统信息。这些信息是在内存中，由系统自己产生的。</li>
<li><code>/root</code>：Linux超级权限用户root的家目录。</li>
<li><code>/sbin</code>：这个目录是用来存放系统管理员的系统管理程序。大多是涉及系统管理的命令的存放，是超级权限用户root的可执行命令存放地，普通用户无权限执行这个目录下的命令，这个目录和/usr/sbin; /usr/X11R6/sbin或/usr/local/sbin目录是相似的，凡是目录sbin中包含的都是root权限才能执行的。</li>
<li><code>/selinux</code> ：对SElinux的一些配置文件目录，SElinux可以让linux更加安全。</li>
<li><code>/srv</code>： 服务启动后，所需访问的数据目录，举个例子来说，www服务启动读取的网页数据就可以放在/srv/www中</li>
<li><code>/tmp</code>：临时文件目录，用来存放不同程序执行时产生的临时文件。有时用户运行程序的时候，会产生临时文件。/tmp就用来存放临时文件的。/var/tmp目录和这个目录相似。</li>
<li><code>/usr</code>：这是linux系统中占用硬盘空间最大的目录。用户的很多应用程序和文件都存放在这个目录下。在这个目录下，可以找到那些不适合放在/bin或/etc目录下的额外的工具</li>
<li><code>/usr/local</code>：这里主要存放那些手动安装的软件，即不是通过“新立得”或apt-get安装的软件。它和/usr目录具有相类似的目录结构。让软件包管理器来管理/usr目录，而把自定义的脚本（scripts)放到/usr/local目录下面、。</li>
<li><code>/usr/share</code> ：系统共用的东西存放地，比如 /usr/share/fonts 是字体目录，/usr/share/doc和/usr/share/man帮助文件。</li>
<li><code>/var</code>：这个目录的内容是经常变动的，看名字就知道，可以理解为vary的缩写，/var下有/var/log 这是用来存放系统日志的目录。/var/ www目录是定义Apache服务器站点存放目录；/var/lib 用来存放一些库文件，比如MySQL的，以及MySQL数据库的的存放地。</li>
</ol>
<h1 id="安装与详解"> 安装与详解</h1>
<p>2020/3/12</p>
<ul>
<li>虚拟机如果出现虚拟机被锁定，可以去虚拟机存储的目录中将.lck的文件删除</li>
<li>系统版本介绍
<ul>
<li><code>DVD</code> 标准版（推荐用这个）4G</li>
<li><code>Everything</code> 完整版本10G</li>
<li><code>LiveKDE</code> 体验版1G</li>
<li><code>Minnimal</code> 最小安装包0.9G</li>
<li><code>NetInstall</code> 网络安装0.5G</li>
</ul>
</li>
<li>我们可以在镜像站中选择下载，下面介绍的安装过程是用了网易的centOS的DVD标准版，http://mirrors.163.com/centos/7.7.1908/isos/x86_64/</li>
</ul>
<p><img src="./images/linux_notes/image-20200312132803802.png" alt="image-20200312132803802" /></p>
<h2 id="安装过程"> 安装过程</h2>
<p>首先我们新建虚拟机，这里最好用自定义来安装</p>
<p><img src="./images/linux_notes/image-20200312023501249.png" alt="image-20200312023501249" /></p>
<p>选择硬件兼容性这里越高越好</p>
<p><img src="./images/linux_notes/image-20200312023525501.png" alt="image-20200312023525501" /></p>
<p>这里我们使用稍后安装操作系统</p>
<p><img src="./images/linux_notes/image-20200312023625126.png" alt="image-20200312023625126" /></p>
<p>选择Linux，并选择对应的版本</p>
<p><img src="./images/linux_notes/image-20200312023649173.png" alt="image-20200312023649173" /></p>
<p>这里选择安装的位置以及在VM中显示的名称</p>
<p><img src="./images/linux_notes/image-20200312023724438.png" alt="image-20200312023724438" /></p>
<p>为虚拟机指定的处理器（CPU）数量</p>
<p><img src="./images/linux_notes/image-20200312023740953.png" alt="image-20200312023740953" /></p>
<p>为其分配的内存</p>
<p><img src="./images/linux_notes/image-20200312023750071.png" alt="image-20200312023750071" /></p>
<p>为其分配磁盘大小，为了后期的操作越大越好，接下来都是默认下一步即可</p>
<p><img src="./images/linux_notes/image-20200312023832356.png" alt="image-20200312023832356" /></p>
<p>完成之后选择<code>编辑虚拟机</code>设置添加挂载光盘镜像</p>
<p><img src="./images/linux_notes/image-20200312023908015.png" alt="image-20200312023908015" /></p>
<p>点击<code>CD/DVD（IDE）</code>这里推荐使用centOS DVD即标准版，你也可以使用Everything的版本，选择好之后点击完成并打开虚拟机</p>
<p><img src="./images/linux_notes/image-20200312023944540.png" alt="image-20200312023944540" /></p>
<p>打开虚拟机之后会让你选择安装还是测试，这里选择第一个安装install CentOS即可</p>
<p><img src="./images/linux_notes/image-20200312114456274.png" alt="image-20200312114456274" /></p>
<p>这里可能需要你按下回车键，然后等待一会</p>
<p><img src="./images/linux_notes/image-20200312024303748.png" alt="image-20200312024303748" /></p>
<p>进入了安装界面进行配置，为了体验良好可以选择中文安装，这里选择中文在安装的时候是中文，安装完成之后也自动会是中文，点击继续</p>
<p><img src="./images/linux_notes/image-20200312114736077.png" alt="image-20200312114736077" /></p>
<p>之后等待一会，这里的安装源就是我们的iso文件，右边的软件选择它默认是最小安装，如果选择了最小安装，安装之后是没有图像界面的，如果想安装带有GUI姐买你的话这里就需要点击软件选择</p>
<p><img src="./images/linux_notes/image-20200312115021760.png" alt="image-20200312115021760" /></p>
<p>然后选择带GUI的服务器，点击完成即可</p>
<p><img src="./images/linux_notes/image-20200312115003876.png" alt="image-20200312115003876" /></p>
<p>之后点击安装位置，这是具体分区，我们使用自动配置完成即可</p>
<p><img src="./images/linux_notes/image-20200312115128268.png" alt="image-20200312115128268" /></p>
<p>然后点击KDUMP，将其取消，点击完成</p>
<p><img src="./images/linux_notes/image-20200312115218057.png" alt="image-20200312115218057" /></p>
<p>最后配置网络设置，这里需要视具体情况配置，配置虚拟机的时候使用了NAT,所以直接配置自动获取就好，假如你使用了桥接的方式则需要根据局域网的配置进行手动获自动配置，完成之后你也可以更改下面的主机名，记得点击应用然后完成开始安装</p>
<p><img src="./images/linux_notes/image-20200312115330472.png" alt="image-20200312115330472" /></p>
<p>安装过程中你需要配置一个root密码（记得设置得复杂点），因为在平时操作中我们都是用普通用户去登录所以建议再创建一个用户</p>
<p><img src="./images/linux_notes/image-20200312115723457.png" alt="image-20200312115723457" /></p>
<p>配置好之后等待安装完成，安装好之后会让你选择重启计算机，点击重启</p>
<p><img src="./images/linux_notes/image-20200312125008634.png" alt="image-20200312125008634" /></p>
<p>等待重启完成之后会让你同意开源协议，点进去同意即可，然后点击完成配置</p>
<p><img src="./images/linux_notes/image-20200312125344674.png" alt="image-20200312125344674" /></p>
<p>此时已经配置完成了，点击登录你刚刚创建的用户登录或选择未列出使用root即可进入带有图形界面的centOS</p>
<p><img src="./images/linux_notes/image-20200312125535307.png" alt="image-20200312125535307" /></p>
<p><img src="./images/linux_notes/image-20200312130015602.png" alt="image-20200312130015602" /></p>
<p>在GUI的界面可以和字符界面进行互换</p>
<h2 id="详解"> 详解</h2>
<p>图像界面在linux中也只是一个程序</p>
<p>如果是最小化安装则是纯命令行的模式，服务器的安全级别比较高的话也是纯命令行的模式</p>
<p>安装好图形界面可以自由切换命令行的图形界面</p>
<p>字符界面转图形界面：<code>init 3</code></p>
<h2 id="linux工作界面"> Linux工作界面</h2>
<p>Linux的工作界面有两种：字符界面与图形界面</p>
<ul>
<li></li>
<li></li>
<li></li>
<li>[X Window的概念和作用](###X Window概念和作用)</li>
<li></li>
<li></li>
</ul>
<h3 id="字符界面"> 字符界面</h3>
<ul>
<li>
<p>使用字符界面的好处</p>
<ul>
<li>
<p>在字符操作方式下可以高效的完成所有的任务，尤其是系统管理任务</p>
</li>
<li>
<p>系统管理任务通常在远程进行，而远程登录后进入的是字符工作方式</p>
</li>
<li>
<p>由于使用字符界面不用启动图形工作环境，大大的节省了系统资源开销</p>
</li>
</ul>
</li>
<li>
<p>如何进入字符界面</p>
<ul>
<li>在图形环境下开启终端窗口进入字符界面的方式</li>
<li>在系统启动后直接进入字符工作方式</li>
<li>使用远程登录方式（Telnet或SSH）进入字符工作方式</li>
<li>字符界面登录与注销
<ul>
<li>虚拟控制台（Virtual Console）
<ul>
<li>系统默认提供了6个虚拟控制台。每个虚拟控制台可以独立的使用，互不影响</li>
<li>使用Alt+F1~Alt+F6进行多个虚拟控制台之间的切换</li>
</ul>
</li>
<li>登录提示符
<ul>
<li>超级用户登录后的操作提示符是：<code>#</code></li>
<li>普通用户登录后的操作提示符是：<code>$</code></li>
</ul>
</li>
<li>注销
<ul>
<li><code>logout</code>命令</li>
<li><code>Ctrl+D</code>热键</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>注意：一般应该使用普通用户登录系统，不要使用root用户登录，当需要进行超级用户工作时可以使用su - 命令切换为超级用户身份</p>
</li>
<li>
<p>在Linux环境下使用SSH远程登录Linux</p>
<ul>
<li>ssh：Secure shell</li>
<li>用户在通过ssh连接到远程系统时在网络上传输的口令和数据都是经过加密的，比传统的telnet远程登录更加安全</li>
<li>ssh的使用方法：
<ul>
<li><code>$ ssh -l osmond 192.168.1.100</code></li>
<li><code>$ ssh osmond@192.168.1.100</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>在Windows环境下使用putty远程登录Linux</p>
<ul>
<li>在putty中支持telnet、ssh、rlogin等连接方式</li>
</ul>
</li>
<li>
<p>获取帮组：</p>
<ul>
<li>字符界面：
<ul>
<li><code>help</code>：获得bash的内部命令棒子</li>
<li><code>man</code>：获得手册页帮助（推出man按q即可）
<ul>
<li><code>$ man passwd</code></li>
<li><code>$ man 5 passwd</code></li>
<li><code>$ man -k selinux</code></li>
</ul>
</li>
<li><code>info</code>：获得texinfo文档帮助（推出info按q即可）</li>
<li><code>pinfo</code>：获得texinfo文档帮助</li>
<li>wh*命令
<ul>
<li><code>$ whatis ls</code></li>
<li><code>$ whereis ls</code></li>
<li><code>$ whichis ls</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="图形界面"> 图形界面</h3>
<p>在使用环境中图形界面虽然友好，但是非常耗费系统资源，而且图形界面存在的安全漏洞也更多</p>
<ul>
<li>两种桌面集成环境
<ul>
<li>Gnome集成环境
<ul>
<li>获得帮助：
<ul>
<li><code>tylp</code>：浏览帮助文档</li>
</ul>
</li>
</ul>
</li>
<li>KDE集成环境</li>
</ul>
</li>
</ul>
<h3 id="shell"> shell</h3>
<h4 id="概念"> 概念</h4>
<p>shell是用户和Linux内核之间的接口程序，为用户提供使用操作系统的操作接口。他是一种基于传统字符界面的操作系统，与DOS有几分类似，在Linux系统中具有极其重要的地位
Shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行。实际上Shell是一个命令解释器，它解释由用户输入的命令并且把它们送到内核。不仅如此，Shell有自己的编程语言用于对命令的编辑，它允许用户编写由shell命令组成的程序。Shell编程语言具有普通编程语言的很多特点，比如它也有循环结构和分支控制结构等，用这种编程语言编写的Shell程序与其他应用程序具有同样的效果。同Linux本身一样，Shell也有多种不同的版本。目前主要有下列版本的Shell：　Bourne Shell：是贝尔实验室开发的。</p>
<ul>
<li><code>BASH</code>：是GNU的Bourne Again Shell，是GNU操作系统上默认的shell。</li>
<li><code>Korn Shell</code>：是对Bourne SHell的发展，在大部分内容上与Bourne Shell兼容。</li>
<li><code>C Shell</code>：是SUN公司Shell的BSD版本。</li>
<li><code>Z Shell</code>：The last shell you’ll ever need! Z是最后一个字母，也就是终极Shell。它集成了bash、ksh的重要特性，同时又增加了自己独有的特性。</li>
</ul>
<h4 id="功能"> 功能</h4>
<ul>
<li>进行命令解释</li>
<li>解释型的程序设计语言</li>
</ul>
<h4 id="shell种类"> shell种类</h4>
<ul>
<li>Bourne shell (sh)</li>
<li>C shell (csh)</li>
<li>Korn shell (ksh)</li>
</ul>
<h3 id="虚拟终端的作用"> 虚拟终端的作用</h3>
<ul>
<li>当在系统启动时直接进入字符工作方式后，系统提供了多个虚拟控制台。每个虚拟控制台可以独立使用，互不影响</li>
<li>虚拟控制台使得 Linux成为一个真正的多用户操作系统。在不同的控制台上，可以同时接受多个用户登录；也允许一个用户进行多次登录。</li>
<li>虚拟控制台之间的切换
<ul>
<li><code>alt+f1</code>~<code>alt+f6</code></li>
<li><code>ctrl+alt+f1</code>~<code>ctrl+alt+f6</code>（用户使用startx命令在字符界面下启动了图形环境时切换字符虚拟终端的方式，使用ctrl+alrt+f7切换到图形界面）</li>
</ul>
</li>
</ul>
<h3 id="x-window概念和作用"> X Window概念和作用</h3>
<p>一套Unix共通的图形界面标准，复合X Window协定的软件都可以在任何X Window上显示，执行与显示独立运作</p>
<p>人性化桌面环境：Gnome与KDE</p>
<h3 id="gnome桌面图标的作用"> GNOME桌面图标的作用</h3>
<p>GNOME是GNU网络对象模型环境（GNU Network Object Model Environment）的缩写，他是GNU项目的一部分，是完全开放源代码的自由软件</p>
<p>在Red Hat Linux系统中，已经将GNOME作为默认的桌面管理器</p>
<p><img src="./images/linux_notes/image-20200312143150700.png" alt="image-20200312143150700" /></p>
<h3 id="kde桌面"> KDE桌面</h3>
<p>KDE桌面环境（ K desktopnvi ronment）是使用图标、窗口、菜单和面板之类常用图形化对象的图形化桌面。KDE的外观、操作和 Windows非常相似，大大降低了 Linux用户的学习难度，同时在稳定性上KDE也非常出色</p>
<h3 id="其他"> 其他</h3>
<p><img src="./images/linux_notes/image-20200312143430030.png" alt="image-20200312143430030" /></p>
<p><img src="./images/linux_notes/image-20200312143453832.png" alt="image-20200312143453832" /></p>
<h4 id="关机"> 关机</h4>
<ul>
<li><code>shutdown或shutdown -h now/+n(立即或n分钟后关闭系统)</code></li>
<li><code>halt</code>：关闭系统（其实就是调用shutdown -h）</li>
<li><code>intit 0</code></li>
</ul>
<h4 id="重启"> 重启</h4>
<ul>
<li><code>shutdown -r</code></li>
<li><code>inti 6</code></li>
<li><code>reboot</code></li>
</ul>
<p>PV-VG-LV的设备名</p>
<table>
<thead>
<tr>
<th></th>
<th>含义</th>
<th>设备名</th>
</tr>
</thead>
<tbody>
<tr>
<td>PV</td>
<td>物理卷：磁盘或分区</td>
<td><code>/dev/dsa</code></td>
</tr>
<tr>
<td>VG</td>
<td>卷组：一组磁盘 和/或 分区</td>
<td><code>/dev/&lt;VG name&gt;（目录）</code></td>
</tr>
<tr>
<td>LV</td>
<td>逻辑卷：LVM分区</td>
<td><code>/dev/&lt;VF name&gt;/&lt;LV name&gt;</code></td>
</tr>
</tbody>
</table>
<h3 id="系统文件夹"> 系统文件夹</h3>
<table>
<thead>
<tr>
<th>位置</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>/bin</td>
<td>存放所有用户可以使用的目录</td>
</tr>
<tr>
<td>/sbin</td>
<td>存放只有系统管理员可以使用的目录</td>
</tr>
<tr>
<td>/boot</td>
<td>用于存放于系统启动相关的文件</td>
</tr>
<tr>
<td>/dev</td>
<td>设备文件存放位置</td>
</tr>
<tr>
<td>/etc</td>
<td>配置文件存放位置</td>
</tr>
<tr>
<td>/home</td>
<td>普通用户家目录</td>
</tr>
<tr>
<td>/lib</td>
<td>用户存放系统的动态链接库</td>
</tr>
<tr>
<td>/mnt</td>
<td>移动存储介质的默认挂载点</td>
</tr>
<tr>
<td>/root</td>
<td>root用户家目录。</td>
</tr>
<tr>
<td>/proc</td>
<td>位于内存中的内核信息</td>
</tr>
<tr>
<td>/tmp</td>
<td>用于存放各种临时文件</td>
</tr>
<tr>
<td>/var</td>
<td>用于存放经常变化的文件</td>
</tr>
</tbody>
</table>
<p>每一个用户都有自己的主目录（家目录），主目录与根目录不一样</p>
<h3 id="文件路径"> 文件路径</h3>
<p>linux的路径采用<code>/</code>开始，文件夹在创建中尽量避免使用<code></code>空格，因为空格在shell中是作为分隔符使用</p>
<ul>
<li>到<code>rpm</code>的绝对路径是从<code>/usr/lib/rpm</code></li>
<li>从usr到rpm的相对路径是：<code>./lib/rpmvcvcvvvc</code></li>
</ul>
<p><img src="./images/linux_notes/image-20200317160001893.png" alt="image-20200317160001893" /></p>
<h3 id="绝对路径与相对路径"> 绝对路径与相对路径</h3>
<ol>
<li>查看当前所在的路径的命令：<code>pwd</code></li>
<li>如果想切换到<code>/etc/</code>目录应使用：cd /etc</li>
<li>回到上次所在目录：cd -</li>
<li>回到主目录：cd</li>
<li>切换到根目录：cd /</li>
<li>切换到上级目录：cd ..</li>
<li>若当前位于/etc/stsconfig/network-scripts/warpper目录下如何快速回到/etc/stsconfig目录下：cd ../..</li>
</ol>
<h2 id="linux命令介绍"> Linux命令介绍</h2>
<p>2020/03/17</p>
<p>虚拟机中linux系统导出ova文件放到一个地方</p>
<p>在云平台中当用户需要一个虚拟机的时候，就可以通过这种ova的方法快速给用户建立一个虚拟系统</p>
<h3 id="图形界面与字符界面"> 图形界面与字符界面</h3>
<p>图形界面非常消耗系统资源且安全漏洞较多</p>
<h3 id="大小写区分"> 大小写区分</h3>
<p>inux系统中命令区分大小写，windows中区分大小写，如果在windows中创建文件夹，大小写相同的文件夹将报错，在linux中复制a和A的文件夹到windows会报错！</p>
<h3 id="shell-2"> shell</h3>
<p>在shell中是作为分隔符使用，shell也能算是编程的一种</p>
<h2 id="linux常用命令"> Linux常用命令</h2>
<h3 id="获取帮助"> 获取帮助</h3>
<h4 id="man"> man</h4>
<p><code>man [命令]</code></p>
<h4 id="h"> -h</h4>
<p><code>[命令] -h / --help</code></p>
<h4 id="help"> help</h4>
<p><code>help [命令]</code></p>
<h4 id="info"> info</h4>
<p><code>info [命令]</code></p>
<h4 id="百度-谷歌"> 百度/谷歌</h4>
<h3 id="init"> init</h3>
<p>所谓的init进程，它是一个由内核启动的用户级进程。</p>
<p>内核自行启动（已经被载入内存，开始运行，并已初始化所有的设备驱动程序和数据结构等）之后，就通过启动一个用户级程序init的方式，完成引导进程。所以,init始终是第一个进程（其进程编号始终为1）。</p>
<p>内核会在过去曾使用过init的几个地方查找它，它的正确位置（对Linux系统来说）是/sbin/init。如果内核找不到init，它就会试着运行/bin/sh，如果运行失败，系统的启动也会失败</p>
<ul>
<li>init一共分为7个级别，这7个级别的所代表的含义如下</li>
<li>0：停机或者关机（千万不能将initdefault设置为0）</li>
<li>1：单用户模式，只root用户进行维护</li>
<li>2：多用户模式，不能使用NFS(Net File System)</li>
<li>3：完全多用户模式（标准的运行级别）</li>
<li>4：安全模式</li>
<li>5：图形化（即图形界面）</li>
<li>6：重启（千万不要把initdefault设置为6）</li>
</ul>
<h3 id="系统关机或重启或切换字符界面"> 系统关机或重启或切换字符界面</h3>
<h4 id="通过快捷键切换图形与字符窗口"> 通过快捷键切换图形与字符窗口</h4>
<p><code>ctrl+alt+[f1~F6]</code>按这个快捷键可以快速的进入其他窗口进行测试</p>
<h4 id="从gui界面切换字符界面"> 从GUI界面切换字符界面</h4>
<p>在终端内输入：init 3</p>
<h4 id="从字符界面切换到字符界面"> 从字符界面切换到字符界面</h4>
<p>在终端内输入：init 5</p>
<h4 id="init-5和startx的区别"> init 5和startx的区别</h4>
<p>使用<strong>init 5</strong> 切换到运行级别5和使用<strong>startx</strong>登录图形界面看起来差不多，其实差别挺大的。最主要的差别就是语系，你可能发现你设定的环境是中文的，但是startx后系统桌面环境变成英文的了，并且输入法也调不出来了。</p>
<ul>
<li>startx是单纯的以执行命令者的身份启动X图形界面,环境变量是当前身份的。任意用户可以执行。</li>
<li>init 5 切换到运行级别5,则是启动 runlevel 5所对应的服务，并运行图形登录管理器，由用户选择以何种身份登录。该操作是有重新启动系统服务的,需要重新输入用户名和密码登陆。只有root有权执行。</li>
</ul>
<p>可以用chkconfig --list |more 查看在runlevel 5上启动的服务,和用ps -aux查看在startx启动时运行服务信息对比即知.startx只是在原运行级别基础上加载了图形,而init 5除了图形外还有</p>
<h4 id="logout"> logout</h4>
<p>注销推出当前用户窗口</p>
<h4 id="exit"> exit</h4>
<p>注销推出当前用户窗口，和<code>ctrl+d</code>差不多，与windows的<code>ctrl+w</code>类似</p>
<h4 id="shutdown"> shutdown</h4>
<p>shutdown会给系统计划一个时间关机，它可以被用于停止、关机、重启机器，也可以在后面添加参数进行指定关机的操作</p>
<div><pre><code><span>shutdown</span>
<span>shutdown</span> now	 <span>### 立刻关机</span>
<span>shutdown</span> <span>13</span>:20   <span>### 在指定小时/分钟关机，额外地，你也可以设置一个广播信息在系统关闭前发送给所有已登录的用户。</span>
<span>shutdown</span> -p now  <span>### 关闭机器</span>
<span>shutdown</span> -H now  <span>### 停止机器      </span>
<span>shutdown</span> -r09:35 <span>### 在 09:35am 重启机器</span>
<span>shutdown</span> -h now	 <span>### 立刻关机（生产常用）</span>
<span>shutdown</span> -h +1   <span>### 一分钟后关闭</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>如果下取消即将进行的关机，只需要在下面输入</p>
<div><pre><code><span>shutdown</span> -c
</code></pre>
<div><span>1</span><br></div></div><h4 id="halt"> halt</h4>
<p>halt是通知硬件来停止所有CPU功能，但是仍然保持通电。你可以用它使系统处于地层维护状态，但是注意有些情况会让他完全关闭系统</p>
<div><pre><code><span>halt</span>			<span>### 停止机器</span>
<span>halt</span> -p 		<span>### 关闭机器</span>
<span>halt</span> --reboot	<span>### 重启机器</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id="poweroff"> poweroff</h4>
<p>如同名字一般，poweroff会发送一个ACPI习惯好来通知系统关闭</p>
<div><pre><code>poweroff			<span>### 关闭机器</span>
poweroff --halt		<span>### 停止机器</span>
poweroff --reboot	<span>### 重启机器</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id="reboot"> reboot</h4>
<p>这个也和名字一样，通知系统重启</p>
<div><pre><code><span>reboot</span>			<span>### 重启机器</span>
<span>reboot</span> --halt	<span>### 停止机器</span>
rebopt -p		<span>### 关闭机器</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="目录管理与文件管理"> 目录管理与文件管理</h3>
<p>Linux与windows不同，linux是从<code>/</code>根目录开始的，windows是从盘符开始，在Linux中的绝对路径与相对路径的写法是如何呢？下面先吧目录结构打出来</p>
<div><pre><code><span>|</span>-- /					<span># 根目录</span>
<span>|</span>   <span>|</span>--root				<span># 文件夹</span>
<span>|</span>   <span>|</span>  <span>|</span>--a				<span># 文件夹</span>
<span>|</span>   <span>|</span>  <span>|</span>  <span>|</span>--b			<span># 文件夹</span>
<span>|</span>   <span>|</span>  <span>|</span>  <span>|</span>--D			<span># 文件夹</span>
<span>|</span>   <span>|</span>  <span>|</span>  <span>|</span>  <span>|</span>--C		<span># 文本文件</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id="绝对路径"> 绝对路径</h4>
<p>假设当前文件位置为<code>/root/a/d</code>要切换到<code>/root/a/b</code>中，切换路径时使用的绝对路径的命令为：<code>cd /root/a/b</code></p>
<h4 id="相对路径"> 相对路径</h4>
<p>假设当前文件位置为<code>/root/a/b</code>要切换到<code>/root</code>中，切换路径时使用的相对路径的命令为：<code>cd ../../</code></p>
<h4 id="ls"> ls</h4>
<ul>
<li>
<p>简介：列出目录内容，与ls, dir, vdir类似</p>
</li>
<li>
<p>命令：ls [-选项] [文件名...]
记得后面的参数要添加空格</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>ls</td>
<td>直接使用ls命令出来的结果是列出当前目录下的文件与文件夹，其中蓝色的是目录，黑色的是文件</td>
</tr>
<tr>
<td>ls -a</td>
<td>是显示所有文件及目录，包括隐藏文件（隐藏文件一般以<code>“.“</code>点号开头）</td>
</tr>
<tr>
<td>ls -d</td>
<td>是将目录名像其他文件一样列出，而不是列出他们的内容</td>
</tr>
<tr>
<td>ls -l</td>
<td>除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出</td>
</tr>
<tr>
<td>ls -A</td>
<td>-A同-a，但不列出“.”（当前目录）及“。。”（父目录）</td>
</tr>
</tbody>
</table>
</li>
</ul>
<div><pre><code><span># 显示a文件夹内的内容</span>
<span>[</span>root@centos /<span>]</span><span># ls -l a</span>
总用量 <span>4</span>
-r-xr--rw-. <span>1</span> bit  bit    <span>0</span> <span>4</span>月   <span>1</span> <span>21</span>:57 a.txt
drwxr-xr-x. <span>2</span> root root  <span>19</span> <span>4</span>月   <span>1</span> <span>18</span>:16 b
-rw-r--r--. <span>1</span> root root <span>204</span> <span>4</span>月   <span>1</span> <span>21</span>:46 b.txt
drwxr-xr-x. <span>2</span> root root  <span>19</span> <span>4</span>月   <span>1</span> <span>18</span>:16 c
<span># 显示a文件夹</span>
<span>[</span>root@centos /<span>]</span><span># ls -ld a</span>
drwxrwsrwx. <span>4</span> root root <span>50</span> <span>4</span>月   <span>1</span> <span>21</span>:48 a
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h4 id="cd"> cd</h4>
<ul>
<li>切换当前路径</li>
<li>命令：<code>cd [dirName]</code></li>
<li><code>cd ~</code> 跳转到自己的home目录</li>
<li><code>cd ../..</code> 跳转目前目录的上两层</li>
</ul>
<h4 id="pwd"> pwd</h4>
<ul>
<li>显示目前的目录</li>
</ul>
<p><img src="./images/linux_notes/image-20200319174647844.png" alt="image-20200319174647844" /></p>
<h4 id="mkdir"> mkdir</h4>
<ul>
<li>
<p>新加一个文件夹</p>
</li>
<li>
<p><code>mkdir [-p] 文件夹名</code>
在Linux中是区分大小写的所以文件名使用A和a都可以，但是在windows下是不行的</p>
</li>
<li>
<p><code>mkdir -p</code> 确保目录名称存在，不存在就建一个</p>
<p><code>mkdir -p a/aa/aaa/aaaa</code>使用这个方式可以一次新建多个文件夹目录</p>
</li>
</ul>
<h4 id="rmdir"> rmdir</h4>
<ul>
<li>删除一个空的目录，若文件夹非空则无法删除</li>
<li>rmdir [-p] 文件名</li>
<li><code>rmdir -p</code>当子目录被删除后使它也成为空目录的话，则一并删除
<ul>
<li>加入在文件夹B里面有个文件C，如果命令为<code>rmdir -p B/C</code>则此时B和C都会被删除</li>
</ul>
</li>
</ul>
<h4 id="cp"> cp</h4>
<ul>
<li>复制文件或文件夹</li>
<li><code>cp [参数] 源文件 目的地址</code>
或
多个文件<code>cp [参数] 源文件... 目的地址</code></li>
<li>copy复制文件，从哪到哪，建议使用tab键自动补齐
<ul>
<li>假如由文件夹b与d，文件夹b里面有一个文件c，此时在b里面使用<code>cp c ../d</code>则可以复制文件到d里</li>
</ul>
</li>
<li><code>cp /etc/*.conf /home/a</code>一键复制目录下多个后缀的文件到指定目录<code>/home/a</code>
<code>cp /etc/a*.conf ../../a</code>将以a开头的conf文件复制到上两层的a文件夹中</li>
</ul>
<h4 id="rm"> rm</h4>
<ul>
<li>
<p>删除文件或目录</p>
</li>
<li>
<p><code>rm [参数] 文件名|文件夹</code></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>-i</td>
<td>删除前逐一询问确认</td>
</tr>
<tr>
<td>-f</td>
<td>即使原档案属性设为唯读，亦直接删除，无需逐一确定</td>
</tr>
<tr>
<td>-r</td>
<td>将目录及以下之档案亦逐一删除</td>
</tr>
</tbody>
</table>
<ul>
<li>删除文件夹</li>
</ul>
<p><img src="./images/linux_notes/image-20200318211626885.png" alt="image-20200318211626885" /></p>
<h4 id="mv"> mv</h4>
<ul>
<li>移动（改名）文件</li>
<li>命令：mv [S源文件] [替换的名字 | D目的文件夹]</li>
<li>改名：将文件d改为dddd
<ul>
<li><code>mv d dddd</code></li>
</ul>
</li>
<li>移动：将文件d移动到上一层的文件夹a里
<ul>
<li><code>mv d ../a</code></li>
</ul>
</li>
</ul>
<h4 id="cat"> cat</h4>
<ul>
<li>
<p>连接文件并在标准输出上输出，cat可以创建或者预览文件</p>
</li>
<li>
<p>命令：cat [option] [文件名]</p>
</li>
<li>
<p>[option]</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>-b</td>
<td>对非空输出行编号</td>
</tr>
<tr>
<td>-E</td>
<td>在每行结束处显示“$”</td>
</tr>
<tr>
<td>-n</td>
<td>输出所有行的编号</td>
</tr>
<tr>
<td>-s</td>
<td>不输出多行空行</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>如果当前目录中没有所输入的这个文件则会自动创建一个
<img src="./images/linux_notes/image-20200318212610327.png" alt="image-20200318212610327" /></p>
</li>
<li>
<p><code>cat &gt; filename</code> 将下面内容输出到filename这个文件，跳到下一行再按ctrl+c可退出
<img src="./images/linux_notes/image-20200317230433141.png" alt="image-20200317230433141" /></p>
</li>
<li>
<p><code>cat filename1 filename2 &gt; filename3</code> 将filename1和filename2的内容输出到filename3中
<img src="./images/linux_notes//image-20200317230002331.png" alt="image-20200317230002331" /></p>
</li>
<li>
<p><code>cat filename1 &gt;&gt; filename2</code>将file1的文件内容<code>附加</code>到file2的文件后面，而file2的内容孩子
<img src="./images/linux_notes/image-20200318212707066.png" alt="image-20200318212707066" /></p>
</li>
<li>
<p>-E 在每行的结束处输出一个”$”</p>
<p><img src="./images/linux_notes/clip_image001-1584536051515.png" alt="img" /></p>
</li>
<li>
<p>-n 输出所有行的编号</p>
<p><img src="./images/linux_notes/clip_image001-1584536065024.png" alt="img" /></p>
</li>
</ul>
<h4 id="重定向-与"> 重定向&gt;与&gt;&gt;</h4>
<h5 id=""> &gt;</h5>
<p>我们将文件ab打印到终端上，如何使用<code>cat &gt;</code>命令进行覆写，在后面写完之后按<code>ctrl+c</code>就可以看到后面输出了之前我们输入的内容</p>
<p><img src="./images/linux_notes/clip_image001.png" alt="img" /></p>
<h5 id="-2"> &gt;&gt;</h5>
<p>接着上面的内容我们将ab这个文件的后面追加一些文字，追加的内容是从最后的下一行开始添加</p>
<p><img src="./images/linux_notes/clip_image001-1584535938608.png" alt="img" /></p>
<h4 id="tac"> tac</h4>
<p>从最后一行开始现实，可以看到tac是cat的倒写</p>
<p><img src="./images/linux_notes/image-20200318210549379.png" alt="image-20200318210549379" /></p>
<h4 id="touch"> touch</h4>
<ul>
<li>touch可以创建一个空文件，也可以更改文件的时间</li>
<li>命令：touch [文件名] -[参数]
<ul>
<li>-t [[ CC] YY] MMDDhhmm[ .ss]</li>
</ul>
</li>
<li>touch wenjianjia</li>
<li>touch wenjianjia -t 03171637
更改时间为<code>三月17日16:37</code></li>
<li><img src="./images/linux_notes/image-20200318210029109.png" alt="image-20200318210029109" /></li>
</ul>
<h4 id="nl"> nl</h4>
<p>显示的时候，顺便输出行号</p>
<h4 id="more"> more</h4>
<p>一页一页的显示文件内容，但是不能往前翻</p>
<p><img src="./images/linux_notes/clip_image002.jpg" alt="img" /></p>
<p><img src="./images/linux_notes/clip_image002-1584537019393.jpg" alt="img" /></p>
<h4 id="less"> less</h4>
<p>与more类似，但是比more更好的是它可以往前翻页</p>
<ul>
<li>输入了less之后可以用滚轮滑动查看，按q可推出</li>
<li><img src="./images/linux_notes/clip_image001-1584537124417.png" alt="img" />
<img src="./images/linux_notes/clip_image002-1584537128784.jpg" alt="img" /></li>
</ul>
<h4 id="head"> head</h4>
<p>只看开头几行</p>
<p><img src="./images/linux_notes/image-20200318211258599.png" alt="image-20200318211258599" /></p>
<h4 id="tail"> tail</h4>
<p>只看返回结尾的几行</p>
<p><img src="./images/linux_notes/image-20200318211352848.png" alt="image-20200318211352848" /></p>
<ul>
<li>tail -num filename
tail-1 filename 则显示filename的最后一行，-2则显示左后两行</li>
</ul>
<h4 id="grep"> grep</h4>
<ul>
<li>打印匹配给定模式的行</li>
<li>命令：cat [文件名] | grep [正则表达式]</li>
</ul>
<h4 id="小技巧"> 小技巧</h4>
<p>在复制移动重命名都可以使用绝对路径和相对路径</p>
<p>一次新建多个文件夹<code>mkdir -p a/aa/aaa/aaaa</code></p>
<p>一次复制目录下多个后缀文件<code>cp /etc/*.conf /home/a</code>
<code>你也可以复制目录下以a开头的.conf文件：cp /etc/a*.conf /home/a</code></p>
<p>重命名 <code>mv anaconda- ff.txt aa.txt</code></p>
<p>重定向，不将其输出至屏幕，而是输出到指定的文件内</p>
<p>例如将<code>ls -l</code>的输出结果输出到指定的文件内<code>ls -l aa.txt</code></p>
<h3 id="压缩与归档"> 压缩与归档</h3>
<h3 id="压缩"> 压缩</h3>
<p>前三个都会将单独的文件压缩，会将原来的文件给删除</p>
<h4 id="gzip"> gzip</h4>
<ul>
<li>压缩每个单独文件，并将源文件删除，后缀为gz</li>
</ul>
<p>命令：</p>
<p><code>gzip [name]</code> 压缩name这个文件
注意在压缩的时候
gzip *.conf`</p>
<p><img src="./images/linux_notes/image-20200319104459777.png" alt="image-20200319104459777" /></p>
<p><code>gunzip name.gz</code>解压name.gz这个文件</p>
<p><img src="./images/linux_notes/image-20200319104523324.png" alt="image-20200319104523324" /></p>
<h4 id="bzip2"> bzip2</h4>
<ul>
<li>压缩每个单独文件，并将源文件删除，后缀为bz2</li>
</ul>
<p><code>bzip2 name</code>压缩name这个文件</p>
<p><code>bunzip2 name.bz2</code> 解压name.bz2这个文件</p>
<p><img src="./images/linux_notes/image-20200319175609862.png" alt="image-20200319175609862" /></p>
<h4 id="xz"> xz</h4>
<p>压缩每个单独文件，并将源文件删除，后缀为xz</p>
<ul>
<li><code>xz a.txt</code>压缩a.txt这个文件</li>
<li><code>unxz a.txt.xz</code>解压a.txt这个文件</li>
</ul>
<p><img src="./images/linux_notes/image-20200319161026726.png" alt="image-20200319161026726" /></p>
<h4 id="注意上下不同-上面为每个单独压缩-下面为每个压缩成单个文件"> 注意上下不同，上面为每个单独压缩，下面为每个压缩成单个文件</h4>
<h4 id="zip"> zip</h4>
<ul>
<li>压缩多个文件成单独的一个文件，后缀为zip</li>
</ul>
<p><code>zip name.zip a*.conf</code> 压缩文件名为name.zip，压缩所有a开头的conf文件</p>
<ul>
<li><code>zip name.zip a.conf b.txt</code>单独选取多个文件</li>
</ul>
<p><img src="./images/linux_notes/image-20200319180158660.png" alt="image-20200319180158660" /></p>
<ul>
<li><code>unzip new.zip</code>将new.zip解压缩，若有重复则会询问是否覆盖</li>
</ul>
<p><img src="./images/linux_notes/image-20200319180244086.png" alt="image-20200319180244086" /></p>
<h2 id="归档"> 归档</h2>
<p>归档只负责吧多个文件归类串联起来，本身不负责压缩，不过你可以添加参数进行归档与压缩成指定格式的压缩文件</p>
<h3 id="tar"> tar</h3>
<p>将文件归档</p>
<h4 id="tar命令选项说明"> tar命令选项说明：</h4>
<ul>
<li>
<p>-c ：建立一个压缩文件的参数指令(create 的意思)；</p>
<p>归档组合使用，压缩归档文件会使用到这个</p>
</li>
<li>
<p>-x ：解开一个压缩文件的参数指令！</p>
<p>解压组合使用，解压归档文件会使用到这个</p>
</li>
<li>
<p>-t ：查看 tarfile 里面的文件！</p>
<ul>
<li>特别注意，在参数的下达中， c/x/t 仅能存在一个！不可同时存在！因为不可能同时压缩与解压缩。</li>
</ul>
</li>
<li>
<p>-z ：是否同时具有 gzip 的属性？亦即是否需要用 gzip 压缩？</p>
</li>
<li>
<p>-j ：是否同时具有 bzip2 的属性？亦即是否需要用 bzip2 压缩？</p>
</li>
<li>
<p>-v ：压缩的过程中显示文件！这个常用，但不建议用在背景执行过程！</p>
</li>
<li>
<p>-f ：文件名，请留意，在 f 之后要立即接文件名！不要再加参数！</p>
</li>
<li>
<p>-j 用 bzip2 压缩或解压</p>
</li>
</ul>
<h3 id="压缩-2"> 压缩</h3>
<h4 id="tar-2"> tar</h4>
<p><code>tar -cvf new.tar a.*</code>
c：建立一个压缩文件的参数指令
v：显示过程
f：文件名为new.tar
<img src="./images/linux_notes/image-20200319105640331.png" alt="image-20200319105640331" /></p>
<h4 id="gz"> gz</h4>
<p><code>tar -czf a.tar.gz ./</code>
c：建立一个压缩文件的参数指令
z：生成一个gzip压缩过的包
f：文件名为new.tar<img src="./images/linux_notes/image-20200319191000664.png" alt="image-20200319191000664" /></p>
<h4 id="bz2"> bz2</h4>
<p><code>tar -cjf a.tar.bz2 ./</code>
c：建立一个压缩文件的参数指令
j：生成一个bzip2压缩过的包
f：文件名为new.tar
<img src="./images/linux_notes/image-20200319191550179.png" alt="image-20200319191550179" /></p>
<h3 id="解压"> 解压</h3>
<h4 id="tar-3"> tar</h4>
<p><code>tar -xvf new.tar a.*</code>
x：解开一个压缩文件的参数指令
v：显示过程
f：文件名为new.tar
<img src="./images/linux_notes/image-20200319192737499.png" alt="image-20200319192737499" /></p>
<h4 id="gz-2"> gz</h4>
<p><code>tar -xzvf a.tar.gz ./</code>
x：解开一个压缩文件的参数指令
z：解开一个gzip压缩过的包
v：显示过程
f：文件名为new.tar
<img src="./images/linux_notes/image-20200319192217957.png" alt="image-20200319192217957" /></p>
<h4 id="bz2-2"> bz2</h4>
<p><code>tar -xjvf a.tar.bz2 ./</code>
x：解开一个压缩文件的参数指令
j：解开一个bzip2压缩过的包
v：显示过程
f：文件名为new.tar
<img src="./images/linux_notes/image-20200319192039940.png" alt="image-20200319192039940" /></p>
<h3 id="其他-2"> 其他</h3>
<h4 id="switch"> switch</h4>
<h1 id="编辑器"> 编辑器</h1>
<h2 id="常用的文本编辑器"> 常用的文本编辑器</h2>
<ul>
<li>Vi（Vim）</li>
<li>nano</li>
<li>emacs</li>
<li>gedit</li>
</ul>
<h2 id="vi-建议"> VI（建议）</h2>
<p>vim是vi的升级版，目前大多都是使用VIM，</p>
<ul>
<li>Vim是彩色的，Vi是黑白的</li>
<li>Vi每个系统都会有，但是Vim不一定有，Vi与Vim是不同的！</li>
</ul>
<p>直接输入vi就可以开始编辑新的文件</p>
<h3 id="三种模式"> 三种模式</h3>
<ul>
<li>普通模式</li>
<li>插入模式</li>
<li>命令模式</li>
</ul>
<h4 id="普通模式-查看模式、normal模式"> 普通模式（查看模式、normal模式）</h4>
<ul>
<li><code>vi [filename]</code> 如果当前路径存在则查看，不存在则新建查看的状态(read)</li>
<li>esc键可以进入查看模式</li>
</ul>
<h5 id="基本操作"> 基本操作</h5>
<ul>
<li><code>G</code> 用于直接跳转到文件末尾</li>
<li><code>gg</code> 用于直接跳转到文件头</li>
<li><code>x</code>删除光标所在的字符 （单独）</li>
<li><code>r</code>替换光标所在的字符（单独）</li>
<li><code>~</code>切换光标所在字母的大小写（单独）</li>
<li><code>u</code>取消上一次编辑操作（undo）</li>
<li><code>.</code>重复上一步编辑操作（redo）</li>
<li><code>ZZ</code>用于存盘推出Vi</li>
<li>ZQ用于不存盘推出Vi</li>
</ul>
<h4 id="插入模式-编辑模式"> 插入模式（编辑模式）</h4>
<ul>
<li>i (insert)插入状态</li>
<li>a 追加模式</li>
</ul>
<h4 id="命令模式"> 命令模式</h4>
<p>在下面有独立一行用作输入命令</p>
<h5 id="基本命令"> 基本命令</h5>
<ul>
<li><code>:w</code>保存</li>
<li><code>:w newfile</code>存为另一个名为newfile的文件</li>
<li><code>:wq</code>保存并退出Vi</li>
<li><code>:q</code>用于直接退出Vi（仅限未作修改的时候推出）</li>
<li><code>q!</code>不保存并退出Vi（强制退出）</li>
<li><code>:set number</code> 显示行号</li>
<li><code>:set nonumber</code>不显示行号</li>
<li><code>:set autoindent</code>缩进，常用于程序的编写</li>
<li><code>:set noautoindent</code>取消缩进</li>
<li><code>:set tabstop=num</code>设置显示制表符的空格字符个数</li>
<li><code>:set</code>显示设置的所有选项</li>
<li><code>:set all</code> 显示所有可以设置的选项</li>
</ul>
<p><img src="./images/linux_notes/image-20200325003828721.png" alt="image-20200325003828721" /></p>
<h2 id="nano-不建议"> Nano（不建议）</h2>
<ul>
<li>有的系统有有的没有</li>
<li>命令行</li>
</ul>
<h2 id="emacs-不建议"> emacs（不建议）</h2>
<ul>
<li>有的系统有有的没有</li>
<li>命令行</li>
</ul>
<h2 id="gedit-不建议"> gedit（不建议）</h2>
<ul>
<li>有图形界面的文本编辑器，类似于windows下的记事本</li>
<li>有的系统有有的没有</li>
</ul>
<h1 id="linux的远程管理"> Linux的远程管理</h1>
<h2 id="命令行界面"> 命令行界面</h2>
<h3 id="ssh"> SSH</h3>
<p>ssh （secure shell），linux默认安装并打开的服务
ststemctl status sshd(查看系统sshd状态)
SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。</p>
<ul>
<li>服务端openssh</li>
<li>客户端putty或xshell</li>
</ul>
<p>默认已经安装了openssh-server服务，并启动</p>
<p>如何使用密钥免密连接Linux系统？</p>
<ol>
<li>
<p>用puttygen或xshell产生一对密钥</p>
<p>公钥、密钥</p>
<p>公钥：传到linux服务器上
私钥：自己保存</p>
</li>
<li>
<p>将公钥传输到linux系统用户的家目录ssh/下.文件名称为authorized_key
如何传文件到linux？可以用sftp</p>
</li>
<li>
<p>在客户端工具中设置用密钥进行身份验证</p>
</li>
</ol>
<h2 id="图形界面-2"> 图形界面</h2>
<ol>
<li>
<p>VNC（tigervnc[服务端]、vnc客户端）</p>
<p>VNC (Virtual Network Console/compute )是虚拟网络控制台（虚拟网络计算）的缩写。它是一款优秀的远程控制工具软件，由著名的 AT&amp;T 的欧洲研究实验室开发的。VNC 是在基于 UNIX 和 Linux 操作系统的免费的开源软件，远程控制能力强大，高效实用，其性能可以和 Windows 和 MAC 中的任何远程控制软件媲美。 在 Linux 中，VNC 包括以下四个命令：vncserver，vncviewer，vncpasswd，和 vncconnect。大多数情况下用户只需要其中的两个命令：vncserver 和 vncviewer。
条件：linux系统应安装图像界面
vnc虚拟网络控制台
VNC服务
VNC客户端
默认已安装但是没有配置</p>
</li>
<li>
<p>WEB网站的安装
webmin（推荐了解）
redhat8系统自带cockpit</p>
</li>
</ol>
<h2 id="使用密钥进行身份验证"> 使用密钥进行身份验证</h2>
<p>参考：https://www.cnblogs.com/dudumao/p/7456208.html</p>
<ul>
<li>
<p>使用xshell生成公钥，点击<code>工具&gt;新建用户密钥生成向导</code></p>
</li>
<li>
<p>生产密钥参数默认即可，然后点击下一步进行生成公钥对，生成好了点击下一步</p>
</li>
<li>
<p>到了用户密钥信息，密钥名称可改或不改，但是不能和已有的重复，密码可以留空，不过建议还是填写，填好了就下一步（记得别按完成）</p>
</li>
<li>
<p>到了公钥注册这一步就需要将公钥保存为文件通过ftp传输到linux上</p>
</li>
<li>
<p>接下来转到linux上操作：</p>
<ul>
<li>
<p>这里我们默认新建一个新用户bit</p>
<div><pre><code><span>[</span>root@centos<span>]</span><span># useradd bit</span>
<span>[</span>root@centos<span>]</span><span># passwd bit</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>进入管理员模式并在bit用户文件夹内操作文件并将公钥写入一个文件中</p>
<div><pre><code><span>[</span>root@centos<span>]</span><span># su bit</span>
<span>[</span>root@centos<span>]</span>$ <span>mkdir</span> .ssh
<span>[</span>root@centos<span>]</span>$ <span>chmod</span> <span>700</span> .ssh/
<span>[</span>root@centos<span>]</span>$ <span>cd</span> .ssh/
<span>[</span>root@centos<span>]</span>$ <span>cat</span> id_rsa_1024.pub <span>></span> authorized_keys
<span>[</span>root@centos<span>]</span>$ <span>chmod</span> <span>600</span> authorized_keys
<span>[</span>root@centos<span>]</span>$ <span>su</span> -
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
<li>
<p>用vim修改ssh部分参数，并重启ssh服务</p>
<div><pre><code><span>[</span>root@centos<span>]</span><span># vim /etc/ssh/sshd_config</span>
<span># 以下是修改的内容</span>
PasswordAuthentication no
PubkeyAuthentication <span>yes</span>
AuthorizedKeysFile  .ssh/authorized_keys
<span># 以上是修改的内容</span>
<span>[</span>root@centos<span>]</span><span># service sshd resetart</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
<li>
<p>接下来在xshell中将连接的<code>属性&gt;用户省份验证&gt;方法</code>改为<code>Public key</code>用户名改为上面写的bit，选择刚刚新建的用户密钥并输入上面输入的密码</p>
</li>
</ul>
</li>
</ul>
<p>​</p>
<h2 id="使用vnc进行图形界面连接"> 使用VNC进行图形界面连接</h2>
<p>参考：https://jingyan.baidu.com/article/eb9f7b6d5ff296869264e858.html</p>
<h3 id="安装vnc"> 安装VNC</h3>
<p><code>yum install vnc-server -y</code></p>
<h3 id="配置vnc"> 配置VNC</h3>
<ul>
<li>
<p><code>vncserver</code> 安装完毕后输入“vncserver”启动VNC设置密码，注意：启动后将自动在user/.vnc目录下创建xstartup文件
<img src="./images/linux_notes/image-20200703120931631.png" alt="image-20200703120931631" /></p>
</li>
<li>
<p><code>vim /root/.vnc/xstartup</code>在最后面添加下面内容后按<code>esc</code>后输入<code>:wq</code>保存并退出</p>
<div><pre><code>VNCSERVERS=&quot;Z:root&quot;
VNCSERVERARGS[2]=&quot;-GEMETRY 800x600 -nolisten tcp -localhost&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p><code>vncpasswd</code>回车键确定，开始输入VNC访问密码并按回车键确定</p>
</li>
<li>
<p><code>netstat -tlup | grep vnc</code>输入查看VNC使用端口
<img src="./images/linux_notes/image-20200703121459957.png" alt="image-20200703121459957" /></p>
<ul>
<li>
<p>注意：VNC访问默认监听如下3个TCP端口：</p>
<ul>
<li>RFB(Remote FrameBuffer)协议 默认端口 :5900+显示器号</li>
<li>HTTP协议默认端口: 5800+显示器号</li>
<li>X协议 默认端口 :6000+显示器号</li>
</ul>
</li>
<li>
<p><code>iptables -I INPUT -p tcp --dport 5901 -j ACCEPT</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="测试"> 测试</h3>
<ul>
<li>在vnc中输入<code>IP:1</code>即可连接</li>
<li>1对应5901端口，以此类推9对应5909端口，如超过100则需使用完整端口号</li>
</ul>
<h2 id="使用putty将inux文件传输下载"> 使用putty将inux文件传输下载</h2>
<div><pre><code># cd 到putty的目录下
PSFTP.exe
# 连接linux的ip
open 192.168.3.121
# 遇到store key in cache?(y/n) 输入y就好
# 输入用户名和密码
# 上传文件
put filename.txt
# 下载文件
get filename.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h1 id="linux用户管理"> Linux用户管理</h1>
<p>Linux是一个多用户多任务系统，用户可以分为三类</p>
<ul>
<li>超级用户
<ul>
<li>最大的权限</li>
<li>root根用户</li>
</ul>
</li>
<li>系统用户
<ul>
<li>系统用户是仅限于系统使用的，他不可以超出它(FTP)的范围，你也可以把它理解为一个服务系统用户</li>
<li>主要是为了满足相应的系统进程对文件属主</li>
<li>他不能登录，例如FTP、bin、adm、ip</li>
</ul>
</li>
<li>普通用户（可以登录系统中进行相关操作）</li>
</ul>
<h2 id="用户管理"> 用户管理</h2>
<p>用户主要通过<code>/etc/passwd</code>和<code>/etc/shadow</code>这两个文件保存</p>
<div><pre><code><span>cd</span> /etc/
<span>less</span> <span>passwd</span> <span># 查看用户详细情况</span>
<span>less</span> shadow <span># 查看用户密码与过期时间（已加密）</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>打开<code>/etc/passwd</code>文件里面都是一行一个账户，每一行以冒号分隔开：
<ul>
<li><code>用户名：X(密码)：Uid(i组ID)：用户的全名：用户的主目录：用的哪一个shell</code>
普通用户的ID号从1000开始，根用户和系统用户是0</li>
<li>密码为X是因为
以前的密码默认都是保存在<code>/etc/passwd</code>这个文件，后来改进将这个密码更换到<code>/etc/shadow</code>中，上面那个X算是一个占位，只有系统能读取这个文件，其他都不能读取，里面的密码都是经过sha512加密过的文件</li>
</ul>
</li>
<li><code>/etc/shadow</code>文件里面都是保存是账户的密码与其他配置也是用冒号分隔开
<ul>
<li><code>用户名：加密过的密码：密码的相关参数（更改时间与过期时间等）</code></li>
</ul>
</li>
</ul>
<h2 id="用户的添加删除"> 用户的添加删除</h2>
<h3 id="useradd"> useradd</h3>
<ul>
<li>添加用户</li>
<li><code>useradd username</code>不能输入已存在的usernam</li>
<li>用户虽然已经添加了但是还没设置密码所以不能登录，在<code>/etc/shawod</code>文件里密码会显示为<code>!</code>，表示不能登录</li>
</ul>
<h3 id="passwd"> passwd</h3>
<ul>
<li>设置用户密码</li>
<li><code>passwd username</code>回车即可开始设置密码，简单的密码会被提醒</li>
</ul>
<h3 id="usermod"> usermod</h3>
<ul>
<li>
<p>修改指定用户的各项设置</p>
</li>
<li>
<p><code>usermod [-LU][-c &lt;备注&gt;][-d &lt;登入目录&gt;][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-l &lt;帐号名称&gt;][-s &lt;shell&gt;][-u &lt;uid&gt;][用户帐号]</code></p>
</li>
<li>
<p>参数：</p>
<ul>
<li><code>-c &lt;备注&gt;</code> 　修改用户帐号的备注文字。</li>
<li><code>-d &lt;登入目录&gt;</code> 　修改用户登入时的目录。</li>
<li><code>-e &lt;有效期限&gt;</code> 　修改帐号的有效期限。</li>
<li><code>-f &lt;缓冲天数&gt;</code> 　修改在密码过期后多少天即关闭该帐号。</li>
<li><code>-g &lt;群组&gt;</code> 　修改用户所属的群组。</li>
<li><code>-G &lt;群组&gt;</code> 　修改用户所属的附加群组。</li>
<li><code>-l &lt;帐号名称&gt;</code> 　修改用户帐号名称。
<ul>
<li>若用户中有进程正在使用则需要kill掉指定进程后才能更改用户名</li>
</ul>
</li>
<li><code>-L</code> 　锁定用户密码，使密码无效。</li>
<li><code>-s &lt;shell&gt;</code> 　修改用户登入后所使用的shell。</li>
<li><code>-u &lt;uid&gt;</code> 　修改用户ID。</li>
<li><code>-U</code> 　解除密码锁定。</li>
</ul>
</li>
<li>
<p>例如：</p>
<ul>
<li>
<p>更改用户的名字</p>
<div><pre><code><span>usermod</span> -l newusername oldusername
</code></pre>
<div><span>1</span><br></div></div></li>
</ul>
</li>
</ul>
<h3 id="userdel"> userdel</h3>
<ul>
<li>删除用户username</li>
<li><code>userdel username</code>注意这种方法不会讲home目录下的档案删除</li>
<li>参数
<ul>
<li><code>userdel -r username</code>彻底删除用户（包括home目录下的档案）</li>
</ul>
</li>
</ul>
<h2 id="组管理"> 组管理</h2>
<ul>
<li>每个用户都可以属于很多组，其中有一个组是用户的主要组</li>
<li>在创建用户的时候默认会创建一个用户的主要组</li>
<li>在linux中组是可以设置密码的</li>
</ul>
<div><pre><code><span>cd</span> /etc/
<span>less</span> group <span># 查看组详细情况</span>
<span>less</span> gshadow <span># 查看组的密码（已加密）</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li><code>/etc/group</code>中也是以冒号等隔开
<ul>
<li><code>组的名称：组的密码：组的ID号：组所有的用户</code></li>
</ul>
</li>
<li><code>/tec/gshadow</code>中也是以冒号等隔开
<ul>
<li><code>组队名称：组的名称：组的密码：组的管理员</code></li>
</ul>
</li>
</ul>
<p>在组管理中-g与-G不同</p>
<h3 id="groupadd"> groupadd</h3>
<ul>
<li>添加组</li>
<li><code>groupadd groupname</code></li>
</ul>
<h3 id="gpasswd"> gpasswd</h3>
<ul>
<li>修改组密码</li>
<li><code>gpasswd groupname</code>
<ul>
<li>回车即可开始设置，当其他用户需要加入组的时候就可以通过这个密码加入</li>
</ul>
</li>
</ul>
<h3 id="groupmod"> groupmod</h3>
<ul>
<li>更改群组识别码或名称</li>
<li><code>groupmod [-g &lt;群组识别码&gt; &lt;-o&gt;][-n &lt;新群组名称&gt;][群组名称]</code></li>
<li>参数
<ul>
<li>-g &lt;群组识别码&gt; 　设置欲使用的群组识别码。</li>
<li>-o 　重复使用群组识别码。</li>
<li>-n &lt;新群组名称&gt; 　设置欲使用的群组名称。</li>
</ul>
</li>
</ul>
<h3 id="groupdel"> groupdel</h3>
<ul>
<li>删除组</li>
<li><code>groupdel groupname</code></li>
</ul>
<h2 id="用户和组状态命令"> 用户和组状态命令</h2>
<h3 id="查看组的用户"> 查看组的用户</h3>
<ul>
<li><code>less group</code></li>
<li><code>tail group</code></li>
</ul>
<h3 id="whoami"> whoami</h3>
<ul>
<li>查看当前用户名称</li>
<li><code>whoami</code>
<ul>
<li>回车就会返回当前用户的名字</li>
</ul>
</li>
</ul>
<h3 id="groups"> groups</h3>
<ul>
<li>查看用户属于那个组</li>
<li><code>groups username</code>
<ul>
<li>回车就会返回<code>指定username的所在组：username</code></li>
</ul>
</li>
</ul>
<h3 id="id"> id</h3>
<ul>
<li>用于显示用户的ID以及所属群组的ID</li>
<li><code>id [-gGnru][--help][--version][用户名称]</code>
<ul>
<li><code>id</code>返回当前用户的详细信息</li>
<li><code>id username</code>返回username用户的信息（不同权限可显示的内容不同</li>
<li>-g或--group 　显示用户所属群组的ID。</li>
<li>-G或--groups 　显示用户所属附加群组的ID。</li>
<li>-n或--name 　显示用户，所属群组或附加群组的名称。</li>
<li>-r或--real 　显示实际ID。</li>
<li>-u或--user 　显示用户ID。</li>
<li>-help 　显示帮助。</li>
<li>-version 　显示版本信息。</li>
</ul>
</li>
</ul>
<h3 id="newgrp"> newgrp</h3>
<ul>
<li>
<p>临时加入到指定组</p>
</li>
<li>
<p><code>newgrp groupname</code></p>
</li>
<li>
<p>linux中的newgrp命令主要是将当前登录用户临时加入到已有的组中，用法如下：<code>newgrp groupname</code></p>
<ul>
<li>
<p>上面命令的含义是将用户yan加入到现有的组grptest中，注意输入命令后需要设置对应的组密码，所以需要先设置<code>gpasswd groupname</code></p>
</li>
<li>
<p>验证方法</p>
</li>
</ul>
<div><pre><code> <span>[</span>yan@localhost etc<span>]</span>$ newgrp grptest
 Password:
 <span>[</span>yan@localhost etc<span>]</span>$ <span>groups</span>
 grptest yan
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
</ul>
<h2 id="切换用户"> 切换用户</h2>
<h3 id="su"> su</h3>
<ul>
<li>切换用户</li>
<li><code>su</code>若后面不输入其他参数则默认进入root根用户</li>
<li><code>su -</code>带入环境变量</li>
</ul>
<p><img src="./images/linux_notes/image-20200331150609731.png" alt="image-20200331150609731" /></p>
<p>可以看到<code>su</code>是直接在当前环境下切换root根用户，而<code>su -</code>则是切换用户并切换环境到root的环境变量中</p>
<h1 id="文件的管理"> 文件的管理</h1>
<p><img src="./images/linux_notes/image-20200401175702270.png" alt="image-20200401175702270" /></p>
<h3 id="read-读权限"> read 读权限</h3>
<ol>
<li>
<p>对于文件而言，就是查看里面的内容</p>
<p>cat、vim、less、more等</p>
</li>
<li>
<p>对目录而言，就是查看目录里的内容</p>
<p>ls等</p>
</li>
</ol>
<h3 id="write-写权限"> write 写权限</h3>
<ol>
<li>
<p>对文件而言，就是修改里面的内容</p>
<p>vi、vim等</p>
</li>
<li>
<p>对目录而言，就是创建、删除、重命名、移动</p>
<p>mkdir、touch、rm、vm、cp</p>
</li>
</ol>
<h3 id="execute-可执行权限"> execute 可执行权限</h3>
<ol>
<li>
<p>对文件而言，就是执行这个文件里的命令</p>
<p>执行脚本文件或可执行文件</p>
</li>
<li>
<p>对目录而言，就是进入目录可以使用cd命令进入</p>
</li>
</ol>
<h3 id="文件权限表示"> 文件权限表示</h3>
<ul>
<li>d 文件夹</li>
<li>后面代表其他人对这个文件夹的权限，没有权限就是<code>---</code>横线</li>
<li>rwx 读取、写入、执行（用户的权限）</li>
<li>r-x 所属组的权限</li>
<li>r-x 其他人的权限</li>
<li>num 文件数</li>
<li>用户</li>
<li>群组</li>
<li>大小</li>
<li>日期</li>
<li>文件/文件夹名</li>
</ul>
<div><pre><code><span>[</span>root@centos ~<span>]</span><span># ls -l</span>
总用量 <span>8</span>
-rw-------. <span>1</span> root root <span>1627</span> <span>3</span>月  <span>12</span> <span>12</span>:25 anaconda-ks.cfg
-rw-r--r--. <span>1</span> root root <span>1655</span> <span>3</span>月  <span>12</span> <span>12</span>:54 initial-setup-ks.cfg
drwxr-xr-x. <span>2</span> root root    <span>6</span> <span>3</span>月  <span>12</span> <span>12</span>:56 公共
drwxr-xr-x. <span>2</span> root root    <span>6</span> <span>3</span>月  <span>12</span> <span>12</span>:56 模板
drwxr-xr-x. <span>2</span> root root    <span>6</span> <span>3</span>月  <span>12</span> <span>12</span>:56 视频
drwxr-xr-x. <span>2</span> root root    <span>6</span> <span>3</span>月  <span>12</span> <span>12</span>:56 图片
drwxr-xr-x. <span>2</span> root root    <span>6</span> <span>3</span>月  <span>12</span> <span>12</span>:56 文档
drwxr-xr-x. <span>2</span> root root    <span>6</span> <span>3</span>月  <span>12</span> <span>12</span>:56 下载
drwxr-xr-x. <span>2</span> root root    <span>6</span> <span>3</span>月  <span>12</span> <span>12</span>:56 音乐
drwxr-xr-x. <span>2</span> root root    <span>6</span> <span>3</span>月  <span>12</span> <span>12</span>:56 桌面
<span># 另一个用户</span>
<span>[</span>bit@centos home<span>]</span>$ <span>ls</span> -l
总用量 <span>4</span>
drwx------. <span>15</span> bit  bit   <span>4096</span> <span>3</span>月  <span>31</span> <span>16</span>:09 bit
drwx------.  <span>3</span> <span>test</span> <span>test</span>    <span>78</span> <span>3</span>月  <span>31</span> <span>15</span>:45 <span>test</span>
drwx------.  <span>5</span> <span>1002</span> test1  <span>128</span> <span>3</span>月  <span>31</span> <span>15</span>:48 test1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id="改变文件或目录存取权限的命令"> 改变文件或目录存取权限的命令</h2>
<h3 id="需要记住的参数缩写"> 需要记住的参数缩写</h3>
<ul>
<li>u user</li>
<li>g group</li>
<li>o other</li>
<li>a all</li>
<li>r read</li>
<li>w write</li>
<li>x excute</li>
<li><code>+</code> 增加权限</li>
<li><code>-</code>减去权限</li>
<li>= 直接等于某些权限</li>
<li>-R 递归修改指定目录下所有文件、子目录的权限</li>
</ul>
<h3 id="chgrp"> chgrp</h3>
<p>更改群组</p>
<p><code>chgrp groupname filename</code>将filename的组权限改为groupname</p>
<h3 id="chown"> chown</h3>
<p>更改所有者，修改属主或属组，只能在root用户执行</p>
<p><code>chown username filename</code>将filename的用户权限改为username</p>
<p><code>chown :groupname filename</code>将filename的群组权限改为groupname</p>
<h3 id="chmod"> chmod</h3>
<p>更改权限标记</p>
<p><img src="./images/linux_notes/image-20200401180400472.png" alt="image-20200401180400472" /></p>
<h4 id="例子"> 例子</h4>
<ul>
<li><code>chmod o+w filename</code> 对filename允许其他用户添加写功能</li>
<li><code>chmod u+x,g+w,o-w filename</code> 对filename允许当前用户执行，允许组写入，不允许其他用户写入</li>
<li><code>chmod a-r filename</code> 对filename不允许所有用户与组读取</li>
<li>系统对文件系统的权限还可以表示为数字：
<ul>
<li>chmod 755 test.txt
<code>rwx r-x r-x</code>一般可以分3个为一段
111 101 101
<code>7 5 5</code></li>
<li>chmod 600 test.txt
<code>rw- --- ---</code>
<code>110 000 000</code>
<code>6 0 0</code></li>
</ul>
</li>
</ul>
<h2 id="特殊权限的设置-chmod-s-t"> 特殊权限的设置  chmod s/t</h2>
<ul>
<li>特殊权限设置
<ul>
<li>SUID （Set User ID）
<ul>
<li>只对二进制程序有效</li>
</ul>
</li>
<li>SGID（Set Group ID）</li>
<li>Sticky-Bit</li>
</ul>
</li>
<li>特殊权限指的是什么？什么时候需要？
<ul>
<li>/bin/passwd命令</li>
<li>shadow文件</li>
</ul>
</li>
<li>对可执行文件
<ul>
<li>SUID</li>
<li>SGID</li>
</ul>
</li>
<li>对目录
<ul>
<li>SGID</li>
<li>sticky-bit</li>
</ul>
</li>
<li>相关命令
<ul>
<li>chmod u+s</li>
<li>chmod g+s</li>
<li>chmod +t</li>
</ul>
</li>
</ul>
<h3 id="chmod-u-s"> chmod u+s</h3>
<ul>
<li><code>chmod u+s filename</code>文件执行的时候拥有文件所有者的权限，只限可执行文件 （二进制程序）</li>
</ul>
<h4 id="例子-2"> 例子</h4>
<ul>
<li>一个经典的情况：用户有权限修改密码，但是无权限修改shawod文件</li>
<li>linux解决方案：在linux将passwd文件的权限设为S，S表示为若登录账号为bit使用该文件的时候，行使的时候还是文件拥有者者的权限，不管谁执行都是root
注：只有管理员才能设置，此方法是有一定危险性的，此权限只限于可执行文件</li>
</ul>
<div><pre><code><span>[</span>root@centos ~<span>]</span><span># cd /usr/bin/</span>
<span>[</span>root@centos bin<span>]</span><span># ls -l passwd</span>
-rwsr-xr-x. <span>1</span> root root <span>27856</span> <span>8</span>月   <span>9</span> <span>2019</span> <span>passwd</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h5 id="过程"> 过程：</h5>
<ol>
<li>因为/usr/bin/passwd的权限对任何的用户都是可以执行的，所以系统中每个用户都可以执行此命令。</li>
<li>而/usr/bin/passwd这个文件的权限是属于root的。</li>
<li>当某个用户执行/usr/bin/passwd命令的时候，就拥有了root的权限了。</li>
<li>于是某个用户就可以借助root用户的权力，来修改了/etc/shadow文件了。</li>
<li>最后，把密码修改成功。
注：这个SUID只能运行在二进制的程序上（系统中的一些命令），不能用在脚本上（script），因为脚本还是把很多的程序集合到一起来执行，而不是脚本自身在执行。同样，这个SUID也不能放到目录上，放上也是无效的。</li>
</ol>
<h3 id="chmod-g-s"> chmod g+s</h3>
<ul>
<li>
<p><code>chmod g+s filename</code> 文件执行的时候拥有群组的权限 SGID，创建文件的时候也会归属于此用户组</p>
</li>
<li>
<p>和SUID一样，只是SGID是获得该程序所属用户组的权限。</p>
<ol>
<li>
<p>SGID对二进制程序有用；</p>
</li>
<li>
<p>程序执行者对于该程序来说，需具备x的权限；</p>
</li>
<li>
<p>SGID主要用在目录上；</p>
<p>如果用户在此目录下具有w权限的话，若使用者在此目录下建立新文件，则新文件的群组与此目录的群组相同。</p>
</li>
</ol>
</li>
</ul>
<h3 id="chmod-t"> chmod +t</h3>
<ul>
<li><code>chmod +t filename</code>t是粘置位，sticky-bit
若一个文件里有多个用户的文件，让在文件夹的文件用户只能删除自己读写的文件，不能删除他人的文件仅有自己与 root才有权力删除</li>
<li>这个就是针对others来设置的了，和上面两个一样，只是功能不同而已。</li>
<li>一般用于临时文件，linux的tmp和win的临时文件，多个程序临时使用tmp文件夹，各自独立运行且不影响</li>
</ul>
<h1 id="文件存储结构与链接文件"> 文件存储结构与链接文件</h1>
<h2 id="文件类型"> 文件类型</h2>
<p>linux下面的文件类型主要有：</p>
<ol>
<li>普通文件：C语言源代码、shell脚本、二进制的可执行文件等。分为纯文本和二进制</li>
<li>目录文件：目录，存储文件的唯一地方</li>
<li>链接文件：指向同一个文件或目录的文件</li>
<li>特殊文件：与系统外设相关的，通常在/dev下面。分为块设备和字符设备</li>
</ol>
<p>可以通过<code>ls -l</code>, <code>file</code>,<code>stat</code>,<code>ls -i</code>几个命令来查看文件的类型等相关信息</p>
<h2 id="文件存储"> 文件存储</h2>
<p>Linux正统的文件系统（如ext2、ext3、ext4）一个文件由目录项、inode和数据块组成</p>
<ul>
<li>目录项：包含文件名和inode节点号</li>
<li>Inode：又称文件索引节点，是文件基本信息的存放地和数据块指针存放地</li>
<li>数据块：文件的具体内容存放地</li>
</ul>
<p>Linux正统的文件系统（如ext2、ext3、ext4等）将硬盘分区时会划分出目录块、 inode table区块和data block数据区域。一个文件由一个目录项、 inode和数据区域块组成。 Inode包含文件的属性（如读写属性、 owner等，以及指向数据块的指针），数据区域块则是文件内容。当査看某个文件时，会先从iode tabe中査出文件属性及数据存放点，再从数据块中读取数据</p>
<p><img src="./images/linux_notes/image-20200407151538628.png" alt="image-20200407151538628" /></p>
<ul>
<li>
<p>有个目录项，每一个目录项文件指向一个索引inode表（索引节点编号）</p>
</li>
<li>
<p>目录项结构：<img src="./images/linux_notes/image-20200407151635240.png" alt="image-20200407151635240" /></p>
<ul>
<li>
<p>查看节点编号</p>
<ul>
<li>
<p><code>li -li</code>可以查看当前文件下的索引节点号</p>
</li>
<li>
<p><code>stat filename</code>查看单个文件的详细inode信息</p>
<div><pre><code><span>[</span>root@centos a<span>]</span><span># stat bit </span>
  文件：<span>"bit"</span>
  大小：34        	块：0          IO 块：4096   目录
设备：fd00h/64768d	Inode：17709411    硬链接：2
权限：<span>(</span><span>2775</span>/drwxrwsr-x<span>)</span>  Uid：<span>(</span> <span>1000</span>/     bit<span>)</span>   Gid：<span>(</span> <span>1000</span>/     bit<span>)</span>
环境：unconfined_u:object_r:default_t:s0
最近访问：2020-04-02 <span>21</span>:31:55.421690059 +0800
最近更改：2020-04-02 <span>21</span>:31:53.500668341 +0800
最近改动：2020-04-02 <span>21</span>:31:53.500668341 +0800
创建时间：-
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div></li>
</ul>
</li>
</ul>
</li>
<li>
<p>inode表再指向了数据，数据是存储在一个单独的数据区</p>
</li>
<li>
<p>inode结构</p>
<ul>
<li>一般inode目录表只占文件系统磁盘空间的1%</li>
<li><img src="./images/linux_notes/image-20200407151725750.png" alt="image-20200407151725750" /></li>
</ul>
</li>
</ul>
<h2 id="硬链接、符号链接"> 硬链接、符号链接</h2>
<ul>
<li>符号链接和硬链接是我们常见的两个概念：</li>
<li>硬链接
<ul>
<li>是给文件一个副本，同时建立两者之间的连接关系。修改其中一个，与其连接的文件同时被修改。如果删除其中任意一个其余的文件将不受影响。</li>
</ul>
</li>
<li>符号链接
<ul>
<li>也叫软链接，他只是对源文件在鑫的位置建立一个“快捷方式”接的文件将成为无源之水-&gt;仅剩下文件名了，当然删除这个链接，也不会影响到源文件，但对链接文件的使用、应用都是直接调用源文件的</li>
</ul>
</li>
</ul>
<p><img src="./images/linux_notes/image-20200407144155127.png" alt="image-20200407144155127" /></p>
<h3 id="硬链接"> 硬链接</h3>
<ul>
<li>ln 源文件 链接文件名</li>
<li>修改其副本文件将会对存储的内容进行修改，其余副本或主文件读取存储内容的时候也会修改，使用ln创建的文件本质上是创建一个链接指向存储的内容</li>
<li>没增加一个文件名，inode节点上的链接数增加一，每删除一个对应的文件名，inode节点上的链接数减一，直到为0，inode节点和对应的数据块被回收，</li>
<li>文件的大小为文件内容的大小，硬链接不能链接目录</li>
<li><img src="./images/linux_notes/image-20200407145015637.png" alt="image-20200407145015637" /></li>
</ul>
<h3 id="软链接"> 软链接</h3>
<ul>
<li>ln -s 源文件 链接文件名</li>
<li>类似建立了一个快捷链接，指向了源文件，当被指向的源文件被删除了软链接还存在但是失效了，可以看到源文件和软链接指向的inode表都不一样</li>
<li>符号链接的大小为路径的长度，软链接可以链接目录</li>
<li><img src="./images/linux_notes/image-20200407145533540.png" alt="image-20200407145533540" /></li>
</ul>
<h3 id="其他说明"> 其他说明</h3>
<ul>
<li><code>rm A</code>删除的只是A这个文件名，而A对应的数据块（文件）只有inode节点链接数减少为0的时候才会被系统回收</li>
</ul>
<h3 id="使用限制"> 使用限制</h3>
<ul>
<li>硬链接Hard Link
<ul>
<li>创建硬链接会增加额外的记录项以引用文件</li>
<li>对应于同一文件系统上的一个物理文件</li>
<li>每个目录项引用相同的inode号</li>
<li>创建时连接数递增</li>
<li>不能跨文件系统</li>
<li>不能link目录</li>
</ul>
</li>
<li>符号连接（软链接）Stmbolic Link
<ul>
<li>一个符号链接的内容是它引用文件的名称</li>
<li>可以对目录进行链接</li>
<li>可以跨分区</li>
<li>指向的是另一个文件的路径；其大小为指向的路径字符串的长度；不增加或减少目标文件inode的引用计数</li>
</ul>
</li>
</ul>
<h1 id="进程管理"> 进程管理</h1>
<h2 id="概述"> 概述</h2>
<p>进程是正在运行的程序的实例</p>
<ul>
<li>狭义定义：进程是正在运行的程序的实例（an instance of a computer program that is being executed）。</li>
<li>广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</li>
<li>进程的概念主要有两点：第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为进程。</li>
<li>进程是操作系统中最基本、重要的概念。是多道程序系统出现后，为了刻画系统内部出现的动态情况，描述系统内部各道程序的活动规律引进的一个概念,所有多道程序设计操作系统都建立在进程的基础上。</li>
</ul>
<h3 id="进程分类"> 进程分类</h3>
<ul>
<li>交互进程
<ul>
<li>由一个shell启动的进程，用户发布一个命令后系统执行，执行完毕显示结果然后等待用户再次输入命令</li>
</ul>
</li>
<li>守护进程
<ul>
<li>在开机启动的程序，一般是在后台运行的特殊进程，执行的是特定的系统任务，用户是不可以与计算机对话的，linux中守护进程在windows中叫做服务</li>
</ul>
</li>
</ul>
<h3 id="进程的属性"> 进程的属性</h3>
<h4 id="进程id"> 进程ID</h4>
<ul>
<li>
<p><code>ps</code>通过此命令可以查看当前运行进程的id号</p>
</li>
<li>
<p>pid（PID process IDentity）是一个整数，每一个进程都有一个唯一的PID来代表自己身份，进程也可以根据PID来识别其他的进程</p>
<p><img src="./images/linux_notes/clip_image001-1586270801469.png" alt="img" /></p>
</li>
</ul>
<h4 id="父进程和父进程id"> 父进程和父进程ID</h4>
<ul>
<li>可以使用<code>ps -o ppid,pid,cmd</code>命令查看父进程ID，进程ID，命令</li>
<li>其中ppid是parent PID，可以通过下图看到ps命令的PPID与-bash的PID 9291相同
<ul>
<li>可以说-bash是ps命令的父进程</li>
<li>ps是-bash的子进程</li>
<li><img src="./images/linux_notes/clip_image001-1586270888034.png" alt="img" /></li>
</ul>
</li>
<li>也可以使用<code>pstree</code>命令将进程树打印出来，可以看到下图中第二个<code>dhclient</code>是<code>NetworkManager</code>的子进程
<ul>
<li><img src="./images/linux_notes/clip_image002-1586270997140.jpg" alt="img" /></li>
</ul>
</li>
</ul>
<h4 id="启动进程的用户id和所属组gid"> 启动进程的用户ID和所属组GID</h4>
<p>​      RUID（Real User ID）   RGID（Real Group ID）</p>
<p>​      EUID（Effect User ID）  EGID（Effect Group ID）</p>
<p>可以使用<code>ps -eo ruid,rgid, euid,egid,pid, cmd</code></p>
<h4 id="进程的状态"> 进程的状态</h4>
<p>由于cpu只能一个时间内对一个进程运行，多个程序需要运行则需要分时运行</p>
<ul>
<li>
<p>运行 run</p>
</li>
<li>
<p>休眠 suspend</p>
</li>
<li>
<p>僵死 zombie</p>
<ul>
<li>运行程序过多或重复运行或运行错误</li>
</ul>
</li>
<li>
<p>由于cpu只能一个时间内对一个进程运行，多个程序需要运行则需要分时运行，所以会产生三种运行状态，运行的时候就是进程运行在前台，休眠则是进程在后台中暂停活动，僵死则是当前进程报错卡主或程序子进程的退出信息滞留在内核中的状况（父进程不对子进程调用wait函数），这样的情况下，子进程成为僵尸（zombie）进程。当大量僵尸进程积累时，内存空间会被挤占</p>
</li>
<li>
<p>当子进程终结时，它会通知父进程，并清空自己所占据的内存，并在内核里留下自己的退出信息(exit code，如果顺利运行，为0；如果有错误或异常状况，为&gt;0的整数)。在这个信息里，会解释该进程为什么退出。父进程在得知子进程终结时，有责任对该子进程使用wait系统调用。这个wait函数能从内核中取出子进程的退出信息，并清空该信息在内核中所占据的空间。但是，如果父进程早于子进程终结，子进程就会成为一个孤儿(orphand)进程。孤儿进程会被过继给init进程，init进程也就成了该进程的父进程。init进程负责该子进程终结时调用wait函数。</p>
<p>当然，一个糟糕的程序也完全可能造成子进程的退出信息滞留在内核中的状况（父进程不对子进程调用wait函数），这样的情况下，子进程成为僵尸（zombie）进程。当大量僵尸进程积累时，内存空间会被挤占。</p>
</li>
</ul>
<h4 id="进程执行的优先级别"> 进程执行的优先级别</h4>
<p>可以指定某一进程在被执行时的优先度</p>
<h4 id="进程所连接的终端名"> 进程所连接的终端名</h4>
<p>从哪个终端获取的</p>
<h4 id="进程资源占用"> 进程资源占用</h4>
<h4 id="tty-teletype"> TTY teletype</h4>
<p>tty一词源于Teletypes，或teletypewriters，原来指的是电传打字机，是通过串行线用打印机键盘通过阅读和发送信息的东西，后来这东西被键盘和显示器取代，所以现在叫终端比较合适。</p>
<p>终端是一种字符型设备，他有多种类型，通常使用tty来简称各种类型的终端设备。</p>
<h3 id="进程启动"> 进程启动</h3>
<ul>
<li>
<p>手动启动</p>
</li>
<li>
<p>调度启动</p>
<ul>
<li>
<p><code>at</code>定时在某一时间点启动程序任务</p>
</li>
<li>
<p>结束时输入ctrl+D结束</p>
</li>
<li>
<p>操作</p>
<div><pre><code>at now+1minutes
<span>ls</span> /a
<span>cat</span> bit2.ini
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
</ul>
<p>要结束的时候输入ctrl+D</p>
</li>
</ul>
<h3 id="在vim挂起进程"> 在VIM挂起进程</h3>
<p>在vim中使用<code>ctrl+Z</code>可以暂停（挂起）进程回到命令行</p>
<h2 id="查看进程信息"> 查看进程信息</h2>
<h3 id="ps"> ps</h3>
<ul>
<li><code>ps [options] [--help]</code> 查看当前系统运行的进程状态</li>
<li>ps ：process status，他可以兼容多种选项的类型例如：
<ul>
<li>UNIX中<code>ps -a -u -x</code></li>
<li>BSD<code>ps aux</code></li>
<li>GNU</li>
<li>推荐使用<code>ps -aux</code></li>
</ul>
</li>
<li><code>ps -aux</code>显示所有的进程的全部信息</li>
<li><code>ps -e</code> -e表示列出全部进程（只显示PID、TTY、time、CMD）</li>
<li><code>ps -eo pid,comm,cmd</code>-o指定输出后面三个参数
<ul>
<li>pid（PID process IDentity）是一个整数，每一个进程都有一个唯一的PID来代表自己<strong>身份</strong>，进程也可以根据PID来识别其他的进程</li>
<li>comm（COMMAND）这个进程的简称</li>
<li>CMD是进程所对应的程序以及运行时所带的参数，一些中括号<code>[]</code>括 起来的，他们是内核的一部分功能，被打扮成进程的样子以方便操作系统管理</li>
</ul>
</li>
<li>ps 的参数非常多, 在此仅列出几个常用的参数并大略介绍含义</li>
<li>-A 列出所有的行程</li>
<li>-w 显示加宽可以显示较多的资讯</li>
<li>-au 显示较详细的资讯</li>
<li>-aux 显示所有包含其他使用者的行程</li>
<li>au(x) 输出格式 :</li>
<li>USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND</li>
<li>USER: 行程拥有者</li>
<li>PID: pid</li>
<li>%CPU: 占用的 CPU 使用率</li>
<li>%MEM: 占用的记忆体使用率</li>
<li>VSZ: 占用的虚拟记忆体大小</li>
<li>RSS: 占用的记忆体大小</li>
<li>TTY: 终端的次要装置号码 (minor device number of tty)</li>
<li>STAT: 该行程的状态:</li>
<li>D: 无法中断的休眠状态 (通常 IO 的进程)</li>
<li>R: 正在执行中</li>
<li>S: 静止状态</li>
<li>T: 暂停执行</li>
<li>Z: 不存在但暂时无法消除</li>
<li>W: 没有足够的记忆体分页可分配</li>
<li>&lt;: 高优先序的行程</li>
<li>N: 低优先序的行程</li>
<li>L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O)</li>
<li>START: 行程开始时间</li>
<li>TIME: 执行的时间</li>
<li>COMMAND:所执行的指令</li>
</ul>
<h3 id="uptime"> uptime</h3>
<p>系统已经运行了多长时间</p>
<div><pre><code><span>[</span>root@centos /<span>]</span><span># uptime</span>
 <span>20</span>:59:26 up <span>37</span> min,  <span>3</span> users,  load average: <span>0.01</span>, <span>0.29</span>, <span>0.58</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="w"> w</h3>
<p>当前登录的用户，以及他们正在干什么</p>
<div><pre><code><span>[</span>root@centos /<span>]</span><span># w</span>
 <span>21</span>:02:13 up <span>40</span> min,  <span>3</span> users,  load average: <span>0.74</span>, <span>0.58</span>, <span>0.65</span>
<span>USER</span>     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
bit      :0       :0               <span>173</span>月20 ?xdm?   <span>4</span>:11   <span>0</span>.62s /usr/libexec/gnome-ses
root     :1       :1               <span>20</span>:36   ?xdm?   <span>4</span>:11   <span>0</span>.48s /usr/libexec/gnome-ses
bit      pts/1    :0               <span>21</span>:00    <span>5</span>.00s  <span>0</span>.32s  <span>1</span>.57s /usr/libexec/gnome-ter
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="top"> top</h3>
<ul>
<li><code>top [-] [d delay] [q] [c] [S] [s] [i] [n] [b]</code></li>
<li>Linux top命令用于实时显示 process 的动态，交互式监视资源密集型流程</li>
<li>参数
<ul>
<li>d : 改变显示的更新速度，或是在交谈式指令列( interactive command)按 s</li>
<li>q : 没有任何延迟的显示速度，如果使用者是有 superuser 的权限，则 top 将会以最高的优先序执行</li>
<li>c : 切换显示模式，共有两种模式，一是只显示执行档的名称，另一种是显示完整的路径与名称S : 累积模式，会将己完成或消失的子行程 ( dead child process ) 的 CPU time 累积起来</li>
<li>s : 安全模式，将交谈式指令取消, 避免潜在的危机</li>
<li>i : 不显示任何闲置 (idle) 或无用 (zombie) 的行程</li>
<li>n : 更新的次数，完成后将会退出 top</li>
<li>b : 批次档模式，搭配 &quot;n&quot; 参数一起使用，可以用来将 top 的结果输出到档案内</li>
<li>p：显示指定的pid进程</li>
</ul>
</li>
</ul>
<h3 id="pstree"> pstree</h3>
<p>显示进程树，将所有进程以柱状图显示</p>
<h3 id="free"> free</h3>
<p>显示 内存使用情况</p>
<div><pre><code><span>[</span>root@centos /<span>]</span><span># free</span>
              total        used        <span>free</span>      shared  buff/cache   available
Mem:        <span>2027940</span>     <span>1082188</span>      <span>523028</span>       <span>18212</span>      <span>422724</span>      <span>778284</span>
Swap:       <span>2097148</span>      <span>161536</span>     <span>1935612</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="管理进程"> 管理进程</h2>
<h3 id="kill"> kill</h3>
<ul>
<li><code>kill PID</code> 杀死进程
<ul>
<li>PID指的是用ps命令查看的PID</li>
</ul>
</li>
<li>用kill来结束进程（发送值15,终止信号给进程）</li>
<li><code>kill -9 PID</code> 若<code>kill PID</code>无法关闭进程则使用值9杀死进程信号
<ul>
<li>在杀死进程的时候切记会对文件当前运行状态损坏！
<img src="./images/linux_notes/image-20200407161202794.png" alt="image-20200407161202794" /></li>
</ul>
</li>
<li><code>man 7 signal</code>值的说明
<img src="./images/linux_notes/image-20200407160805151.png" alt="image-20200407160805151" /></li>
</ul>
<h3 id="timeout"> timeout</h3>
<ul>
<li><code>timeout 时间 命令</code> 指定时间内查看指定的命令，超出时间自动退出</li>
<li><code>timeout 10 top</code> 执行10秒的top命令</li>
</ul>
<h3 id="nice"> nice</h3>
<ul>
<li><code>nice [-n adjustment] [-adjustment] [--adjustment=adjustment] [--help] [--version] [command [arg...]]</code>配置调用程序的优先级</li>
<li>linux nice命令以更改过的优先序来执行程序，如果未指定程序，则会打印出目前的排程优先序，内定的adjustment为10，范围为-20（最高优先序）到19（最低优先序）</li>
<li>比如，你希望操作系统能分配更多的CPU资源给浏览器进程，让浏览速度更快、更流畅，操作体验更好。那具体应该怎么做呢？尽管linux的进程调度算法十分复杂，但都是以进程的优先级为基础的。因此，只需要改变进程的优先级即可。</li>
<li>命令
<ul>
<li><code>nice</code>当nice没有选项时，输出值表示系统进程缺省的优先级值，一般为0
<ul>
<li>当没有给出具体的优先级值时默认为10，如<code>nice vi</code>设置vi进程的优先级值为10</li>
</ul>
</li>
<li><code>nice -n 优先级值 调度的任务</code>，-n与--adjustment的效果是一样的
<ul>
<li><img src="./images/linux_notes/image-20200409200732390.png" alt="image-20200409200732390" /></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="renice"> renice</h3>
<ul>
<li>
<p><code>renice</code> <code>[优先等级][</code>-g<code>&lt;程序群组名称&gt;...][</code>-p<code>&lt;程序识别码&gt;...][-u &lt;用户名称&gt;...]</code></p>
</li>
<li>
<p>重置改变程序的优先级</p>
</li>
<li>
<p>命令</p>
<ul>
<li>renice -5 -p 5200  #将PID为5200的进程的niceness设为-5</li>
<li>renice -5 -u xie   #将属于用户xie的进程的niceness设为-5</li>
<li>renice -5 -g group1 #将属于group1组的程序的niceness设为5</li>
</ul>
</li>
<li>
<p><img src="./images/linux_notes/image-20200409201202123.png" alt="image-20200409201202123" /></p>
</li>
</ul>
<h2 id="杀进程"> 杀进程</h2>
<h3 id="kill-2"> kill</h3>
<p>上面有将这里不复述</p>
<h3 id="killall"> killall</h3>
<ul>
<li>
<p><code>killall 正在运行的程式名</code></p>
</li>
<li>
<p>killall和pkill是相似的,不过如果给出的进程名不完整，killall会报错</p>
</li>
<li>
<p>操作</p>
<div><pre><code><span>[</span>root@centos /<span>]</span><span># ps</span>
   PID TTY          TIME CMD
  <span>6009</span> pts/1    00:00:00 <span>su</span>
  <span>6019</span> pts/1    00:00:00 <span>bash</span>
  <span>6130</span> pts/1    00:00:00 <span>vim</span>
  <span>6144</span> pts/1    00:00:00 <span>ps</span>
<span>[</span>root@centos /<span>]</span><span># killall vi</span>
vi: no process found
<span>[</span>root@centos /<span>]</span><span># killall vim</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></li>
</ul>
<h3 id="pkill"> pkill</h3>
<ul>
<li>
<p><code>pkill 正在运行的程式名</code></p>
</li>
<li>
<p>pkill 和killall 应用方法差不多，相比killall他可以不输入全名，也是直接杀死运行中的程式；如果你想杀掉单个进程，请用kill 来杀掉。</p>
</li>
<li>
<p>pkill＝pgrep+kill。</p>
</li>
<li>
<p>操作</p>
<div><pre><code><span>[</span>root@centos /<span>]</span><span># ps</span>
   PID TTY          TIME CMD
  <span>6009</span> pts/1    00:00:00 <span>su</span>
  <span>6019</span> pts/1    00:00:00 <span>bash</span>
  <span>6130</span> pts/1    00:00:00 <span>vim</span>
  <span>6173</span> pts/1    00:00:00 <span>ps</span>
<span>[</span>root@centos /<span>]</span><span># pkill vi</span>
<span>[</span>root@centos /<span>]</span><span># pkill vim</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></li>
</ul>
<h2 id="管理后台任务"> 管理后台任务</h2>
<ul>
<li>前台（foreground）</li>
<li>后台（background）</li>
</ul>
<p>前台就是在当前窗口中运行的进程，后台大多是一种在不需用户干预的情况下运行于操作系统后台的计算机进程，通常用于执行如日志记录、系统监测、作业调度以及用户提醒等任务</p>
<h3 id="如何让工作进入后台"> 如何让工作进入后台？ <strong>&amp;</strong></h3>
<h3 id="jobs"> jobs</h3>
<p>list your jobs 查看后台的工作</p>
<p><img src="./images/linux_notes/image-20200407161931650.png" alt="image-20200407161931650" /></p>
<h3 id="-3"> &amp;</h3>
<ul>
<li><code>vi file.txt &amp;</code></li>
<li>Run a job in the background 在后台运行作业</li>
<li><code>vi &amp;</code>这样也可以直接在后台运作</li>
<li><img src="./images/linux_notes/image-20200407163023810.png" alt="image-20200407163023810" /></li>
</ul>
<h3 id="z"> ^Z</h3>
<ul>
<li>在vim的操作视图中使用<code>ctrl+Z</code>命令即可挂起当前作业回到字符界面</li>
<li>Suspend the current (foreground) job 挂起当前（前台）作业</li>
</ul>
<h3 id="fg"> fg</h3>
<ul>
<li>
<p><code>fg jobID</code></p>
<ul>
<li>jobID为在jobs中查看的ID数</li>
</ul>
</li>
<li>
<p>Unsuspend a job: bring it into the foreground 取消暂停作业：将其置于前台。</p>
</li>
<li>
<p>可以将后台的进程调用置于前台</p>
</li>
<li>
<p>操作</p>
<div><pre><code><span>[</span>root@centos /<span>]</span><span># jobs</span>
<span>[</span><span>1</span><span>]</span>+  已停止               <span>vi</span>
<span>[</span>root@centos /<span>]</span><span># pkill vi</span>
<span>[</span>root@centos /<span>]</span><span># fg 1</span>
<span>vi</span>
Vim: Caught deadly signal <span>TERM</span>
Vim: Finished.
已终止
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></li>
</ul>
<h3 id="bg"> bg</h3>
<ul>
<li>
<p><code>bg jobID</code></p>
<ul>
<li>将挂起的作业在后台运行，使<code>jobs</code>命令可以看到左边有<code>+、-、空格</code></li>
</ul>
</li>
<li>
<p>Make a suspended job run in the background 使挂起的作业在后台运行</p>
</li>
<li>
<p>操作</p>
<div><pre><code><span>[</span>root@centos /<span>]</span><span># jobs</span>
<span>[</span><span>1</span><span>]</span>   已停止               <span>vi</span>
<span>[</span><span>2</span><span>]</span>-  已停止               <span>vi</span>
<span>[</span><span>3</span><span>]</span>+  已停止               <span>vi</span>
<span>[</span>root@centos /<span>]</span><span># bg 1</span>
<span>[</span><span>1</span><span>]</span> <span>vi</span> <span>&amp;</span>

<span>[</span><span>1</span><span>]</span>+  已停止               <span>vi</span>
<span>[</span>root@centos /<span>]</span><span># jobs</span>
<span>[</span><span>1</span><span>]</span>+  已停止               <span>vi</span>
<span>[</span><span>2</span><span>]</span>   已停止               <span>vi</span>
<span>[</span><span>3</span><span>]</span>-  已停止               <span>vi</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div></li>
</ul>
<h3 id="c"> ^C</h3>
<ul>
<li>在前台应用中使用<code>ctrl+C</code>可以中断执行</li>
</ul>
<h1 id="网络配置"> 网络配置</h1>
<h2 id="查看"> 查看</h2>
<ul>
<li><code>/etc/sysconfig/network-scripts</code>网络配置的文件一般存放于此，也可以直接配置这些文件来达到网络配置，但是容易出错所以不建议直接配置此文件！新版本中将不被允许而是由服务代替编辑配置</li>
<li><code>ifconfig</code>此命令也不建议使用，因为在Linux操作系统中最小安装时默认不安装<code>ifconfig</code>这个命令，使用<code>ip</code>这个命令来取代配置IP地址</li>
</ul>
<h3 id="显示当前连接情况-ip"> 显示当前连接情况 - ip</h3>
<p><a href="https://www.cnblogs.com/0to9/p/9591315.html" target="_blank" rel="noopener noreferrer">参考</a></p>
<h4 id="ip-addr"> ip addr</h4>
<p><code>ip addr show</code> 显示当前所有的网络情况</p>
<ul>
<li><code>ip addr</code></li>
<li><code>ip a s</code></li>
<li><code>ip a</code></li>
</ul>
<h4 id="ip-route"> ip route</h4>
<ul>
<li><code>ip route</code>显示路由信息
<ul>
<li><code>ip route show</code></li>
</ul>
</li>
</ul>
<h4 id="ip-link"> ip link</h4>
<ul>
<li><code>ip link</code>显示连接状态
<ul>
<li><code>ip link show</code></li>
<li><code>ip link set ens33 up</code>指定物理设备连接开启</li>
</ul>
</li>
<li><code>ip -s link</code>显示所有网络连接和数据包情况</li>
</ul>
<h4 id="ip-addr-add"> ip addr add</h4>
<ul>
<li><code>ip addr add 192.168.3.110/24 dev ens33</code>给ens33添加一个ip</li>
</ul>
<h4 id="ip-addr-del"> ip  addr del</h4>
<ul>
<li><code>ip addr del 192.168.3.110/24 dev ens33</code>删除ens的一个ip</li>
</ul>
<h2 id="查看端口和服务状况"> 查看端口和服务状况</h2>
<h4 id="netstat"> netstat</h4>
<ul>
<li><code>netstat</code>用于显示网络状态，利用netstat指令可让你得知整个Linux系统的网络情况</li>
<li><code>netstat [-acCeFghilMnNoprstuvVwx][-A&lt;网络类型&gt;][--ip]</code></li>
<li><a href="https://www.runoob.com/linux/linux-comm-netstat.html" target="_blank" rel="noopener noreferrer">参考</a></li>
</ul>
<h4 id="ss"> ss</h4>
<ul>
<li><code>ss [-参数]</code>ss 是 Socket Statistics 的缩写，用来统计 socket 连接的相关信息，它跟 netstat 差不多，但有着比 netstat 更强大的统计功能，能够显示更多更详细的连接信息</li>
<li>命令
<ul>
<li>ss -l 显示本地打开的所有端口</li>
<li>ss -pl 显示每个进程具体打开的socket</li>
<li>ss -t -a 显示所有tcp socket</li>
<li>ss -u -a 显示所有的UDP Socekt</li>
<li>ss -o state established '( dport = :smtp or sport = :smtp )' 显示所有已建立的SMTP连接</li>
<li>ss -o state established '( dport = :http or sport = :http )' 显示所有已建立的HTTP连接</li>
</ul>
</li>
<li>命令可以提供如下信息：
<ul>
<li>所有的TCP sockets
<ul>
<li>所有的UDP sockets</li>
<li>所有ssh/ftp/ttp/https持久连接</li>
<li>所有连接到Xserver的本地进程</li>
<li>使用state（例如：connected, synchronized, SYN-RECV, SYN-SENT,TIME-WAIT）、地址、端口过滤</li>
<li>所有的state FIN-WAIT-1 tcpsocket连接以及更多.</li>
</ul>
</li>
</ul>
</li>
<li>使用ss命令替代netstat部分命令,例如netsat -ant/lnt等.</li>
<li><a href="https://www.cnblogs.com/saneri/p/7561614.html" target="_blank" rel="noopener noreferrer">参考</a></li>
</ul>
<h3 id="ping"> ping</h3>
<ul>
<li>
<p><code>ping [-参数]</code>Linux ping命令用于检测主机。</p>
<p>执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常</p>
</li>
<li>
<p>参数</p>
<ul>
<li>-d 使用Socket的SO_DEBUG功能。</li>
<li>-c&lt;完成次数&gt; 设置完成要求回应的次数。
<ul>
<li><code>ping -c 4 8.8.8.8</code></li>
</ul>
</li>
<li>-f 极限检测。</li>
<li>-i&lt;间隔秒数&gt; 指定收发信息的间隔时间。</li>
<li>-I&lt;网络界面&gt; 使用指定的网络接口送出数据包。</li>
<li>-l&lt;前置载入&gt; 设置在送出要求信息之前，先行发出的数据包。</li>
<li>-n 只输出数值。</li>
<li>-p&lt;范本样式&gt; 设置填满数据包的范本样式。</li>
<li>-q 不显示指令执行过程，开头和结尾的相关信息除外。</li>
<li>-r 忽略普通的Routing Table，直接将数据包送到远端主机上。</li>
<li>-R 记录路由过程。</li>
</ul>
</li>
<li>
<p><a href="https://www.runoob.com/linux/linux-comm-ping.html" target="_blank" rel="noopener noreferrer">参考</a></p>
<ul>
<li>-s&lt;数据包大小&gt; 设置数据包的大小。</li>
<li>-t&lt;存活数值&gt; 设置存活数值TTL的大小。</li>
<li>-v 详细显示指令的执行过程。</li>
</ul>
</li>
</ul>
<h3 id="ip-配置网络配置"> IP 配置网络配置</h3>
<ul>
<li><code>ip a add 192.168.1.1/24 dev ens33</code>
<ul>
<li>给指定网卡添加一个ip（不是覆盖修改）</li>
<li>dev ens33 指定的网卡</li>
</ul>
</li>
</ul>
<h3 id="网络服务说明"> 网络服务说明</h3>
<ul>
<li>新的服务：NetworkManager（优先）
<ul>
<li>开机优先启动</li>
</ul>
</li>
<li>旧服务：network（次级、第二）
<ul>
<li>开机后启动</li>
</ul>
</li>
</ul>
<h3 id="device与connection的区别"> device与connection的区别</h3>
<ul>
<li>简介
<ul>
<li>device：设备</li>
<li>connection：连接</li>
</ul>
</li>
<li>一个设备可以有多个连接配置，</li>
</ul>
<h2 id="配置网络的主要命令"> 配置网络的主要命令</h2>
<h4 id="nmtui"> nmtui</h4>
<ul>
<li><code>nmtui</code>NetworkManager Text user interface
命令行下图形界面的配置网络设置</li>
</ul>
<h4 id="nmcli"> nmcli</h4>
<ul>
<li><code>nmcli OPTIONS OBJECT {COMMAND|help}</code></li>
<li>OPTIONS 选项
<ul>
<li><code>-p[retty]</code> 漂亮的输出 *</li>
<li><code>-t[erse]</code> 简介的输出</li>
<li><code>-m[ode]tabular|multiline</code>输出模式</li>
<li><code>-c[olors]auto|yes|no</code>是否在输出中使用颜色</li>
<li><code>-f[ields]&lt;field1,field2,...&gt;|all|common</code>指定要输出的字段</li>
<li><code>-e[scape]yes|no</code>值中的列分隔符</li>
<li><code>-a[sk]</code>询问缺少的参数</li>
<li><code>-s[how-secrets]</code>允许显示密码</li>
<li><code>-w[ait]&lt;seconds&gt;</code>设置超时等待完成操作</li>
<li><code>-v[version]</code>显示程序版本</li>
<li><code>-h[elp]</code>打印帮助</li>
</ul>
</li>
<li>OBJECT 科目<code>（* -常用）</code>
<ul>
<li><code>g[eneral]</code> 通用，网络管理的一般状况及操作 *
<ul>
<li><code>nmcli general</code>查看设备简要状态</li>
<li><code>nmcli general permissions</code>查看当前用户对网络设置的的权限</li>
<li><code>nmcli general hostname YOURHOSTNAME</code>设置计算机名YOURHOSTNAME
<ul>
<li><code>hostname</code>可以直接查看，或者<code>vi /etc/hostname</code></li>
</ul>
</li>
<li><code>nmcli general logging</code>记录日志的等级，默认为INFO
<ul>
<li><code>nmcli general logging level 日志等级 domains 所选域</code>更改日志记录等级！只是一次生效，重启恢复原状</li>
<li><code>journalctl</code>查看日志</li>
<li><code>journalctl -u NetworkManager</code>查看NetworkManager日志</li>
</ul>
</li>
</ul>
</li>
<li><code>n[etworking]</code> 网络，网络开启与禁用
<ul>
<li><code>nmcli networking connectivity check</code>当前模式（全双工/半双工）</li>
<li><code>nmcli networking on|off</code>开关网络连接</li>
</ul>
</li>
<li><code>r[adio]</code> 无线，网络开关
<ul>
<li><code>nmcli radio all on|off开关无线</code></li>
</ul>
</li>
<li><code>c[onnection]</code> 连接，网络连接管理 *
<ul>
<li><code>nmcli connection show</code>可以查看又有什么设备后再输入</li>
</ul>
</li>
<li><code>d[evice]</code> 设备，设备管理 *
<ul>
<li><code>nmcli device status</code> 当前设备状态（简要）</li>
<li><code>nmcli device show ens33</code>显示设备信息（详细）</li>
<li><code>nmcli device disconnect ens33</code>禁用设备ens33</li>
<li><code>nmcli device connect ens33</code>启用设备ens33</li>
<li><code>nmcli device monitor ens33</code>监控指定设备ens33</li>
<li><code>nmcli device set ens33 autoconnect yes|no</code>指定设备是否设置自动连接</li>
<li><code>nmcli device set ens33 managed yes|no</code>指定设备是否设置被NetworkManager管理</li>
</ul>
</li>
<li><code>a[gent]</code>代理，安装代理</li>
<li><code>m[onitor]</code> 监控，监控NetworkManager的变动，每当NetworkManager出现改动时打印一行信息
<ul>
<li><code>nmcli monitor</code>显示更改日志，会占用前台，所有网络设备当变动时会在下方打印出</li>
</ul>
</li>
<li>help 帮助</li>
</ul>
</li>
<li>命令
<ul>
<li><code>nmcli</code>NetworkManager command line interface
纯命令行配置网络设置</li>
<li><code>nmcli con show</code>查看当前连接</li>
<li><code>nmcli con show ens33</code>查看指定设备连接属性</li>
<li><code>nmcli con add con-name “interface-name” ifname ens33 type ethernet</code>建立一个连接</li>
<li><code>nmcli con up “interface-name”</code>生效一个连接</li>
<li><code>nmcli dev show ens33</code>查看ens33属性</li>
<li><code>nm-connection-editor</code>限定图形界面下配置网络</li>
</ul>
</li>
</ul>
<h3 id="设置主机名"> 设置主机名</h3>
<ul>
<li><code>hostnamectl</code>查看主机名与本机信息</li>
<li><code>hostnamectl set-hostname MYNEWNAME</code>设置主机名为MYNEWNAME</li>
</ul>
<h1 id="linux软件管理"> Linux软件管理</h1>
<h2 id="rpm"> RPM</h2>
<ul>
<li>RPM软件包管理器，英文原义：RPM Package Manager（原Red Hat Package Manager，是一个递归缩写）。</li>
<li>注解：一种用于互联网下载包的打包及安装工具，它包含在某些Linux分发版中。它生成具有.RPM扩展名的文件。作为一个软件包管理工具，RPM管理着系统已安装的所有RPM程序组件的资料。</li>
<li>包命名规则
<ul>
<li>software-1.2.3-1.tar.gz</li>
<li>software-1.2.3-1.i386.rpm</li>
</ul>
</li>
<li>主要功能
<ul>
<li>安装</li>
<li>卸载</li>
<li>升级</li>
<li>查询</li>
<li>验证</li>
</ul>
</li>
<li>输出选项
<ul>
<li>-v
<ul>
<li>安装时显示软件名称</li>
</ul>
</li>
<li>-h
<ul>
<li>使用<code>#</code>显示进度</li>
</ul>
</li>
</ul>
</li>
<li>常见的基于RPM的更新系统
<ul>
<li>Red Hat Network</li>
<li>yum</li>
<li>zypp</li>
<li>urpmi</li>
<li>ART-RPM</li>
</ul>
</li>
</ul>
<h3 id="安装"> 安装</h3>
<ul>
<li><code>rpm -i|-install package_name.rpm</code>
<ul>
<li><code>rpm -ivh rpm -ivh httpd-2.4.6-90.el7.centos.x86_64.rpm</code>安装httpd包</li>
</ul>
</li>
<li><code>rpm -F|--freshen package_name</code>重装</li>
</ul>
<h4 id="安装apache阿帕奇"> 安装Apache阿帕奇</h4>
<p>如果是第一次安装会提示依赖包</p>
<div><pre><code><span>[</span>root@centos Packages<span>]</span><span># rpm -ivh httpd-2.4.6-90.el7.centos.x86_64.rpm </span>
错误：依赖检测失败：
	/etc/mime.types 被 httpd-2.4.6-90.el7.centos.x86_64 需要
	httpd-tools <span>=</span> <span>2.4</span>.6-90.el7.centos 被 httpd-2.4.6-90.el7.centos.x86_64 需要
	libapr-1.so.0<span>(</span><span>)</span><span>(</span>64bit<span>)</span> 被 httpd-2.4.6-90.el7.centos.x86_64 需要
	libaprutil-1.so.0<span>(</span><span>)</span><span>(</span>64bit<span>)</span> 被 httpd-2.4.6-90.el7.centos.x86_64 需要
<span>[</span>root@centos Packages<span>]</span><span># rpm -ivh mailcap-2.1.41-2.el7.noarch.rpm</span>
<span>[</span>root@centos Packages<span>]</span><span># rpm -ivh apr-1.4.8-5.el7.x86_64.rpm apr-util-1.5.2-6.el7.x86_64.rpm</span>
<span>[</span>root@centos Packages<span>]</span><span># rpm -ivh httpd-tools-2.4.6-90.el7.centos.x86_64.rpm</span>
<span>[</span>root@centos Packages<span>]</span><span># rpm -ivh httpd-2.4.6-90.el7.centos.x86_64.rpm</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="卸载"> 卸载</h3>
<ul>
<li><code>rpm -e|--erase pack_path_name</code>切记是package，包含软件名的</li>
</ul>
<h3 id="升级"> 升级</h3>
<ul>
<li><code>rpm -U|--upagrade package_name</code></li>
</ul>
<h3 id="查询"> 查询</h3>
<ul>
<li><code>rpm -p package_name</code></li>
<li><code>rom -q package_name</code>查询软件包是否安装并查看软件包的版本</li>
<li><code>rpm -qa</code>查询已安装的所有软件包</li>
<li><code>rpm -qa | grep package_name</code>查询已安装的所有关于与rpmfile名字的包
<ul>
<li><code>rpm -qa | grep dhcp</code>查询安装了的DHCP</li>
</ul>
</li>
<li><code>rpm -ql package_name</code>查看指定rpmfile包安装了什么文件与安装路径</li>
</ul>
<h4 id="查看安装文件"> 查看安装文件</h4>
<p><code>rpm -ql dhcp</code>检查DHCP安装了什么文件</p>
<h3 id="其他-3"> 其他</h3>
<ul>
<li><code>--replacepkgs</code>重新安装rpm包</li>
<li><code>--justdb</code>升级数据库，不修改文件系统</li>
<li><code>--percent</code>在软件包安装时输出百分比</li>
<li><code>--help</code>帮助</li>
<li><code>--version</code>显示版本信息</li>
<li><code>-c</code>显示所有配置文件</li>
<li><code>-d</code>显示所有文档文件</li>
<li><code>-h</code>显示安装进度</li>
<li><code>-l</code>列出软件包中的文件</li>
<li><code>-a</code>显示出文件状态</li>
<li><code>-p</code>查询/校验一个软件包文件</li>
<li><code>-v</code>显示详细的处理信息</li>
<li><code>--dump</code>显示基本文件信息</li>
<li><code>--nomd5</code>不验证文件的md5支持</li>
<li><code>--nofiles</code>不验证软件包中的文件</li>
<li><code>--nodeps</code>不验证软件包的依赖关系</li>
<li><code>--whatrequires</code>查询/验证需要一个依赖性的软件包</li>
<li><code>--whatprovides</code>查询/验证提供一个依赖性的软件包</li>
</ul>
<h2 id="yum"> yum</h2>
<ul>
<li>yum是Yellow dog Updater，Modified的简称 ，用python写成，基于RPM可以自动解决依赖问题，他拥有自己的配置文件位于<code>/etc/yum.conf</code>，库在<code>/etc/yum.repos.d/</code>，由于yum追求安全可靠，所以新的软件不会在库上出现</li>
<li>特点
<ul>
<li>便于管理大量系统的更新问题</li>
<li>可以同时配置多个资源库*.repo（Repository）</li>
<li>简介的配置文件</li>
</ul>
</li>
</ul>
<h3 id="常用命令"> 常用命令</h3>
<ol>
<li>列出所有可更新的软件清单命令：<code>yum check-update</code></li>
<li>更新所有软件命令：<code>yum update</code></li>
<li>仅安装指定的软件命令：<code>yum install &lt;package_name&gt;</code></li>
<li>仅更新指定的软件命令：<code>yum update &lt;package_name&gt;</code></li>
<li>列出所有可安裝的软件清单命令：<code>yum list</code></li>
<li>删除软件包命令：<code>yum remove &lt;package_name&gt;</code></li>
<li>查找软件包 命令：<code>yum search &lt;keyword&gt;</code></li>
<li>清除缓存命令:
<ul>
<li><code>yum clean packages</code>: 清除缓存目录下的软件包</li>
<li><code>yum clean headers</code>: 清除缓存目录下的 headers
<ul>
<li><code>yum clean oldheaders</code>: 清除缓存目录下旧的 headers</li>
<li><code>yum clean</code>, <code>yum clean all</code>(= <code>yum clean packages</code>; <code>yum clean oldheaders</code>) :清除缓存目录下的软件包及旧的headers</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="查询-2"> 查询</h3>
<ul>
<li><code>yum search NAME</code> 可支持模糊查询软件包名</li>
</ul>
<h3 id="安装-2"> 安装</h3>
<ul>
<li><code>yum install NAME</code>安装指定软件包名安装包</li>
<li><code>yum install NAME -y</code></li>
</ul>
<h3 id="删除卸载"> 删除卸载</h3>
<ul>
<li><code>yum remove NAME</code> 删除卸载指定软件</li>
</ul>
<h3 id="清理yum索引"> 清理yum索引</h3>
<ul>
<li>
<p><code>yum clean all</code>将本地yum库索引清理掉，下次索引时就会下载新的索引</p>
</li>
<li>
<p><code>less /etc/yum.conf</code>查看yum配置文件</p>
</li>
<li>
<p>查看yum库</p>
<div><pre><code>  <span>[</span>root@centos ~<span>]</span><span># cd /etc/yum.repos.d/</span>
  <span>[</span>root@centos yum.repos.d<span>]</span><span># ls</span>
  CentOS-Base.repo  CentOS-Debuginfo.repo  CentOS-Media.repo    CentOS-Vault.repo
  CentOS-CR.repo    CentOS-fasttrack.repo  CentOS-Sources.repo
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
</ul>
<h3 id="手动添加在线yum库"> 手动添加在线yum库</h3>
<h4 id="添加国内源镜像"> 添加国内源镜像</h4>
<ul>
<li>
<p><code>/etc/yum.repos.d</code>centos yum源文件存放目录</p>
</li>
<li>
<p><code>CentOS-Base</code>开头的文件为系统默认的源文件如需添加国内镜像，只需要先备份这个文件，并改成其他名字，再用国内的源改成这个名字的源文件即可</p>
</li>
<li>
<p>这里我们通过重命名来备份</p>
<div><pre><code><span>mv</span> /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>添加国内源</p>
<ul>
<li>
<p>网易</p>
<div><pre><code>CentOS7
<span>[</span>root@localhost yum.repos.d<span>]</span><span># wget http://mirrors.163.com/.help/CentOS7-Base-163.repo</span>
CentOS6
<span>[</span>root@localhost yum.repos.d<span>]</span><span># wget http://mirrors.163.com/.help/CentOS6-Base-163.repo</span>
CentOS5
<span>[</span>root@localhost yum.repos.d<span>]</span><span># wget http://mirrors.163.com/.help/CentOS5-Base-163.repo</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
<li>
<p>阿里云</p>
<div><pre><code>CentOS7
<span>[</span>root@localhost ~<span>]</span><span># wget -O /etc/yum.repos.d/CentOS-Base-aliyun.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span>
CentOS6
<span>[</span>root@localhost ~<span>]</span><span># wget -O /etc/yum.repos.d/CentOS-Base-aliyun.repo http://mirrors.aliyun.com/repo/Centos-6.repo</span>
CentOS5
<span>[</span>root@localhost ~<span>]</span><span># wget -O /etc/yum.repos.d/CentOS-Base-aliyun.repo http://mirrors.aliyun.com/repo/Centos-5.repo</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
</ul>
</li>
<li>
<p>编译源信息：</p>
<div><pre><code>yum makecache 
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>更新源会看到镜像信息</p>
<div><pre><code> yum -y update
</code></pre>
<div><span>1</span><br></div></div></li>
</ul>
<h4 id="添加制定软件源"> 添加制定软件源</h4>
<ul>
<li>
<p>新建<code>Nginx.repo</code>文件来并下载Nginx，好处是可以一直与官方保持最新版本（需要联网）</p>
<ul>
<li>
<p><code>touch /etc/yum.repos.d/Nginx.repo</code>新建文件</p>
</li>
<li>
<p><code>vi /etc/yum.repos.d/Nginx.repo</code>编辑文件</p>
</li>
<li>
<p>并将<a href="http://nginx.org/en/linux_packages.html#RHEL-CentOS" target="_blank" rel="noopener noreferrer">Nginx给的内容</a>粘贴上去</p>
<p>20200416旧版：</p>
<div><pre><code>[nginx-stable]
name=nginx stable repo
baseurl=http://nginx.org/packages/centos/$releasever/$basearch/
gpgcheck=1
enabled=1
gpgkey=https://nginx.org/keys/nginx_signing.key
module_hotfixes=true
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
<li>
<p><code>yum install nginx</code>安装nginx</p>
</li>
</ul>
</li>
</ul>
<h3 id="yun挂载虚拟机iso源"> yun挂载虚拟机iso源</h3>
<p><a href="https://blog.csdn.net/moranxue/article/details/44460589" target="_blank" rel="noopener noreferrer">参考</a></p>
<p>为了能直接使用本地，请先将本地网络断开<code>nmcli d con dis ens33</code></p>
<ul>
<li>
<p>用<code>pwd</code>命令先得到iso的路径，我这里的iso路径为：<code>/run/media/root/CentOS\ 7\ x86_64 /mnt</code></p>
<ul>
<li>首先我们将其挂载，<code>CentOS\ 7\ x86_64</code>z中的<code>\</code>作用是转义空格，不作为分隔符使用</li>
</ul>
<div><pre><code><span>mount</span> /run/media/root/CentOS<span>\</span> <span>7</span><span>\</span> x86_64 /mnt
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>然后去<code>CentOS\ 7\ x86_64</code>将yum挂载源更改其中三个内容，注意<code>baseurl=file:///</code>后面的内容以你的iso路径为准</p>
<div><pre><code><span>baseurl</span><span>=</span>file:///run/media/root/CentOS<span>\</span> <span>7</span><span>\</span> x86_64/
<span>gpgcheck</span><span>=</span><span>0</span>
<span>enabled</span><span>=</span><span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>
<p>然后使用<code>yum repolist all</code>查看是否有启用源
显示的结果应该为</p>
<div><pre><code>c7-media     CentOS-7 - Media       启用
</code></pre>
<div><span>1</span><br></div></div></li>
</ul>
</li>
<li>
<p>成功之后使用<code>yum search httpd</code>，以下结果为本地源的查找结果
<img src="./images/linux_notes/image-20200416152412013.png" alt="image-20200416152412013" /></p>
</li>
</ul>
<h3 id="制作yum离线软件库-createrepo"> 制作yum离线软件库  -  createrepo</h3>
<ul>
<li>若<code>/myrpm/</code>中有许多rpm文件，要制作索引</li>
<li><code>createrepo /myrpm/</code>制作在<code>/myrpm/</code>全部rpm文件的索引，建立好之后会多出一个文件夹repodata，里面包含了索引文件
<img src="./images/linux_notes/image-20200416155443228.png" alt="image-20200416155443228" /></li>
</ul>
<h3 id="yum将逐渐淘汰"> yum将逐渐淘汰</h3>
<p>yum将逐渐淘汰，取而代之的是DNF，在8中会替代yum的操作，yum已经停止更新不再更新</p>
<h1 id="磁盘管理"> 磁盘管理</h1>
<h2 id="概念-2"> 概念</h2>
<h3 id="硬盘的技术指标"> 硬盘的技术指标</h3>
<ul>
<li>主轴转速：指硬盘盘片在一分钟内所能完成的最大转数。</li>
<li>平均寻道时间：指磁头从得到指令到寻找到数据所在磁道的时间，它描述硬盘读取数据的能力。</li>
<li>数据传输率：指的是从硬盘缓存向外输出数据的速度，单位为MB/S.</li>
<li>高速缓存：缓存是数据的临时寄存器，主要用来缓解速度差和实现数据预存取等。</li>
<li>单碟容量：指每张碟片的最大容量。这是反映硬盘综合性能指标的一个重要的因素。</li>
</ul>
<h3 id="硬盘接口方式"> 硬盘接口方式</h3>
<ul>
<li>FC-AL接口主要应用于任务级的关键数据的大容量实时存储。可以满足髙性能、高可靠和高扩展性的存储需要</li>
<li>SCSI接口主要应用于商业级的关键数据的大容量存储。</li>
<li>SAS接口是个全才，可以支持SAS和SATA磁盘，很方便地满足不同性价比的存储需求，是具有高性能、高可靠和高扩展性的解决方案，因而被业界公认为取代并行SCSI的不二之选。</li>
<li>SATA接口主要应用于非关键数据的大容量存储，近线存储和非关键性应用（如替代以前使用磁带的数据备份）.</li>
<li>PATA（俗称IDE）接口已基本淘汰。</li>
</ul>
<h3 id="主引导记录-mbr"> 主引导记录 MBR</h3>
<p>MBR (Main Boot Record)</p>
<ul>
<li>MBR位于硬盘的0磁道0柱面1扇区【512字节】
<ul>
<li>装载操作系统的硬盘引导程序【446字节】</li>
<li>硬盘分区表（ Disk Partition Table，DPT）【64字节】
<ul>
<li>分区ID或者类型</li>
<li>分区起始磁道</li>
<li>分区磁道数</li>
</ul>
</li>
<li>最后两个字节“55， AA”是分区的结束标志</li>
</ul>
</li>
<li>MBR是由分区程序（如fdisk）所产生的
<ul>
<li>不依赖任何操作系统</li>
<li>硬盘引导程序是可以改变的，从而实现多系统共存</li>
</ul>
</li>
</ul>
<h3 id="磁盘分区"> 磁盘分区</h3>
<ul>
<li>指向附加分区描述符的扩展分区</li>
<li>内核最多支持分区数：
<ul>
<li>IDE驱动器为63</li>
<li>SCSI驱动器为15</li>
</ul>
</li>
<li>为什么是分区驱动？</li>
<li>容量、性能、配额和修复</li>
</ul>
<h3 id="分区类型"> 分区类型</h3>
<p>三个主系统，第四个为扩展分区，里面有L的逻辑分区</p>
<p><img src="./images/linux_notes/image-20200421210114544.png" alt="image-20200421210114544" /></p>
<h3 id="两种硬盘存储方式"> 两种硬盘存储方式</h3>
<ul>
<li>基本硬盘存储
<ul>
<li>在基本磁盘上存储数据需要在磁盘上创建主分区、扩展分区和逻辑分区，然后对这些分区进行管理</li>
</ul>
</li>
<li>动态硬盘存储
<ul>
<li>在动态硬盘上存储数据需要在磁盘上创建动态卷，然后对这些卷进行管理</li>
</ul>
</li>
</ul>
<h2 id="操作-分区管理工具"> 操作 - 分区管理工具</h2>
<p>常用的操作：分区、格式化、挂载/卸载、自动挂载</p>
<ul>
<li>常用的分区工具
<ul>
<li>fdisk</li>
<li>sfdisk</li>
<li>GNU parted - 高级分区操作（创建、复制、调整大小等等）</li>
</ul>
</li>
<li>partprobe - 重新设置内存中的内核分区表版本</li>
</ul>
<h3 id="fdisk"> fdisk</h3>
<p><img src="./images/linux_notes/image-20200421210414413.png" alt="image-20200421210414413" /></p>
<ul>
<li><code>fdisk -l</code>查看本地存储列表
<ul>
<li><code>fdisk -l /dev/sdb</code> 查看指定的</li>
</ul>
</li>
<li><code>fdisk /dev/sdb</code> 这里/dev/sdb为指定的磁盘进入分区管理界面
<ul>
<li>m 获取帮组</li>
<li>l 显示可支持的类型</li>
<li>n 添加新的分区
<ul>
<li>p 主要分区，可用来安装操作系统
<ul>
<li>选择指定的分区号（1-4）</li>
<li>起始扇区（2048-10485759，默认为 2048） -  由于我的硬盘设置为5G所以实际最大的大小会不一样</li>
<li>Last扇区 结束的扇区（+扇区 or +size{K,M,G} (2048-10485759，默认为 10485759）
<ul>
<li>假如我输入100000，这个表示为100000个扇区
返回：分区 1 已设置为 Linux 类型，大小设为 47.8 MiB</li>
<li>假如我输入+1G，这个表示为添加1G的内存
返回：分区 2 已设置为 Linux 类型，大小设为 1 GiB</li>
</ul>
</li>
</ul>
</li>
<li>e 扩展分区，只能用于存储，不可安装操作系统
<ul>
<li>扩展分区是不能格式化的，扩展分区必须建立逻辑分区使用</li>
<li>l 逻辑分区
<ul>
<li>这个分区是可以被格式化的</li>
<li>不管有没有逻辑分区都是从<code>/dev/sdb5</code>开始，只建立扩展分区是不能直接用的，建立了扩展分区之后还要再次<code>n</code>后之前的e就会变成<code>l</code>(logical逻辑)的命令</li>
<li>添加逻辑分区的扇区大小操作与主要分区一样</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>p 查看分区情况</li>
<li>w 写入硬盘
<ul>
<li>注意这个命令将写入硬盘，此命令不可逆！</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="格式化分区-format"> 格式化分区 format</h4>
<p>格式化成指定系统格式，扩展分区是不能格式化的</p>
<ul>
<li><code>mkfs -t vfat /dev/sdb1</code></li>
<li><code>mkfs -t ext4 /dev/sdb5</code></li>
<li><code>mkfs.ext4 /dev/sdb2</code></li>
<li><code>mkfs.vfat /dev/sdb2</code>
<ul>
<li>如果是使用mkfs.***的格式就不需要加-t</li>
</ul>
</li>
</ul>
<h3 id="挂载-mount"> 挂载 mount</h3>
<ul>
<li>挂载的文件与设备都是临时的，重启之后就没了</li>
<li>当分区建立好了之后是不能直接使用的，需要将其挂载到分区内，扩展分区是不能挂载的！要挂载逻辑分区</li>
</ul>
<ol>
<li>
<p>先建立空文件夹</p>
<p>默认的linux会自动挂载到mnt和media文件夹中</p>
<p><code>cd mnt</code>后<code>mkdir diskb1 diskb2</code>文件夹的名字可以随便起</p>
</li>
<li>
<p>挂载分区到文件夹内</p>
</li>
</ol>
<ul>
<li>
<p><code>mount 选项 设备名 挂载点(目录)</code></p>
</li>
<li>
<p><code>mount -t vfat /dev/sdb1 /mnt/diskb1</code></p>
</li>
<li>
<p><code>mount /dev/sdb1 /mnt/diskb2</code></p>
</li>
<li>
<p><code>mount</code> 查看已挂载的分区(有点复杂)</p>
</li>
</ul>
<p>遇到NTFS的文件系统需要安装工具才能对NTFS文件系统操作</p>
<h4 id="df-查看分区情况"> df  查看分区情况</h4>
<p><img src="./images/linux_notes/clip_image002-1587469298117.jpg" alt="img" /></p>
<h4 id="lsblk-查看块设备命令"> lsblk 查看块设备命令</h4>
<ul>
<li>list block devices</li>
</ul>
<h4 id="blkid-查看uuid"> blkid 查看UUID</h4>
<h4 id="问题"> 问题</h4>
<ol>
<li>
<p>能否挂载到非空目录？</p>
<p>可以，但不建议，会将原本的内容都隐藏</p>
</li>
<li>
<p>能否将一个分区多次挂载？</p>
<p>可以，还可以用不同的权限挂载，但一般用的不多</p>
</li>
<li>
<p>如何读取NTFS文件系统？如NTFS的U盘或exFAT</p>
<p>直接使用是不支持，需要配合第三方工具，但最新的系统中支持了exFAT，要使用NTFS则需要安装<code>ntfs-3g</code>这个软件</p>
</li>
</ol>
<h3 id="卸载-umount"> 卸载 - umount</h3>
<p>这个卸载不是删除文件，而是卸载挂载</p>
<p>这里假设分区<code>/dev/sdb1</code>挂载在目录<code>/mnt/cdrom1</code></p>
<ul>
<li><code>umount 挂载的分区名</code>
<ul>
<li><code>umount /dev/sdb1</code></li>
</ul>
</li>
<li><code>umount 挂载点目录</code>
<ul>
<li><code>umount /mnt/cdrom1</code></li>
</ul>
</li>
</ul>
<h3 id="自动挂载-开机自动挂载"> 自动挂载 - 开机自动挂载</h3>
<p><code>vim /etc/fstab</code></p>
<ul>
<li>
<p>限制说明：</p>
<ul>
<li><code>/</code>目录必须优先于其他mount point被挂载进来</li>
<li>其他挂载点必须已经创建的目录</li>
<li>所有挂载点同一时间内只能挂载一次</li>
<li>所有分区在同一时间内只能挂载一次</li>
</ul>
</li>
<li>
<p>目录<code>/etc/fstab</code></p>
</li>
<li>
<p>在fstab文件内添加内容：<code>分区名称 挂载点 文件系统类型 defaults 0 0</code></p>
<ul>
<li>后面两个0代表是否自动检查与备份</li>
<li>新建挂载点文件夹<code>mkdir /mnt/cdrom1</code></li>
<li><code>/dev/sdb1 /mnt/cdrom1 vfat defaults 0 0</code></li>
</ul>
</li>
<li>
<p><code>LABEL=</code></p>
<ul>
<li><code>LABEL=/dev/sdb1 /mnt/cdrm1 vfat defaults 0 0</code></li>
</ul>
</li>
<li>
<p><code>UUID</code></p>
<ul>
<li>先使用<code>lsblk</code>命令获得清晰的全局块设备布局</li>
<li>然后使用<code>blkid</code>命令获得设备的UUID</li>
<li>使用 vi命令，<code>vi /etc/fstab</code></li>
<li>在最后一行添加<code>UUID=第二部获取的UUID 挂载点 文件系统类型 defaults 0 0</code>，然后命令模式下使用<code>:wq</code>保存退出</li>
<li>重启一次使用<code>df</code>或<code>df -h</code>命令查看</li>
</ul>
</li>
</ul>
<h2 id="其他工具"> 其他工具</h2>
<h3 id="parted"> parted</h3>
<ul>
<li>交互模式
<ul>
<li><code>parted [选项] &lt;硬盘设备名&gt;</code></li>
</ul>
</li>
<li>命令行模式
<ul>
<li><code>parted [选项] &lt;硬盘设备名&gt; &lt;子命令&gt; [&lt;子命令参数&gt;]</code></li>
<li>子命令
<ul>
<li><code>help [COMMAND]</code>打印帮助信息</li>
<li>print [free |NUMBER|all]显示分区表</li>
<li><code>mkpart PART-TYPE [FS-TYPE] START END</code>创建新分区</li>
<li><code>rm NUMBER</code>删除指定分区</li>
<li><code>set NUMBER FLAG STATE</code>设置分区标记</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="逻辑卷管理"> 逻辑卷管理</h1>
<h2 id="概念-3"> 概念</h2>
<ul>
<li>
<p>LVM是逻辑卷管理(Logical Bolume Manager)的简称，他是Linux环境下对卷进行方便的抽象层</p>
</li>
<li>
<p>LVM是建立在硬盘和分区之上的一个逻辑层来为文件系统屏蔽下层磁盘分区布局，从而提高磁盘分区管理的灵活性。</p>
</li>
<li>
<p>LVM允许在多个物理设备间重新组织文件系统，包括重新设定文件系统的大小。</p>
</li>
</ul>
<h3 id="lvm结构"> LVM结构</h3>
<p>先将其变成物理卷(physical volume, PV)，再转换逻辑卷成为一个大VG大磁盘(vgcreate)，再划分成若干个逻辑分区后像普通分区一样格式化后直接挂在到文件系统中</p>
<p><img src="./images/linux_notes/image-20200423102309602.png" alt="image-20200423102309602" /></p>
<h3 id="lvm-物理区域"> LVM - 物理区域</h3>
<ul>
<li>每一个物理卷被划分为基本单元（称为 Physical EXtent，PE），具有唯一编号的</li>
<li>PE是可以被LWM寻址的最小存储单元PE的大小可根据实际情况在创建物理卷时指定，默认为4MB</li>
<li>PE的大小一旦确定将不能改变，同一个卷组中的所有物理卷的PE的大小需要一致</li>
</ul>
<h3 id="lvm-卷组"> LVM - 卷组</h3>
<ul>
<li>卷组（ Volume group，VG）建立在物理卷之上，它由一个或多个物理卷组成</li>
<li>卷组创建之后，可以动态添加物理卷到卷组中，在卷组上可以创建一个或多个“LVM分区”（逻辑卷）</li>
<li>一个LVM系统中可以只有一个卷组，也可以包含多个卷组</li>
<li>LVM的卷组类似于非LWM系统中的物理硬盘</li>
</ul>
<h3 id="lvm-逻辑卷"> LVM - 逻辑卷</h3>
<ul>
<li>逻辑卷（ Logical Volume,LV）建立在卷组之上，它是从卷组中“切出”的一块空间</li>
<li>逻辑卷创建之后，其大小可以伸缩</li>
<li>LVM的逻辑卷类似于非LVM系统中的硬盘分区，在逻辑卷之上可以建立文件系统（比如/home或者/usr等）</li>
</ul>
<h2 id="操作"> 操作</h2>
<h3 id="磁盘-分区"> 磁盘（分区）</h3>
<ul>
<li><code>disk /partition</code></li>
</ul>
<h3 id="物理卷-physical-volume-pv"> 物理卷（physical volume, PV）</h3>
<ul>
<li><code>/dev/sd*?</code></li>
<li><code>pvdisplay</code>查看拥有哪些物理卷</li>
<li><code>pvcreate</code> 分区或磁盘
<ul>
<li><code>pvcreate /dev/sdb1 /dev/sdb2 /dev/sdb5 /dev/sdb6</code>一次创建多个物理卷</li>
<li><code>pvcreate /dev/sdc</code>也可以直接对磁盘进行物理卷创建</li>
</ul>
</li>
</ul>
<h3 id="卷组-volume-group-vg"> 卷组（volume group, VG）</h3>
<ul>
<li><code>/dev/VG name/</code></li>
<li>创建卷组
<ul>
<li><code>vgcreate</code> 卷组名称 物理卷列表</li>
<li><code>vgcreate vg1 /dev/sdb1 /dev/sdb2 /dec/sdc</code>将三个物理卷加到一个卷组中（逻辑上指定的大磁盘）</li>
</ul>
</li>
<li>向组卷<code>vg</code>添加物理卷<code>pv</code>
<ul>
<li><code>vgextend [选项] 参数</code></li>
<li>实例
<ul>
<li><code>vgextend vg1 /dev/sdb2</code>将物理卷<code>/dev/sdb2</code>添加至卷组<code>vg1</code></li>
</ul>
</li>
<li>选项
<ul>
<li><code>-d</code>调试模式</li>
<li><code>-t</code>仅测试</li>
</ul>
</li>
<li>参数
<ul>
<li>卷组：指定要操作的卷组名称</li>
<li>物理卷列表：指定要删除的物理卷列表</li>
</ul>
</li>
</ul>
</li>
<li>删除卷组<code>vg</code>内物理卷<code>pv</code>
<ul>
<li><code>vgreduce [选项] 参数</code></li>
<li>实例
<ul>
<li><code>vgreduce vg1 /dev/sdb2</code>将物理卷<code>/dev/sdb2</code>从卷组<code>vg1</code>中删除</li>
</ul>
</li>
<li>选项
<ul>
<li><code>-a</code>如果命令行中没有指定要删除的物理卷，则删除所有空物理卷</li>
<li><code>--removemissing</code>删除卷组中丢失的物理卷，使卷组恢复正常状态</li>
</ul>
</li>
<li>参数
<ul>
<li>卷组：指定要操作的卷组名称</li>
<li>物理卷列表：指定要删除的物理卷列表</li>
</ul>
</li>
</ul>
</li>
<li><code>vgchange</code>激活与停用
<ul>
<li>激活卷组 - linux系统会自动激活卷组
<ul>
<li><code>vgchange -a y vg1</code> 激活卷组vg1</li>
</ul>
</li>
<li>停用卷组
<ul>
<li><code>vgvhange -a n vg1</code>停用卷组vg1</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="逻辑卷-logical-volume-lv"> 逻辑卷（logical volume, LV）</h3>
<ul>
<li>
<p><code>/dev/VG name/LV name/</code></p>
</li>
<li>
<p>创建逻辑卷</p>
<ul>
<li><code>lvcreate [选项] 参数</code></li>
<li>实例
<ul>
<li><code>lvcreate -L 大小 -n 名称 卷组名</code></li>
<li><code>lvcreate -L 500M -n newlv1 vg1</code>创建大小为500M的逻辑卷，名为<code>newlv1</code></li>
</ul>
</li>
<li>选项
<ul>
<li><code>-L</code>指定逻辑卷大小，单位为<code>lLmMgGtT</code>字节</li>
<li><code>-l</code>指定逻辑卷大小（LE数）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>删除指定LVM逻辑卷</p>
<ul>
<li><code>lvremove [选项] 参数</code></li>
<li>实例
<ul>
<li><code>lvremove /dev/vg1/newlv1</code>删除逻辑卷<code>newlv1</code></li>
</ul>
</li>
<li>选项
<ul>
<li><code>-f</code>强制删除</li>
</ul>
</li>
<li>参数
<ul>
<li>逻辑卷：指定要删除的逻辑卷</li>
</ul>
</li>
</ul>
</li>
<li>
<p>扩展逻辑卷空间</p>
<ul>
<li><code>lvextend [选项] 参数</code></li>
<li>实例
<ul>
<li><code>lvextend -L + 100M /dev/vg1/newlv1</code>增加100M空间</li>
</ul>
</li>
<li>选项
<ul>
<li>与创建逻辑卷一致</li>
</ul>
</li>
</ul>
</li>
<li>
<p>调整逻辑卷空间大小</p>
<p>lvresize命令用于调整LVM逻辑卷的空间大小，可以增大空间和缩小空间。使用lvresize命令调整逻辑卷空间大小和缩小空间时需要谨慎，因为它有可能导致数据丢失。</p>
<ul>
<li><code>lvresize [选项] 参数</code></li>
<li>实例
<ul>
<li><code>lvresize -L +200M /dev/vg1/newlv1</code>将逻辑卷空间增加200M</li>
</ul>
</li>
<li>选项
<ul>
<li>与创建逻辑一致</li>
</ul>
</li>
<li>参数
<ul>
<li>逻辑卷：指定要删除的逻辑卷</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="格式化"> 格式化</h3>
<p><code>mkfs -t ext4 /dev/vg1/newlv1</code></p>
<h3 id="挂载"> 挂载</h3>
<div><pre><code><span>mkdir</span> /a/newlv1dir
<span>mount</span> /dev/vg1/newlv1 /a/newlv1dir
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h1 id="服务"> 服务</h1>
<h2 id="systemctl"> systemctl</h2>
<ul>
<li><code>systemctl [starat|stop|restart|try-restart|reload|status|is-active] SERVERNAME</code>
<ul>
<li>参数
<ul>
<li><code>systemctl start启动服务</code>
<ul>
<li><code>systemctl start dhcpd.service</code>启动dhcp服务</li>
</ul>
</li>
<li><code>systemctl restart</code>先stop，如果失败则再start</li>
<li><code>systemctl try-restart</code>先stop，如果失败不再启动；如果停止成功则再start</li>
<li><code>systemctl reload</code>重新加载</li>
<li><code>systemctl status</code>状态查看
<ul>
<li><code>systemctl status dhcpd[.server]</code>查看dhcp服务状态</li>
<li><code>systemctl status dhcp[.server] -l</code>查看服务详细内容，可以使用这个命令来查看服务报错的详细内容</li>
</ul>
</li>
<li><code>systemctl stop firewalld</code>关闭防火墙</li>
<li><code>systemctl enable vsftpd</code>设置vsftpd开机自启</li>
<li><code>systemctl is-enabled vsftpd</code>检查vsftpd是否开机自启</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="dhcp"> DHCP</h2>
<p>20200428</p>
<h3 id="概念-4"> 概念</h3>
<ul>
<li>DHCP (Dynamic Host Configuration Protocol)动态主机配置协议是TCP/IP协议簇中的一种</li>
<li>DHCP是由因特网工程任务组（IETF）设计的，详尽的协议内容参考RFC2131和RFC1541</li>
<li>DHCP协议主要是用来自动为局域网中的客户机器分配TCP/IP信息的网络协议，并完成每台客户机的 TCP/IP协议配置
<ul>
<li>TCP/IP信息包括IP地址、子网掩码、网关，以及DNS服务器等。</li>
</ul>
</li>
<li>DHCP的前身是 BOOTP（引导协议），DHCP可以说是 BOOTP的增强版本</li>
</ul>
<h4 id="优点"> 优点</h4>
<ul>
<li>减少管理员的工作量</li>
<li>避免IP冲突</li>
<li>减少收入错误的可能</li>
<li>能方便地更改网络的IP网段</li>
<li>移动计算机后不用重新配置网络信息</li>
<li>提高IP地址的利用率</li>
</ul>
<h4 id="dhcp相关概念"> DHCP相关概念</h4>
<ul>
<li>DHCP客户
<ul>
<li>是指一台通过DHCP服务器来获得网络配置参数的主机，通常是不同的客户机或工作站。</li>
</ul>
</li>
<li>DHCP服务器
<ul>
<li>是指提供网络配置参数给DHCP客户的主机。</li>
</ul>
</li>
<li>DHCP中继代理
<ul>
<li>是指在DHCP服务器和DHCP客户之间转发DHCP消息的主机或路由器。若要使用DHCP服务器支持跨越多重路由的子网，则路由器可能需要硬件升级路由器必须支持RFC1533、RFC1534、RFC1541和RFC1542.</li>
</ul>
</li>
<li>作用域
<ul>
<li>是指一个网络中的所有可分配的IP地址的连续范围。作用域主要用来定义网络中单一的物理子网的IP地址范围。作用域是服务器用来管理分配给网络客户的IP地址的主要手段。</li>
</ul>
</li>
<li>超级作用域
<ul>
<li>是指一组作用域的集合，它用来实现同一个物理子网中包含多个逻辑IP子网的情况。在超级作用域中只包含一个成员作用域或子作用域的列表。然而超级作用域并不用于设置具体的范围。子作用域的各种属性需要单独设置。</li>
</ul>
</li>
<li>排除范围
<ul>
<li>是指作用域内从DHCP服务中排除的有限P地址序列。
排除范围确保在这些范围内的任何地址都不由DHCP服务器分配给DHCP客户机。</li>
</ul>
</li>
<li>地址池
<ul>
<li>定义DHCP作用域并应用排除范围之后，剩余的地址在作用域内形成可用地址池。地址池内的地址由DHCP服务器在网络上动态指派给DHCP客户机。</li>
</ul>
</li>
<li>保留
<ul>
<li>指通过DHCP服务器的永久地址租约指派。保留确保了子网上指定的硬件设备始终可使用相同的IP地址。</li>
</ul>
</li>
<li>租用
<ul>
<li>是指DHCP客户从DHCP服务器上获得并临时占用某IP地址的过程。</li>
</ul>
</li>
<li>租约
<ul>
<li>是指客户机可使用的被DHCP服务器指派的IP地址的时间长度，在这个时间范围内客户机可以使用所获得的IP地址。</li>
<li>当客户机获得IP地址时租约被激活。在租约过期之前，客户机一般需要通过服务器更新其地址租约。当租约期满或在服务器上删除时租约停止。租约期限决定租约何时期满以及客户需要用服务器更新它的次数。</li>
</ul>
</li>
</ul>
<p>简单描述过程</p>
<ol>
<li>复制<code>dhcpd.conf.example</code>文件</li>
<li>编辑配置dhcpd.conf文件</li>
<li>建立作用域，设置网关、dns</li>
<li>启动<code>systemctl start dhcpd.service</code></li>
<li>查看客户端获取情况</li>
</ol>
<h3 id="动手"> 动手</h3>
<ol>
<li>
<p><code>yum install dhcp</code>安装dhcp服务器</p>
<ol>
<li>查询是否已经安装DHCP服务<code>rpm -qa | grep dhcp</code></li>
<li>查看安装文件<code>rpm -ql dhcp</code></li>
</ol>
</li>
<li>
<p>配置一个静态IP，两台机器建议配置网络设置为<code>自定义特定虚拟网络</code></p>
</li>
<li>
<p>根据需求配置静态IP</p>
<ul>
<li>
<p><code>systemctl start dhcpd.service</code>启动服务，在启动前需要先配置dhcp，如果没有配置启动则会报错</p>
</li>
<li>
<p><code>cp /usr/share/doc/dhcp-4.2.5/dhcpd.conf.example /etc/dhcp/dhcpd.conf</code>将其覆盖</p>
</li>
<li>
<p><code>vim /etc/dhcp/dhcpd.con</code>简略模式</p>
<div><pre><code>subnet 192.168.3.0 netmask 255.255.255.0 {
        range dynamic-bootp 192.168.3.100 192.168.3.200;	#地址池
        option routers 192.168.3.1;	
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
<li>
<p><code>vim /etc/dhcp/dhcpd.condhcpd.conf</code>详细模式（可选）</p>
</li>
</ul>
<div><pre><code># 设置作用域名
# option definitions common to all supported networks...
option domain-name &quot;bit.cn&quot;;		# 客户机上显示的域名
option domain-name-servers ns1.bit.cn, ns2.bit.cn;	#DNS域名
#......省略中间的大部分内容
# 定义一个作用域，划分网段并配置网关，mac绑定指定IP
subnet 192.168.3.128 netmask 255.255.255.128 {
        range dynamic-bootp 192.168.3.130 192.168.3.200;	#地址池
        option routers 192.168.3.1;	
        option domain-name-servers 114.114.114.114;	# DNS服务地址
        option domain-name &quot;bit.cn&quot;;	# 域名
        option broadcast-address 192.168.1.255;	#广播地址
        default-lease-time 300;	# 默认租约时间
        max-lease-time 7200;	# 最大租约时间
        host Bcomputer{		#host后什么名字都可以
                hardware ethernet 00:0C:29:15:D0:66;		#绑定的mac地址
                fixed-address 192.168.3.155;		# 绑定的ip地址
}
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div></li>
<li>
<p><code>systemctl start dhcpd</code>启动dhcpd服务</p>
</li>
<li>
<p>测试，让DHCP服务器和客户机在同一物理网络下然后获取IP地址</p>
</li>
</ol>
<h2 id="dns"> DNS</h2>
<p>20200430</p>
<h3 id="概念-5"> 概念</h3>
<ul>
<li>
<p>DNS( Domain Name Service，域名系统）是个分布式数据库系统，其作用将域名解析成IP地址</p>
</li>
<li>
<p>域名系统允许用户使用友好的名字而不是难以记忆的数字-IP地址来访问 Iinternet上的主机。</p>
</li>
<li>
<p>DNS是基于客户/服务器模型设计的。</p>
</li>
<li>
<p>Linux下假设DNS服务器通常是使用BIND来进行</p>
</li>
<li>
<p>组成</p>
<ul>
<li>域名系统
<ul>
<li>标识一组主机并提供他们的有关信息的树结构的详细说明</li>
</ul>
</li>
<li>域名服务器
<ul>
<li>保持和维持域名空间中数据的程序</li>
</ul>
</li>
<li>Stub解析器
<ul>
<li>解析器是简单的程序或子程序库，它从服务器中提取信息以响应对域名空间中主机的查询，用于DNS客户</li>
</ul>
</li>
</ul>
</li>
<li>
<p>域名空间的分层结构</p>
<ul>
<li><img src="./images/linux_notes/image-20200430101408111.png" alt="image-20200430101408111" /></li>
<li><img src="./images/linux_notes/image-20200430101430378.png" alt="image-20200430101430378" /></li>
</ul>
</li>
<li>
<p>DNS服务器类型——权威性服务器</p>
<ul>
<li>主域名服务器（ Primary Name Server)
<ul>
<li>是区数据的最根本的来源，是从本地硬盘文件中读取域的数据的，它是所有辅域名服务器进行域传输的源。</li>
</ul>
</li>
<li>辅域名服务器（ Secondary Name Server）
<ul>
<li>通过“区传输（ zone transfer）”从主服务器复制区数据，辅域名服务器可以提供必需的冗余服务。所有的辅域名服务器都应该写在这个域的NS记录中。</li>
</ul>
</li>
<li>残根域名服务器（ Stub Name Server)
<ul>
<li>与辅域名服务器类似，但只复制NS记录而不复制主机数据。</li>
</ul>
</li>
<li>秘密域名服务器（ Stealth Name Server)
<ul>
<li>并没有列在这个域的NS记录里，仅对于知道其IP地址的人可见。</li>
</ul>
</li>
</ul>
</li>
<li></li>
</ul>
<h3 id="动手-2"> 动手</h3>
<h4 id="配置一个主dns"> 配置一个主DNS</h4>
<ol>
<li>
<h5 id="安装-3"> 安装</h5>
<p>chroot机制，当服务被攻陷的时候，只会限制在服务内，而不会影响到实机</p>
<ul>
<li><code>yum install bind-libs bind bind-chroot bind-utils</code>
<ul>
<li>bind-libs</li>
<li>bind</li>
<li>bind-chroot</li>
<li>bind-utils</li>
</ul>
</li>
<li><code>rpm -ql bind</code>查看安装文件</li>
</ul>
</li>
<li>
<p>配置主配置文件（新建区域）</p>
<ul>
<li>
<p>概念</p>
</li>
<li>
<p>主配置文件位置：<code>/etc/named.conf</code></p>
</li>
<li>
<p><code>vim /etc/named.conf</code>改了第2、9行的any，并添加了第17行的zone</p>
</li>
</ul>
</li>
</ol>
<ul>
<li>
<p>配置<code>/etc/named.conf</code></p>
<div><pre><code>options {
        listen-on port 53 { any; };	#侦听的端口{侦听的IP地址;};
        directory       &quot;/var/named&quot;;	# 区域配置文件所存放的位置，正常不改动
        dump-file       &quot;/var/named/data/cache_dump.db&quot;;
        statistics-file &quot;/var/named/data/named_stats.txt&quot;;
        memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;;
        recursing-file  &quot;/var/named/data/named.recursing&quot;;
        secroots-file   &quot;/var/named/data/named.secroots&quot;;
        allow-query     { any; };	# 允许查询的{允许的IP地址;};
#......省略中间的大部分内容
zone &quot;.&quot; IN {
        type hint;
        file &quot;named.ca&quot;;
};  # &quot;.&quot;代表DNS的根服务器，文件位于、var/named/named.ca

# 声明一个自己的DNS区域，区域的名称引号引起来
zone &quot;bit.com&quot; {
	type master;	# 主要区域
	file &quot;bit.com.zone&quot;;	# 此区域的区域文件名，路径在directory指定的/var/named
};
# 声明一个自己的DNS区域，末尾记得加;

# 也可以将自己的区域放在named.rfc1912.zones这个文件中
include &quot;/etc/named.rfc1912.zones&quot;;
include &quot;/etc/named.root.key&quot;;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div></li>
</ul>
<ol start="3">
<li>
<p>编辑区域文件（资源记录文件）注意权限！</p>
<ul>
<li>
<p>概念</p>
<ul>
<li>默认区域文件位置：<code>/var/named</code></li>
<li><code>bit.com.zone</code>注意这里的区域文件名为在主配置文件中申明的文件名</li>
</ul>
</li>
<li>
<p><code>cp /var/named/named.localhost /var/named/bit.com.zone</code> 使用模板文件，然后将其名改为bit.com.zone</p>
</li>
<li>
<p><code>chown :named bit.com.zone</code>安全起见要将组权限要修改为named</p>
</li>
<li>
<p><code>vim /var/named/bit.com.zone</code>编辑区域文件
第二行中<code>123321.qq.com</code>是<code>123321@qq.com</code>的意思，这里用处是当dns出现问题会发送邮件给管理员邮箱<code>123321@qq.com</code></p>
<ul>
<li>
<p>操作</p>
<div><pre><code>$TTL 1D
@       IN SOA  dns.bit.com. 123321.qq.com (
                                        0       ; serial
                                        1D      ; refresh
                                        1H      ; retry
                                        1W      ; expire
                                        3H )    ; minimum
        IN      NS      dns.bit.com.
dns     IN      A       192.168.129.136
www     IN      A       192.168.129.100
mail    IN      A       1.2.3.4
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></li>
</ul>
</li>
</ul>
</li>
<li>
<p>检查配置和区域文件语法问题</p>
<ul>
<li><code>named-checkconf</code></li>
<li><code>named-checkzone bit.com bit.com.zone</code></li>
</ul>
</li>
<li>
<p>启动</p>
<ul>
<li><code>systemctl start named-chroot</code>建议使用这个方法启用DNS服务，会更加安全</li>
<li><code>systemclt start named</code> 启用DNS服务</li>
</ul>
</li>
<li>
<p>测试</p>
<ul>
<li><code>nslookup</code>在nslookup中检查区域配置文件中配置的dns、www、mail是否解析正确，在其他机器上可能会由于防火墙的问题呗拦截
<ul>
<li><code>server localhost</code> 使用本地dns服务</li>
<li><code>dns.bit.com</code> 解析dns.bit.com</li>
<li><code>www.bit.com</code></li>
<li><code>mail.bit.com</code></li>
<li>exit退出</li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="补充"> 补充</h5>
<ul>
<li><code>/etc/named.rfc1912.zones</code>为标准的dns扩展模板，你也可以在这个文件中添加zone进行操作</li>
<li>在zone选项中
<ul>
<li><code>file &quot;host.com.zone&quot;</code>后面的文件名其实可以随便取，只需要<code>/var/named/</code>这个目录下有<code>host.com.zone</code>这个文件即可</li>
<li><code>allow-update</code>是否允许更新</li>
<li>主配置文件可以完全手打也可以使用模板<code>named.localhost</code>，将其复制并改名<code>host.com.zone</code>并修改其中内容即可</li>
</ul>
</li>
</ul>
<h4 id="配置主dns与辅dns"> 配置主DNS与辅DNS</h4>
<p>由于上面已经有详细说明，这里就不再重复</p>
<ul>
<li>
<p>主DNS在<code>named.conf</code>文件中添加</p>
<div><pre><code>...
zone &quot;bit.com&quot; IN {
        type master;
        file &quot;bit.com.zone&quot;;
        allow-update{none;};	# 不允许更新
        allow-transfer {192.168.3.104;};	# 允许传输
};
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>
<li>
<p>重启named-chroot服务</p>
</li>
<li>
<p>若辅助区域拥有多个，则根据需要允许数据传输的IP有多个</p>
<div><pre><code>allow-transfer{
	192.168.3.22;
	192.168.3.33;
};
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
</ul>
</li>
<li>
<p>辅助DNS在<code>named.conf</code>文件或<code>/etc/named.rfc1912.zones</code>中添加</p>
<div><pre><code>....
zone &quot;bit.com&quot; IN {
        type slave;		# 辅助DNS
        file &quot;slaves/bit.com.zone&quot;;
        masters {192.168.3.105};	# 如果有多个主DNS可以继续在后面添加
};
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>
<li>启动named-chroot服务</li>
</ul>
</li>
<li>
<p>可参考：</p>
<ul>
<li>https://blog.51cto.com/20101218/634482</li>
<li>https://blog.csdn.net/mez_blog/article/details/79872251</li>
</ul>
</li>
</ul>
<h5 id="补充-2"> 补充</h5>
<ul>
<li>如果nslookup验证失败了，可以试试允许dns通过或关闭防火墙<code>systemctl stop firewalld</code></li>
</ul>
<h3 id="转发器"> 转发器</h3>
<p>具体参考：https://blog.51cto.com/sweetpotato/1607383</p>
<p>转发器在一台拥有dns环境的空机上配置<code>/etc/named.conf</code>文件：</p>
<div><pre><code>options {
forwarders { 192.168.3.105; }; #指明转发器是谁
forward only; #only表示仅转发 ；也可以使用first表示先进行转发，如果没查询到结果，那么它自己还会根据根提示向外迭代查询
};
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id="验证"> 验证</h4>
<p>假设DNS的IP地址为<code>192.168.3.105</code></p>
<ul>
<li>
<p>ping</p>
<ul>
<li><code>ping 192.168.3.105</code>测试与DNS的连通性</li>
<li><code>ping mail.bit.com</code>此时解析到的会是主区域配置表里的ip</li>
</ul>
</li>
<li>
<p>dig</p>
<ul>
<li><code>dig @DNS_IP 请求的域名</code></li>
<li><code>dig @192.168.3.1005 mail.bit.com</code></li>
</ul>
</li>
<li>
<p>nslookup</p>
<div><pre><code> <span>[</span>root@centos ~<span>]</span><span># nslookup</span>
 <span>></span> server localhost
 Default server: localhost
 Address: ::1<span>#53</span>
 Default server: localhost
 Address: <span>127.0</span>.0.1<span>#53</span>
 <span>></span> mail.bit.com
 Server:		localhost
 Address:	::1<span>#53</span>
 
 Name:	mail.bit.com
 Address: <span>192.168</span>.3.123
 <span>></span> 
 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div></li>
</ul>
<h1 id="web服务"> WEB服务</h1>
<h2 id="工作原理"> 工作原理</h2>
<p>一般可分成4个步骤：连接过程、请求过程、应答过程以及关闭连接</p>
<h3 id="常见的web服务器"> 常见的web服务器</h3>
<ul>
<li>IIS</li>
<li>kangle</li>
<li>websphere</li>
<li>apache</li>
<li>tomcat</li>
<li>jboss</li>
</ul>
<h3 id="web组件"> WEB组件</h3>
<ul>
<li>统一资源标识符URI
<ul>
<li><code>协议名称://极其地址:端口号/路径号/文件名</code>
<ul>
<li>协议名称一所使用的访问协议。如：htt、ftp等</li>
<li>机器地址一数据所在的机器，IP地址/域名</li>
<li>端口号一请求数据的数据源端口（可省略)</li>
<li>路径名一数据所在的相对路径</li>
<li>文件名一请求数椐的文件名</li>
</ul>
</li>
</ul>
</li>
<li>Web客户和Web服务器
<ul>
<li>Web服务器的职责
<ul>
<li>默认监听 TCP/IP的80端口</li>
<li>接受Web客户请求</li>
<li>检查请求的合法性，包括安全性屏蔽</li>
<li>针对请求获取并制作和处理数据</li>
<li>把处理后的信息发送给提出请求的客户机</li>
</ul>
</li>
<li>Web浏览器的职责
<ul>
<li>生成一个Web请求（通常在単击某个链接点时启动）</li>
<li>通过网络将Web请求发送给某个Web服务器</li>
<li>解释服务器传来的Web文档，并把结果显示在屏幕上</li>
</ul>
</li>
<li>WEB客户端与服务器通信过程
<ul>
<li>每取一个网页建立一次连接，读完后马上断开，当需要另一个网页时重新连接，周而复始</li>
</ul>
</li>
</ul>
</li>
<li>超文本传输协议HTTP
<ul>
<li>超文本传输协议（ Hyper Text Transfer Protocol）是在Web上传输资源最常用的方式</li>
<li>HTTP规定了客户机和服务器等Web组件相互交换信息的格式和含义</li>
<li>HTTP协议的特点
<ul>
<li>URL资源识别</li>
<li>请求-响应方式</li>
<li><strong>无状态性</strong></li>
<li>携带元数据</li>
</ul>
</li>
<li>HTTP的连接方式
<ul>
<li>传统方式</li>
<li>持久连接方式</li>
<li>管线化方式</li>
</ul>
</li>
<li>HTTP的协议头
<ul>
<li>请求头</li>
<li>响应头</li>
</ul>
</li>
<li>HTTP的请求方式
<ul>
<li>HEAD</li>
<li><strong>GET</strong></li>
<li><strong>POST</strong></li>
<li><strong>PUT</strong></li>
<li>DELETE</li>
<li>CONNECT</li>
<li>OPTIONS</li>
<li>TRACE</li>
</ul>
</li>
<li>HTTP的响应代码
<ul>
<li>信息1xx
<ul>
<li>表明服务端接收了客户端请求，客户端继续发送请求</li>
</ul>
</li>
<li>成功2xx
<ul>
<li>客户端发送的请求被服务端成功接收并成功进行了处理</li>
</ul>
</li>
<li>重定向3xx
<ul>
<li>服务端给客户端返回用于重定向的信息</li>
</ul>
</li>
<li>客户端错误4x
<ul>
<li>客户端的请求有非法内容</li>
</ul>
</li>
<li>服务器错误5xx
<ul>
<li>服务端未能正常处理客户端的请求而出现意外错误</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Web缓存和Web代理
<ul>
<li>WEB缓存
<ul>
<li>HTTP协议定义了客户端缓存机制</li>
<li>架设Web缓存服务器和内容分发网络（CDN）可以加快客户端访问</li>
</ul>
</li>
<li>WEB代理
<ul>
<li>同时扮演者客户和服务器的双重身份
<ul>
<li>对于Web客户来说是服务器</li>
<li>对于Web服务器来说是客户</li>
</ul>
</li>
<li>还可以过滤不希望的Web请求，实现高速缓存</li>
</ul>
</li>
</ul>
</li>
<li>Cookie和 Session机制
<ul>
<li>HTTP是一个无状态协议，因此当Web服务器将Web客户请求的响应发送出去后，服务器便
不必保存任何信息了。</li>
<li>Web服务器可以指示Web客户以存储Cookie的方式在一系列请求和响应之间维持状态，而服务器端则采用 Session机制保持状态</li>
</ul>
</li>
<li>Web内容的构建组件
<ul>
<li>使用HTML/XHTML、CSS、Javascript构建静态Web页面</li>
<li>使用CGI、PHP、Python、Ruby、Java、Servlet、Node.js等技术构建动态Web应用</li>
<li>使用各种数据发布格式及语言（XML、YAML、JSON、RSS/Atom）交换数据</li>
</ul>
</li>
</ul>
<h3 id="linux下常用的web服务器"> Linux下常用的Web服务器</h3>
<ul>
<li>Apache</li>
<li>Nginx</li>
<li>Lighttpd</li>
</ul>
<h2 id="apache"> Apache</h2>
<h3 id="安装与启动"> 安装与启动</h3>
<ul>
<li><code>yum install httpd httpd-tools httpd-manual</code>安装</li>
<li><code>systemctl start httpd</code>启动</li>
<li>网页打开失败大部分是防火墙导致，具体参考下面关闭防火墙或允许http服务规则</li>
</ul>
<h3 id="配置"> 配置</h3>
<ul>
<li><code>/etc/httpd/conf/httpd.conf</code>httpd服务的配置文件</li>
<li><code>/var/www/html/index.html</code>可以在这个路径下创建html文件替换掉默认网站</li>
</ul>
<h3 id="虚拟主机"> 虚拟主机</h3>
<ul>
<li>若要创建不同的虚拟主机，使用不同的<code>ip、port、servername</code>即可</li>
</ul>
<h3 id="使用不同的主机名端口等配置"> 使用不同的主机名端口等配置</h3>
<p>先创建对应的目录，建议在<code>/var/www/</code>这个目录下，假设这里需要使用<code>bit.com</code>作为主机名</p>
<h4 id="先配置html文件"> 先配置html文件</h4>
<ul>
<li>
<p><code>mkdir bit.com</code>在<code>/var/www/</code>目录下创建文件夹<code>bit.com</code></p>
</li>
<li>
<p>然后在里面再创一个文件：<code>touch index.html</code>这里只是单纯测试所以只需要在里面随便放一些文字即可</p>
</li>
<li>
<p>我这里只是想测试所以只放了一些文字：</p>
<div><pre><code>This is www.bit.com!
</code></pre>
<div><span>1</span><br></div></div></li>
</ul>
<h4 id="配置httpd服务配置文件"> 配置httpd服务配置文件</h4>
<ul>
<li>
<p><code>vim /etc/httpd/conf/httpd.conf</code>修改添加了端口记得去linux安全设置里面允许端口通过，可参考</p>
<div><pre><code>...
# 可以直接使用这个命令添加不同端口访问
Listen 81
# 也可以添加不同IP和端口访问
Listen 192.168.3.199:85
# 创建一个虚拟主机名
&lt;VirtualHost 192.168.3.105:80&gt;
	DocumentRoot &quot;/var/www/bit.com&quot;
	ServerName www.bit.com
&lt;/VirtualHost&gt;
# 也可以配置多个，ip和端口也都可以修改
&lt;VirtualHost 192.168.3.106:81&gt;
	DocumentRoot &quot;/var/www/bit.xyz&quot;
	ServerName www.bit.xyz
&lt;/VirtualHost&gt;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div></li>
</ul>
<h4 id="启动apache服务"> 启动apache服务</h4>
<ul>
<li><code>systemctl start httpd</code>启动后去浏览器中查看，若无法打开可能是防火墙未允许通过或配置有误</li>
</ul>
<h2 id="nginx"> Nginx</h2>
<ul>
<li>nginx小巧，功能强大，有逐渐占Apache的趋势</li>
<li><code>/usr/share/nginx/html/index.html</code>nginx的默认html文件在这里</li>
</ul>
<h3 id="创建repo库文件"> 创建repo库文件</h3>
<p>，因为Linux系统一般不自带Nginx，所以需要手动添加库文件以便下载或更新Nginx</p>
<ul>
<li><code>touch /etc/yum.repos.d/nginx.repo</code>新建repo文件，名字可随意</li>
<li>在<a href="http://nginx.org/en/linux_packages.html#RHEL-CentOS" target="_blank" rel="noopener noreferrer">官网</a>中选择<code>RHEL-CentOS</code>，或者直接复制下面repo信息然后粘贴到：<code>vim nginx.repo</code></li>
</ul>
<div><pre><code>[nginx-stable]
name=nginx stable repo
baseurl=http://nginx.org/packages/centos/$releasever/$basearch/
gpgcheck=1
enabled=1
gpgkey=https://nginx.org/keys/nginx_signing.key
module_hotfixes=true

[nginx-mainline]
name=nginx mainline repo
baseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/
gpgcheck=1
enabled=0
gpgkey=https://nginx.org/keys/nginx_signing.key
module_hotfixes=true
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="安装启动测试"> 安装启动测试</h3>
<ul>
<li><code>yum install nginx -y</code>当repo库保存好了之后就可以使用这个命令安装</li>
<li><code>rpm -ql nginx</code>查看nginx文件</li>
<li><code>systemctl start nginx</code>测试nginx服务是否能正常启动，此时可以在浏览器中输入centos的ip地址查看，若不能正常打开可能是防火墙未允许或者nginx的配置有误</li>
</ul>
<h3 id="配置nginx"> 配置nginx</h3>
<ul>
<li>
<p>添加配置html文件</p>
<ul>
<li><code>mkdir /var/www/bit.com</code>与apache一样添加一个文件夹并创建一个<code>index.html</code>文件</li>
<li><code>vim var/www/bit.com/index.html</code>仅测试所以随便添加内容即可，我在里面输入的是<code>This is www.bit.com</code></li>
</ul>
</li>
<li>
<p><code>/etc/nginx/conf.d/default.d</code>编辑默认网站配置</p>
<ul>
<li>
<p>配置文件</p>
<div><pre><code>... 
# 一个server就是一个网站
server{
	listen	192.168.3.106:80;
	server_name	www.bit.com;
	root	/var/www/bit.com;
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
<li>
<p>如果需要不同IP或端口可以修改listen后的参数，例如：<code>listen 192.168.3.199:85;</code></p>
</li>
<li>
<p>如果需要修改不同的域名可以在server_name后修改参数，如：<code>server_name www.bit.xyz;</code></p>
</li>
<li>
<p>记得<code>/var/www/bit.com</code>目录下需要拥有一个<code>index.html</code>文件</p>
</li>
</ul>
</li>
</ul>
<h3 id="重启nginx测试"> 重启nginx测试</h3>
<p>由于上面已经开启了nginx服务所以这里重启一次</p>
<ul>
<li><code>systemctl restart nginx</code>重启nginx服务</li>
<li>此时192.168.3.105是nginx的默认站点,192.168.3.106是我自己的<code>www.bit.com</code>站点</li>
<li>打开浏览器输入<code>192.168.3.106</code>
<ul>
<li>或修改dns或修改hosts文件再输入<code>www.bit.com</code></li>
</ul>
</li>
</ul>
<h2 id="tomcat"> Tomcat</h2>
<p>Tomcat也是一直web服务器，但他是需要配合java使用，也可以<a href="https://blog.csdn.net/wohiusdashi/article/details/81147059" target="_blank" rel="noopener noreferrer">参考这里</a></p>
<h3 id="安装-4"> 安装</h3>
<ul>
<li>
<p>先打开<a href="https://tomcat.apache.org/" target="_blank" rel="noopener noreferrer">官网</a>，在左侧可以选择对应的版本，我选择的是Tomcat 9.你也可以直接<a href="https://tomcat.apache.org/download-90.cgi" target="_blank" rel="noopener noreferrer">点我</a>直接到达tomcat 9的下载页面，下滑找到<code>Core</code>下的<code>tar.gz</code>链接将其下载下来<img src="./images/linux_notes/image-20200517163813753.png" alt="image-20200517163813753" /></p>
</li>
<li>
<p>在命令行中对其进行解压</p>
<div><pre><code><span>[</span>root@centos 下载<span>]</span><span># ls</span>
apache-tomcat-9.0.35.tar.gz
<span>[</span>root@centos 下载<span>]</span><span># tar -zx -f apache-tomcat-9.0.35.tar.gz </span>
<span>[</span>root@centos 下载<span>]</span><span># mv apache-tomcat-9.0.35 tomcat</span>
<span>[</span>root@centos 下载<span>]</span><span># ls</span>
apache-tomcat-9.0.35.tar.gz  tomcat
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
</ul>
<h3 id="启用服务"> 启用服务</h3>
<div><pre><code><span>[</span>root@centos 下载<span>]</span><span># tomcat/bin/startup.sh </span>
Using CATALINA_BASE:   /root/下载/tomcat
Using CATALINA_HOME:   /root/下载/tomcat
Using CATALINA_TMPDIR: /root/下载/tomcat/temp
Using JRE_HOME:        /usr
Using CLASSPATH:       /root/下载/tomcat/bin/bootstrap.jar:/root/下载/tomcat/bin/tomcat-juli.jar
Tomcat started.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>此时去浏览器中输入<code>localhost:8080</code>即可发现服务已启用成功！</p>
<h1 id="数据库"> 数据库</h1>
<p>目前MariaDB等同于MySQL，由于MariaDB有逐渐上升的趋势，且MySQL有弱化的趋势，所以这里只叙述MariaDB，其他部分涉及到SQL语句这里也不叙述</p>
<h2 id="mariadb"> MariaDB</h2>
<h3 id="安装-5"> 安装</h3>
<p><code>yum install mariadb-server</code>安装MariaDB</p>
<h3 id="启动"> 启动</h3>
<p><code>systemctl start mariadb</code>启动mariaDB服务</p>
<h3 id="初始化"> 初始化</h3>
<ul>
<li><code>mysql_secure_installation</code>初始化数据库
<ul>
<li>一开始会询问是否设置数据库root的密码，回车确认</li>
<li><code>Set root password? [Y/n]</code>是否设置root密码，推荐y
<ul>
<li><code>New password:</code>之后会让你输入密码</li>
</ul>
</li>
<li><code>Disallow root login remotely? [Y/n]</code>是否不允许root用户远程登录，推荐n</li>
<li><code>Remove anonymous users? [Y/n]</code>移除anonymous用户，推荐y</li>
<li><code>Remove test database and access to it? [Y/n]</code>是否要移除测试数据库</li>
<li><code>Reload privilege tables now? [Y/n]</code>是否要重启以生效刚刚的设置</li>
</ul>
</li>
</ul>
<h3 id="访问测试"> 访问测试</h3>
<ul>
<li><code>mysql -u root -p</code>后面会让你输入密码，这里输入你上面设置的密码即可</li>
<li><code>flush privileges</code>刷新数据库</li>
</ul>
<h3 id="外部访问"> 外部访问</h3>
<p>参考：https://www.cnblogs.com/mapu/p/9184212.html</p>
<ul>
<li><code>firewall-cmd --add-service=mysql</code>外部访问，首先第一步需要允许防火墙通过3306或mysql服务，如果你需要永久允许通过可以在后面添加<code>--permanent</code></li>
<li>对于外部访问的工具，你可以使用<code>Navicat</code>、<code>MYSQL-Front</code>等工具...</li>
<li>外部访问最主要的是用户，指定<code>用户</code>、<code>IP</code>、<code>所访问的数据库</code>等</li>
</ul>
<h4 id="指定用户通过-指定ip-访问-所有-的数据库"> 指定用户通过“指定IP”访问“所有”的数据库</h4>
<ul>
<li><code>grant all privileges on *.* to &quot;root&quot;@&quot;192.168.1.99&quot; identified by &quot;password&quot;;</code>
<ul>
<li><code>on *.*</code>表示允许访问任意数据库</li>
<li><code>to &quot;root&quot;@&quot;192.168.1.99&quot;</code>表示指定用户<code>root</code>只能被<code>192.168.1.99</code>这个IP的主机访问数据库</li>
<li><code>by &quot;password&quot;</code>表示需要通过passowrd这个密码访问</li>
</ul>
</li>
</ul>
<h4 id="指定用户通过-任何ip-访问-指定-的数据库"> 指定用户通过“任何ip”访问“指定”的数据库</h4>
<ul>
<li><code>grant all privileges on bit.* to &quot;bit&quot;@&quot;%&quot; identified by &quot;password&quot; with grant option;</code>
<ul>
<li><code>on bit.*</code>表示允许访问bit这个数据库下的任意数据表</li>
<li><code>to &quot;bit&quot;@&quot;%&quot;</code>表示指定用户<code>bit</code>可以被任意IP的主机访问数据库</li>
<li><code>by &quot;password&quot;</code>表示需要通过passowrd这个密码访问</li>
</ul>
</li>
</ul>
<h1 id="linux安全"> Linux安全</h1>
<h2 id="防火墙-firewall"> 防火墙 firewall</h2>
<p>一般真机中为了安全起见建议不要直接关闭，后果自负</p>
<h3 id="常用命令-2"> 常用命令</h3>
<h4 id="服务-2"> 服务</h4>
<ul>
<li><code>firewall-cmd -add-service=http 添加</code></li>
<li><code>firewall-cmd --remove-service=http 删除</code></li>
<li>若要永久保存（持久化）后面加上 <code>--permanent</code>
<ul>
<li><code>firewall-cmd --reload</code>重新载入防火墙配置</li>
</ul>
</li>
</ul>
<h4 id="端口"> 端口</h4>
<ul>
<li>
<p><code>firewall-cmd -add-port=3306/tcp 添加</code>，也可以将tcp改为udp</p>
</li>
<li>
<p><code>firewall-cmd --remove-service=3306/tcp 删除</code>，也可以将tcp改为udp</p>
</li>
<li>
<p>若要永久保存（持久化）后面加上 <code>--permanent</code></p>
</li>
<li>
<p>重新加载防火墙策略：<code>systemctl reload firewalld</code></p>
</li>
</ul>
<h3 id="详细"> 详细</h3>
<ul>
<li>防火墙在运行的时候会有两种配置模式，Runtime Mode(当前运行模式)和Permanent Mode(永久模式)，Runtime mode只会在当前运行的时候生效，重启后失效，Permanent mode则是在每次重启时生效，立刻添加不会立刻生效(写如文件)</li>
</ul>
<h4 id="查看-2"> 查看</h4>
<ul>
<li><code>firewall-cmd --get-default-zone</code>查看当前的默认区域</li>
<li><code>firewall-cmd --get-zone</code>查看所有可使用区域</li>
<li><code>firewall-cmd --get-services</code>查看当前系统可用服务，可以添加到防火墙</li>
<li><code>firewall-cmd --list-services</code>当前区域可使用的服务，已经添加到服务器</li>
<li><code>firewall-cmd --list-all</code>当前区域所有信息</li>
<li><code>firewall-cmd --add-service=vnc-server</code>添加服务</li>
<li><code>firewall-cmd --list-port</code>查看开放的端口</li>
<li><code>firewall-cmd --reload</code>重新载入防火墙配置</li>
</ul>
<h4 id="添加到永久模式"> 添加到永久模式</h4>
<ul>
<li><code>firewall -cmd --add-service=http --permanent</code>将http写入永久模式</li>
<li><code>systemctl restart firewalld</code>需要重启一次才会启动http防火墙配置</li>
</ul>
<h4 id="添加指定端口-永久模式"> 添加指定端口-永久模式</h4>
<ul>
<li><code>firewall-cmd --add-port=3306/tcp --permanent</code>添加允许端口到永久默认</li>
</ul>
<h4 id="删除指定服务"> 删除指定服务</h4>
<ul>
<li><code>firewall-cmd --remove-service=http</code>删除http服务</li>
</ul>
<h2 id="selinux"> SELinux</h2>
<h3 id="概念-6"> 概念</h3>
<p>SELinux 主要作用就是最大限度地减小系统中服务进程可访问的资源（最小权限原则）<a href="https://www.phpyuan.com/235739.html" target="_blank" rel="noopener noreferrer">可参考</a></p>
<ul>
<li>其他程序之外增加的安全机制，Linux系统中会默认安装，所有的程序都会受到SELinux限制，所以即使当http服务受到了控制也不会影响系统</li>
<li>根目录：<code>/etc/selinux/</code></li>
<li>配置文件：<code>/etc/selinux/config</code></li>
</ul>
<h4 id="mac"> Mac</h4>
<p>MAC（Mandatory Access Control）强制访问控制</p>
<ul>
<li>在使用了 SELinux 的操作系统中，决定一个资源是否能被访问的因素除了上述因素之外，还需要判断每一类进程是否拥有对某一类资源的访问权限。</li>
<li>这样一来，即使进程是以 root 身份运行的，也需要判断这个进程的类型以及允许访问的资源类型才能决定是否允许访问某个资源。进程的活动空间也可以被压缩到最小。</li>
<li>即使是以 root 身份运行的服务进程，一般也只能访问到它所需要的资源。即使程序出了漏洞，影响范围也只有在其允许访问的资源范围内。安全性大大增加。</li>
<li>这种权限管理机制的主体是进程，也称为强制访问控制（MAC）。</li>
<li>而 MAC 又细分为了两种方式，一种叫类别安全（MCS）模式，另一种叫多级安全（MLS）模式。</li>
</ul>
<h4 id="dac"> DAC</h4>
<p>DAC（Discretionary Access Control）自主访问控制</p>
<ul>
<li>在没有使用 SELinux 的操作系统中，决定一个资源是否能被访问的因素是：某个资源是否拥有对应用户的权限（读、写、执行）。</li>
<li>只要访问这个资源的进程符合以上的条件就可以被访问。</li>
<li>而最致命问题是，root 用户不受任何管制，系统上任何资源都可以无限制地访问。</li>
<li>这种权限管理机制的主体是用户，也称为自主访问控制（DAC）。</li>
</ul>
<h4 id="mac和dac的对比"> MAC和DAC的对比</h4>
<p>可以看到，在 DAC 模式下，只要相应目录有相应用户的权限，就可以被访问。而在 MAC 模式下，还要受进程允许访问目录范围的限制。</p>
<p><img src="./images/linux_notes/image-20200514120855496.png" alt="image-20200514120855496" /></p>
<h4 id="selinux的基本概念"> SELinux的基本概念</h4>
<ul>
<li>
<p>主体（Subject）</p>
<ul>
<li>可以完全等同于<strong>进程</strong>（注：为了方便理解，如无特别说明，以下均把<strong>进程</strong>视为主体。）</li>
</ul>
</li>
<li>
<p>对象（Object）</p>
</li>
<li>
<p>被主体访问的<strong>资源</strong>。可以是文件、目录、端口、设备等。（注：为了方便理解，如无特别说明，以下均把<strong>文件或者目录</strong>视为对象。）</p>
</li>
<li>
<p>政策和规则（Policy &amp; Rule）</p>
<ul>
<li>
<p>系统中通常有大量的文件和进程，为了节省时间和开销，通常我们只是<strong>选择性</strong>地对某些进程进行管制。</p>
<p>而哪些进程需要管制、要怎么管制是由政策决定的。</p>
<p>一套政策里面有多个规则。部分规则可以按照需求启用或禁用（以下把该类型的规则称为<strong>布尔型</strong>规则）。</p>
<p>规则是<strong>模块化、可扩展</strong>的。在安装新的应用程序时，应用程序可通过添加新的模块来添加规则。用户也可以手动地增减规则。</p>
<p>在 CentOS 7 系统中，有三套政策，分别是：</p>
<ol>
<li>
<p>targeted：对大部分网络服务进程进行管制。这是系统<strong>默认使用</strong>的政策（下文均使用此政策）。</p>
</li>
<li>
<p>minimum：以 targeted 为基础，仅对选定的网络服务进程进行管制。一般不用。</p>
</li>
<li>
<p>mls：多级安全保护。对所有的进程进行管制。这是最严格的政策，配置难度非常大。一般不用，除非对安全性有极高的要求。</p>
</li>
</ol>
<p>政策可以在 /etc/selinux/config 中设定。</p>
</li>
</ul>
</li>
<li>
<p>安全上下文（Security Context）</p>
<ul>
<li>
<p>安全上下文是 SELinux 的<strong>核心</strong>。</p>
<p>安全上下文我自己把它分为「进程安全上下文」和「文件安全上下文」。<strong>一个</strong>「进程安全上下文」一般对应<strong>多个</strong>「文件安全上下文」。**只有两者的安全上下文对应上了，进程才能访问文件。**它们的对应关系由政策中的规则决定。</p>
</li>
<li>
<p>文件安全上下文由<strong>文件创建的位置和创建文件的进程所决定</strong>。而且系统有一套默认值，用户也可以对默认值进行设定。需要注意的是，单纯的<strong>移动文件</strong>操作并<strong>不会</strong>改变文件的安全上下文。</p>
</li>
<li>
<p><strong>安全上下文的结构及含义</strong></p>
<p>安全上下文有四个字段，分别用冒号隔开。形如：system_u:object_r:admin_home_t:s0</p>
<p><img src="./images/linux_notes/image-20200514121600685.png" alt="image-20200514121600685" /></p>
</li>
</ul>
</li>
</ul>
<h4 id="selinux的三种工作模式"> SELinux的三种工作模式</h4>
<ul>
<li><code>enforcing</code>强制模式，selinux彻底检查，保护linux的安全</li>
<li><code>permissive</code>宽容模式，selinux不执行，但只记录</li>
<li><code>disabled</code>关闭模式，关闭selinux</li>
</ul>
<p>SELinux 工作模式可以在 /etc/selinux/config 中设定。</p>
<p>如果想从 disabled 切换到 enforcing 或者 permissive 的话，需要<strong>重启系统</strong>。反过来也一样。需要注意的是，如果系统已经在关闭 SELinux 的状态下运行了一段时间，在打开 SELinux 之后的第一次重启速度可能会比较慢。因为系统必须为磁盘中的文件<strong>创建安全上下文</strong>（原作者表示重启了大约10分钟），SELinux 日志的记录需要借助 auditd.service 这个服务，请<strong>不要禁用</strong>它。</p>
<h4 id="selinux工作流程"> SELinux工作流程</h4>
<p><img src="./images/linux_notes/image-20200514121635844.png" alt="image-20200514121635844" /></p>
<h3 id="动手-3"> 动手</h3>
<h4 id="查看状态"> 查看状态</h4>
<ul>
<li><code>getenforce</code>查看SELinux当前运行的工作模式</li>
<li><code>sestatus</code>详细的SELinux当前运行的工作状态</li>
<li><code>getsebool -a</code>查看系统服务是否允许的布尔值<code>on/off</code>，-a是所有的
<ul>
<li><code>setsebool ftpd_anon_write=on</code>临时设定为开启</li>
<li><code>setsebool ftpd_full_access=1</code>临时设定为开启</li>
<li><code>setsebool ftpd_anon_write=on -P</code>永久有效</li>
<li><code>ftp_home_dir</code>（centos7/redhat没有）由于没有用处所以官方将其取消</li>
</ul>
</li>
</ul>
<h4 id="改变状态"> 改变状态</h4>
<p>一般真机中为了安全起见建议不要直接关闭，后果自负，有时候服务不能访问，有可能是防火墙也有可能是SELinux的问题，在保证安全的情况下暂时关闭测试是否因为他们所导致，如果是则需要对其进行设置</p>
<ul>
<li><code>setenforce 0</code>临时关闭SELinux的状态，变成permissive状态</li>
<li><code>setenforce 1</code>临时开启SELinux的状态，变成enforcing状态</li>
</ul>
<h4 id="对服务端口"> 对服务端口</h4>
<h5 id="添加"> 添加</h5>
<p><code>semanage port -a -t http_port_t -p tcp 12345</code>对htttp服务添加端口</p>
<h5 id="删除"> 删除</h5>
<p><code>semanage port -d -t http_port_t -p tcp 12345</code>对http服务删除端口</p>
<h4 id="types类型"> Types类型</h4>
<h5 id="查看进程的安全上下文"> 查看进程的安全上下文</h5>
<p><code>ps auxZ | grep -v grep | grep http</code></p>
<h5 id="查看文件或文件夹类型"> 查看文件或文件夹类型</h5>
<p><code>ls -Z</code>可以查看当前文件夹下的Types类型</p>
<h4 id="改变文件或文件夹类型"> 改变文件或文件夹类型</h4>
<p><code>chcon -R -t htpd_sys_content_y /mydir/</code>改变文件夹<code>mydir</code>的types类型</p>
<h5 id="示例"> 示例</h5>
<p>除了防火墙上默认允许http开放的80等端口，其他端口SELinux都会对其进行管制，如果我要http添加83端口，因为其中默认不包含83，所以需要在SELinux上添加此端口外部才能访问，若是单独在防火墙中进行添加也无法访问</p>
<ul>
<li><code>semanage port -l |grep -w http_port_t</code>查看http默认允许的端口</li>
<li>这里以http为例子，若在httpd.conf文件中添加<code>listen 83</code>，如果我没有在SELinux中添加，则无法启动httpd服务，因为SELinux会为了安全拒绝，可以用下面这条命令对其放行
<ul>
<li><code>semanage port -a -t http_port_t -p tcp 83</code>在SELinux中放行83端口给http</li>
<li><code>firewall-cmd --add-port=83/tcp</code>如果防火墙中没有允许83端口通过，那就需要在防火墙中添加端口</li>
</ul>
</li>
</ul>
<h2 id="上下文"> 上下文</h2>
<ul>
<li>ls -Z`显示上下文
<ul>
<li>用户 角色 类型</li>
<li><code>public_content_t</code></li>
<li><code>public_content_rw_t</code></li>
</ul>
</li>
<li><code>chcon</code>改变上下文
<ul>
<li><code>chcon -R -t public_content_t filename</code>更改文件的上下文为<code>public_content_t</code></li>
<li><code>chcon --reference=/var/www/html filename</code>改变文件夹的上下文，参考自文件夹html的上下文</li>
</ul>
</li>
</ul>
<h1 id="ftp"> FTP</h1>
<p><a href="https://blog.csdn.net/qq_39228620/article/details/102727606" target="_blank" rel="noopener noreferrer">FTP，TFTP， SFTP，FTPS总结和对比</a></p>
<h2 id="概念-7"> 概念</h2>
<ul>
<li>类型
<ul>
<li>tftp 简单文件传输协议 UDP
<ul>
<li>TFTP是TCP/IP协议族中在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为69。</li>
<li>优势
<ol>
<li>TFTP能够用于那些有UDP而无TCP的环境</li>
<li>TFTP代码所占的内存要比FTP小</li>
</ol>
</li>
</ul>
</li>
<li>ftp
<ul>
<li>FTP是在网络层传输文件的应用层协议，基于TCP连接，使用客户/服务器模式。
对于ftp服务器来说，常用的端口有两个，一个是tcp端口21，此端口经常用于连接，另一个是tcp端口号20， 此端口经常用于传输数据。</li>
</ul>
</li>
<li>SFTP与FTPS
<ul>
<li>SFTP（SSH 文件传输协议SSH File transfer protocol）也称为通过安全套接层的文件传输协议File Transfer protocol via Secure Socket Layer， 以及 FTPS（FTP-SSL） 都是最常见的安全 FTP 通信技术，用于通过 TCP 协议将计算机文件从一个主机传输到另一个主机。SFTP 和 FTPS 都提供高级别文件传输安全保护，通过强大的算法（如 AES 和 Triple DES）来加密传输的数据。当你在FTP服务器上收发文件的时候，你面临两个风险。第一个风险是在上载文件的时候为文件加密。第二个风险是，这些文件在你等待接收方下载的时候将停留在FTP服务器上，这时你如何保证这些文件的安全。一个选择是创建一个支持SSL的FTP服务器，它能够让你的主机使用一个FTPS连接上载这些文件。这包括使用一个在FTP协议下面的SSL层加密控制和数据通道。一种替代FTPS的协议是安全文件传输协议(SFTP)。这个协议使用SSH文件传输协议加密从客户机到服务器的FTP连接。</li>
</ul>
</li>
<li>sftp
<ul>
<li>sftp是Secure File Transfer Protocol的缩写，安全文件传送协议。可以为传输文件提供一种安全的加密方法。sftp 与 ftp 有着几乎一样的语法和功能。SFTP 为 SSH的一部分，是一种传输档案至 Blogger 伺服器的安全方式。其实在SSH软件包中，已经包含了一个叫作SFTP(Secure File Transfer Protocol)的安全文件传输子系统，SFTP本身没有单独的守护进程，它必须使用sshd守护进程（端口号默认是22）来完成相应的连接操作，所以从某种意义上来说，SFTP并不像一个服务器程序，而更像是一个客户端程序。SFTP同样是使用加密传输认证信息和传输的数据，所以，使用SFTP是非常安全的。但是，由于这种传输方式使用了加密/解密技术，所以传输效率比普通的FTP要低得多，如果您对网络安全性要求更高时，可以使用SFTP代替FTP。</li>
<li>SFTP 或 SSH 文件传输协议是另一种安全的安全文件传输协议，设计为 SSH 扩展以提供文件传输功能，因此它通常仅使用 SSH 端口用于数据传输和控制。当 FTP 客户端软件连接到 SFTP 服务器时，它会将公钥传输到服务器进行认证。如果密钥匹配，提供任何用户/密码，身份验证就会成功。</li>
</ul>
</li>
<li>ftps (ftp over ssh)
<ul>
<li>FTPS也称作“FTP-SSL”和“FTP-over-SSL”，是一种多传输协议，相当于加密版的FTP。默认端口号是21。FTPS是在安全套接层使用标准的FTP协议和指令的一种增强型FTP协议，为FTP协议和数据通道增加了SSL安全功能。SSL是一个在客户机和具有SSL功能的服务器之间的安全连接中对数据进行加密和解密的协议。</li>
<li>FTPS最常见的问题之一是建立数据传输连接。在FTPS中，数据通过单独的通道（不同于发起命令的主通道，DATA）传输。 这意味着每次列出目录或上传/下载文件时都会建立新连接。</li>
</ul>
</li>
</ul>
</li>
<li>ftp有两种模式
<ul>
<li>主动</li>
<li>被动</li>
</ul>
</li>
</ul>
<h2 id="配置-2"> 配置</h2>
<h3 id="安装-6"> 安装</h3>
<ul>
<li><code>yum install vsftpd</code>安装vsftp服务</li>
<li><code>rpm -ql vsftpd</code></li>
</ul>
<h3 id="配置开机启动"> 配置开机启动</h3>
<ul>
<li><code>systemctl enable vsftpd</code>设置开机自启</li>
<li><code>systemctl is-enabled vsftpd</code>查询是否开机启动</li>
</ul>
<h3 id="配置文件"> 配置文件</h3>
<ul>
<li><code>vim /etc/vsftpd/vsftpd.conf</code>配置vsftpd配置文件</li>
<li><code>grep -v &quot;^#&quot; vsftpd.conf</code>查看vsftpd.conf的有效配置</li>
<li>vsftp是通过<code>/etc/pam.d/vsftpd</code>这个文件来身份验证，同时是在<code>/etc/vsftpd/vsftpd.conf</code>文件中的末尾<code>pam_serice_name=vsftpd</code>来指向身份验证文件</li>
</ul>
<h3 id="启动-2"> 启动</h3>
<p><code>systemctl start vsftpd</code>启动vsftpd</p>
<h3 id="访问"> 访问</h3>
<h4 id="匿名账户"> 匿名账户</h4>
<p>如果需要登录匿名账户，则需要在<code>vsftpd.conf</code>文件中更改允许匿名选项：<code>anonymous_enable=YES</code>，记得重启一次vsftpd服务，不输入任何东西则系统ftp会默认填充anonymous，但命令行一定要输入，一般只能下载不能上传</p>
<ol>
<li>账户名：<code>anonymous</code>，密码：空(不输入)或者邮件地址</li>
<li>账户名：<code>ftp</code>，密码：<code>ftp</code></li>
</ol>
<ul>
<li>
<p>如果需要匿名用户写入需要开启SELinux的<code>ftpd_anon_write</code>和<code>ftpd_full_access</code></p>
</li>
<li>
<p><code>setsebool ftpd_anon_write=on</code>临时设定为开启，允许匿名用户读写</p>
</li>
<li>
<p><code>setsebool ftpd_full_access=1</code>临时设定为开启，取消对本地虚拟用户的限制</p>
</li>
<li>
<p><code>setsebool ftpd_anon_write=on -P</code>永久有效</p>
</li>
<li>
<p><code>ftp_home_dir</code>（centos7/redhat没有）由于没有用处所以官方将其取消</p>
</li>
<li>
<p>如果出现<code>登录失败: 500 OOPS: vsftpd: refusing to run with writable root inside chroot()</code>，需要在vsftp的配置文件中添加一条命令</p>
<ul>
<li>
<p><code>vim /etc/vsftpd/vsftpd.conf</code>编辑配置文件</p>
<div><pre><code>allow_writeable_chroot=YES
</code></pre>
<div><span>1</span><br></div></div></li>
</ul>
</li>
</ul>
<h4 id="本地用户"> 本地用户</h4>
<p>我们可以在FTP上使用系统本地用户进行登录访问，如果账户没有限制在自己的家目录内（chroot），则这种方法不安全，因为可以直接跳转到其他根目录去，几乎能看到任何文件夹</p>
<h4 id="防火墙"> 防火墙</h4>
<ul>
<li><code>firewall-cmd --add-service=ftp</code>配置防火墙允许ftp通过</li>
<li><code>firewall-cmd --add-service=ftp --permanent</code>配置永久允许防火墙允许ftp通过
<ul>
<li><code>firewall-cmd --reload</code> 重新载入防火墙配置</li>
</ul>
</li>
</ul>
<h4 id="命令行"> 命令行</h4>
<ul>
<li>
<p><code>ftp 192.168.3.105</code>在windows的cmd中输入即可发起连接，如果需要使用匿名用户<code>anonymous</code>则需要修改ftp的根路径</p>
</li>
<li>
<p>之后会要求输入账号与密码，以下是输入成功样子：</p>
<div><pre><code>用户(192.168.3.105:(none)): bit
331 Please specify the password.
密码:
230 Login successful.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
<li>
<p>登录成功后就如同在centos的shell一样，输入命令即可：</p>
<div><pre><code>ftp<span>></span> <span>ls</span>
<span>200</span> PORT <span>command</span> successful. Consider using PASV.
<span>150</span> Here comes the directory listing.
下载
公共
图片
文档
桌面
模板
视频
音乐
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></li>
</ul>
<h4 id="工具"> 工具</h4>
<p>这里使用的工具是<code>FileZilla</code>，你也可以使用其他工具</p>
<h2 id="其他-4"> 其他</h2>
<h3 id="将本地用户限制在其家目录中"> 将本地用户限制在其家目录中</h3>
<p><a href="https://blog.csdn.net/u010433704/article/details/50831246" target="_blank" rel="noopener noreferrer">参考1</a> <a href="https://blog.csdn.net/bluishglc/article/details/42399439" target="_blank" rel="noopener noreferrer">参考2</a></p>
<ul>
<li>
<p>先新建用户</p>
<div><pre><code><span># 将vuser1文件目录放置在/vuser1中，这里将限制其在此</span>
<span>useradd</span> -d /vuser1 vuser1
<span>passwd</span> vuser1
<span># vuser2默认会在/home/vuser2中，这里将限制在此</span>
<span>useradd</span> vuser2
<span>passwd</span> vuser2
<span># vuser3也会在home目录里，但不做限制</span>
<span>useradd</span> vuser3
<span>passwd</span> vuser3
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></li>
<li>
<p><code>vim /etc/vsftpd/vsftpd.conf</code></p>
<div><pre><code>chroot_local_user=YES # YES为所有的人都限制，NO为所有人都不被限制
chroot_list_enable=YES
chroot_list_file=/etc/vsftpd/chroot_list 
allow_writeable_chroot=YES # 添加权限
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>
<li>可能上述可能模糊，这里拆分一下</li>
</ul>
<div><pre><code>chroot_local_user=YES # YES 为所有的用户都开启限制
chroot_list_enable=YES
chroot_list_file=/etc/vsftpd/chroot_list # 若此文件存在此文件内的用户名不会受到限制
--------------------------
chroot_local_user=NO # NO 不限制所有用户
chroot_list_enable=YES
chroot_list_file=/etc/vsftpd/chroot_list # 若此文件存在此文件内的用户名会受到限制
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
<li>
<p><code>firewall-cmd --add-service=ftp</code>后面在防火墙中允许其通过</p>
</li>
<li>
<p><code>setsebool ftpd_full_access=1</code>允许登入</p>
</li>
<li>
<p><code>setsebool ftpd_anon_write=1</code>允许写入</p>
<ul>
<li>如果测试过程中还是失败可以尝试将selinux暂时停止<code>setenforce 0</code>，也可以将防火墙临时关闭<code>systemctl stop firewalld</code></li>
</ul>
</li>
<li>
<p>测试，在另外一台机器上，可以是linux也可以是windows，这里以windows为例子，注：下面有将一些不必要的信息给去掉了</p>
<div><pre><code>C:\&gt;ftp 192.168.3.105
用户(192.168.3.105:(none)): vftp1
密码:
230 Login successful.
ftp&gt; mkdir vftp1
257 &quot;/vftp1&quot; created
ftp&gt; ls
linux1
vftp1
ftp&gt; quit
221 Goodbye.
C:\&gt;ftp 192.168.3.105
用户(192.168.3.105:(none)): vftp2
密码:
230 Login successful.
ftp&gt; ls
linux2
ftp&gt; mkdir vftp2
257 &quot;/vftp2&quot; created
ftp&gt; pwd
257 &quot;/&quot;
ftp&gt; quit
C:\&gt;ftp 192.168.3.105
用户(192.168.3.105:(none)): vuser3
密码:
230 Login successful.
ftp&gt; cd /
250 Directory successfully changed.
ftp&gt; ls
bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div></li>
</ul>
<h3 id="虚拟用户"> 虚拟用户</h3>
<p><a href="https://blog.51cto.com/13043516/2131033" target="_blank" rel="noopener noreferrer">参考</a></p>
<ul>
<li>
<p>使用linux中创建的用户登录可能会导致linux的安全问题，所以创建虚拟的用户相对会安全一点</p>
<ul>
<li><code>setsebool ftpd_anon_write=on</code>临时设定为开启，允许匿名用户读写</li>
<li><code>setsebool ftpd_full_access=1</code>临时设定为开启，取消对本地虚拟用户的限制</li>
</ul>
</li>
<li>
<p>先创建一个用户名、密码，明文的文件，将用户名和密码放入<code>vim ftpuser</code></p>
<div><pre><code>vuser1
12345678
vuser2
87654321
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
<li>
<p><code>db_load -T -t hash -f ftpuser /etc/vsftpd/vu.db</code>将<code>ftpuser</code>文件处理转换成数据库文件</p>
</li>
<li>
<p><code>chmod 600 vu.db</code>为了安全，更改权限防止其他用户读取更改</p>
</li>
<li>
<p><code>vim /etc/vsftpd/vsftpd.conf</code>编辑vsftp配置文件</p>
<div><pre><code>chroot_local_user=YES
chroot_list_enable=YES
# (default follows)
chroot_list_file=/etc/vsftpd/chroot_list
...
pam_service_name=vsftpd
# 在文件的末尾添加
guest_enable=YES
guest_username=vftp
user_config_dir=/etc/vsftpd/vuserconf
allow_writeable_chroot=YES
# 结束
userlist_enable=YES
tcp_wrappers=YES
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div></li>
<li>
<p><code>cp /etc/pam.d/vsftpd /etc/pam.d/vsftpd.copy</code>复制备份一个vsftpd文件</p>
</li>
<li>
<p><code>vim /etc/pam.d/vsftpd</code>编辑vsftpd文件</p>
<div><pre><code>#%PAM-1.0
auth    required        pam_userdb.so   db=/etc/vsftpd/vu
account required        pam_userdb.so   db=/etc/vsftpd/vu
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p>创建一个<code>vftp</code>用户</p>
<ul>
<li><code>useradd vftp</code></li>
<li><code>passwd vftp</code></li>
</ul>
</li>
<li>
<p><code>mkdir /etc/vsftpd/vuserconf</code>创建虚拟用户配置文件目录</p>
</li>
<li>
<p>配置虚拟用户的配置文件</p>
<ul>
<li>
<p><code>vim /etc/vsftpd/vuserconf/vftp1</code>这里只记录一个，有多少个用户就创建多少个虚拟用户配置文件</p>
</li>
<li>
<p>简单配置：</p>
<div><pre><code>local_root=/home/vftp1
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>详细配置：</p>
<div><pre><code># 设置虚拟用户的目录
local_root=/home/vftp1
# 设置虚拟用户是否可以写入
write_enable=YES
local_umask=022
anon_world_readable_only=NO
# 允许虚拟用户的上传功能
anon_upload_enable=YES
# 设置虚拟用户是否可以创建文件夹
anon_mkdir_write_enable=YES
# 设置虚拟用户是否可以知晓其他的写入操作，比如删除、重命、覆盖操作
anon_other_write_enable=YES
# 最多允许同意账号在10个不同的IP登录
max_per_ip=10
# 最大下载速度（字节/秒）
local_max_rate=2500000
# session超时时间
idle_session_timeout=600
# 连接超时时间
data_connection_timeout=120
# 最多连接数量
max_clients=10
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div></li>
<li>
<p><code>mkdir /home/vftp1</code>创建文件夹给vftp1这个用户作家目录</p>
</li>
<li>
<p><code>chmod 777 vftp</code>如果需要ftp在这个文件夹内操作可以使用这个命令（仅供测试）</p>
</li>
</ul>
</li>
<li>
<p><code>systemctl restart vsftpd</code>重启vsftpd服务</p>
</li>
<li>
<p>常见错误</p>
<ul>
<li>错误 ：500 OOPS: cannot change directory:/
<ul>
<li>权限问题 或者
<ol>
<li><code>setsebool ftpd_disable_trans 1</code></li>
<li><code>service vsftpd restart</code></li>
</ol>
</li>
</ul>
</li>
<li>错误：500 OOPS: unrecognised variable in config file: cal_root
<ul>
<li>大部分情况是复制的时候丢失了字符，应该是 local_root 回头去看看<code>vsftpd.conf</code>配置文件！</li>
</ul>
</li>
<li>错误：500 OOPS：could not read chroot() list file:/etc/Vsftpd/chroot_list
<ul>
<li>遇到这种情况是因为在<code>/etc/Vsftpd</code>目录下没有一个文件叫做<code>chroot_list</code>的文件，创建即可</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="多个虚拟ftp主机"> 多个虚拟FTP主机</h3>
<p><a href="https://blog.51cto.com/sunweiha/1612412" target="_blank" rel="noopener noreferrer">参考</a></p>
<ul>
<li>
<p><code>ifconfig ens33:0 192.168.3.107/24</code>添加一个虚拟IP</p>
</li>
<li>
<p><code>useradd -d /ftp2 ftp2</code>添加一个ftp2用户并设置其家目录为/ftp2</p>
</li>
<li>
<p><code>passwd ftp2</code>设置密码</p>
</li>
<li>
<p><code>cp /etc/vsfptd/vsftpd.conf /etc/vsftpd/vsftpd2.conf</code>将原有的vsftpd.conf配置文件复制一份用作于新的虚拟FTP</p>
</li>
<li>
<p><code>vim /etc/vsftpd/vsftpd.conf</code>配置原vsftpd.conf添加内容</p>
<div><pre><code>listen_address=192.168.3.105 #原本主机的IP
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p><code>vim /etc/vsftpd/vsftpd2.conf</code>配置新的vsftpd2.conf添加内容</p>
<div><pre><code>listen_address=192.168.3.107
ftp_username=ftp2
local_root=/var/ftp2
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p>测试，使用不同的IP进行测试即可</p>
</li>
<li>
<p>如果失败了请配置selinux与firewall服务，这里不再赘述</p>
</li>
</ul>
<h3 id="ftps"> FTPS</h3>
<p><a href="https://jingyan.baidu.com/article/6d704a1335695628db51ca20.html" target="_blank" rel="noopener noreferrer">参考</a></p>
<ul>
<li>
<p><code>yum install openssl</code>安装openssl</p>
</li>
<li>
<p><code>cd /etc/pki/tls/certs</code>切换目录进行密钥生成</p>
</li>
<li>
<p><code>make vsftpd.pem</code>生成证书密钥文件</p>
<ul>
<li>
<p>后面填写的资料可以随便填</p>
<div><pre><code>Country Name <span>(</span><span>2</span> letter code<span>)</span> <span>[</span>XX<span>]</span>:CN
State or Province Name <span>(</span>full name<span>)</span> <span>[</span><span>]</span>:SD
Locality Name <span>(</span>eg, city<span>)</span> <span>[</span>Default City<span>]</span>:XX
Organization Name <span>(</span>eg, company<span>)</span> <span>[</span>Default Company Ltd<span>]</span>:
Organizational Unit Name <span>(</span>eg, section<span>)</span> <span>[</span><span>]</span>:
Common Name <span>(</span>eg, your name or your server's <span>hostname</span><span>)</span> <span>[</span><span>]</span>:ftp.name.com
Email Address <span>[</span><span>]</span>:
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
</ul>
</li>
<li>
<p>编辑配置<code>vsftpd.conf</code>配置文件对其添加ssl加密参数</p>
<div><pre><code>ssl_enable=YES   #启用ssl加密
allow_anon_ssl=YES   #允许匿名用户使用ssl加密
force_local_data_ssl=YES     #强制本地用户数据传输加密
force_local_logins_ssl=YES   #强制本地用户登录加密
force_anon_logins_ssl=YES    #强制匿名用户登录加密
force_anon_data_ssl=YES  #强制匿名用户数据传输加密
ssl_tlsv1=YES    #支持TLS方式
ssl_sslv2=NO     
ssl_sslv3=NO     
rsa_cert_file=/etc/pki/tls/certs/vsftpd.pem      #RSA凭证档案所在
pasv_min_port=64000
pasv_max_port=64100
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div></li>
<li>
<p>配置selinux</p>
<ul>
<li><code>setsebool ftpd_full_access on</code></li>
<li>setsebool ftpd_use_passive_mode on</li>
</ul>
</li>
<li>
<p>配置防火墙</p>
<ul>
<li><code>firewall-cmd --add-port=64000-64100/tcp</code>允许指定端口的tcp连接</li>
<li><code>firewall-cmd --add-service=ftp</code> 允许ftp防火墙服务项通过</li>
</ul>
</li>
<li>
<p>测试，可在FileZilla等工具上测试</p>
</li>
<li>
<p>如果失败了请配置selinux与firewall服务，这里不再赘述</p>
</li>
</ul>
<h2 id="selinux与ftp"> SELinux与FTP</h2>
<ul>
<li>如何FTP服务配置使用中出现了问题可以从SELinux或防火墙中寻找问题
<ul>
<li>SELinux
<ul>
<li><code>getenforce</code>查看状态</li>
<li><code>setenforce 0</code>0关、1开，Permissive和Enforcing的切换</li>
<li><code>ftp_home_dir</code>（centos7/redhat没有）由于没有用处所以官方将其取消</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="lamp"> LAMP</h1>
<h2 id="概念-8"> 概念</h2>
<p>（Linux+Apache+MariaDB+PHP，开源黄金组合）</p>
<ul>
<li>LAMP是指一组通常一起使用来运行动态网站或者服务器的自由软件名称首字母缩写：
<ul>
<li>Linux，操作系统</li>
<li>Apache，网页服务器</li>
<li>MariaDB或MySQL，数据库管理系统（或者数据库服务器）</li>
<li>PHP、Perl或Python，脚本语言</li>
</ul>
</li>
<li>虽然这些开放源代码程序本身并不是专门设计成同另几个程序一起工作的，但由于它们的廉价和普遍，这个组合开始流行（大多数Linux发行版本捆绑了这些软件）。当一起使用的时候，它们表现的像一个具有活力的“解决方案包”（Solution Packages）。其他的方案包有苹果的WebObjects（最初是应用服务器），Java/J2EE和微软的.NET架构。</li>
<li>“LAMP包”的脚本组件中包括了CGIweb接口，它在90年代初期变得流行。这个技术允许网页浏览器的用户在服务器上执行一个程序，并且和接受静态的内容一样接受动态的内容。程序员使用脚本语言来创建这些程序因为它们能很容易有效的操作文本流，甚至当这些文本流并非源自程序自身时也是。正是由于这个原因系统设计者经常称这些脚本语言为胶水语言。</li>
</ul>
<h2 id="简易配置"> 简易配置</h2>
<ul>
<li>
<p>安装</p>
<ul>
<li><code>yum install httpd mariadb-server php-mysql php-gd libjpeg* php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-bcmath php-mhash</code></li>
</ul>
</li>
<li>
<p>启动</p>
<ul>
<li><code>systemctl start httpd mariadb</code></li>
</ul>
</li>
<li>
<p>初始化数据库</p>
<ul>
<li><code>mysql_secure_installation</code>初始化数据库
<ul>
<li>一开始会询问是否设置数据库root的密码，回车确认</li>
<li><code>Set root password? [Y/n]</code>是否设置root密码，推荐y
<ul>
<li><code>New password:</code>之后会让你输入密码</li>
</ul>
</li>
<li><code>Disallow root login remotely? [Y/n]</code>是否不允许root用户远程登录，推荐n</li>
<li><code>Remove anonymous users? [Y/n]</code>移除anonymous用户，推荐y</li>
<li><code>Remove test database and access to it? [Y/n]</code>是否要移除测试数据库</li>
<li><code>Reload privilege tables now? [Y/n]</code>是否要重启以生效刚刚的设置</li>
</ul>
</li>
</ul>
</li>
<li>
<p>编辑配置主页</p>
<ul>
<li>
<p><code>vim /var/www/html/index.php</code>编辑php文件</p>
<div><pre><code><span><span>&lt;?PHP</span>
<span>$connect</span> <span>=</span> <span>mysqli_connect</span><span>(</span><span>'localhost'</span><span>,</span><span>'root'</span><span>,</span><span>'password'</span><span>,</span><span>'myDB'</span><span>,</span><span>'3306'</span><span>)</span><span>or</span> <span>die</span><span>(</span><span>"连接数据库失败"</span><span>.</span><span>mysql_error</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>if</span><span>(</span><span>$connect</span><span>)</span><span>{</span>
    <span>echo</span> <span>"连接成功！"</span><span>;</span>
<span>}</span>
<span>?></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
</ul>
</li>
<li>
<p>防火墙与selinux</p>
<ul>
<li><code>firewall-cmd --add-service=http --add-service=https --add-service=mysql</code></li>
<li><code>setenforce 0</code></li>
</ul>
</li>
<li>
<p>测试</p>
<ul>
<li>打开浏览器输入<code>http:\\localhost\index.php</code></li>
</ul>
</li>
<li>
<p>应用测试请往下翻看</p>
</li>
</ul>
<h2 id="详细基础搭建"> 详细基础搭建</h2>
<ol>
<li>
<p>Apache</p>
<ul>
<li>安装<code>yum install httpd</code></li>
<li>设置开机启动<code>systemctl enable httpd</code></li>
<li>启动<code>systemctl start httpd</code></li>
</ul>
</li>
<li>
<p>mariadb</p>
<ul>
<li>安装<code>yum install mariadb-server</code></li>
<li>设置开机启动<code>systemctl enable mariadb</code></li>
<li>启动<code>systemctl start mariadb</code></li>
<li><code>mysql_secure_installation</code>初始化数据库
<ul>
<li>一开始会询问是否设置数据库root的密码，回车确认</li>
<li><code>Set root password? [Y/n]</code>是否设置root密码，推荐y
<ul>
<li><code>New password:</code>之后会让你输入密码</li>
</ul>
</li>
<li><code>Disallow root login remotely? [Y/n]</code>是否不允许root用户远程登录，推荐n</li>
<li><code>Remove anonymous users? [Y/n]</code>移除anonymous用户，推荐y</li>
<li><code>Remove test database and access to it? [Y/n]</code>是否要移除测试数据库</li>
<li><code>Reload privilege tables now? [Y/n]</code>是否要重启以生效刚刚的设置</li>
</ul>
</li>
</ul>
</li>
<li>
<p>PHP</p>
<ul>
<li>
<p>安装<code>yum install php</code></p>
</li>
<li>
<p>安装web常用PHP组件<code>yum install php-mysql php-gd libjpeg* php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-bcmath php-mhash</code></p>
</li>
<li>
<p>可选测试</p>
</li>
</ul>
</li>
</ol>
<ul>
<li>
<p><code>vim /var/www/html/index.php</code>在网页根目录中新建一个php主页
<code>&lt;?PHP echo &quot;hello world!&quot;; ?&gt;</code></p>
</li>
<li>
<p>重启Apache加载PHP<code>systemctl restart httpd</code></p>
</li>
<li>
<p><code>vim /var/www/html/inde.php</code>PHP+SQL简单测试</p>
<div><pre><code><span><span>&lt;?PHP</span>
<span>$connect</span> <span>=</span> <span>mysqli_connect</span><span>(</span><span>'localhost'</span><span>,</span><span>'root'</span><span>,</span><span>'password'</span><span>,</span><span>'myDB'</span><span>,</span><span>'3306'</span><span>)</span><span>or</span> <span>die</span><span>(</span><span>"连接数据库失败"</span><span>.</span><span>mysql_error</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>if</span><span>(</span><span>$connect</span><span>)</span><span>{</span>
    <span>echo</span> <span>"连接成功！"</span><span>;</span>
<span>}</span>
<span>?></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
<li>
<p><code>vim /var/www/html/inde.php</code>PHP连接数据库，忘记了可<a href="https://www.cnblogs.com/bigspinach/p/7653655.html" target="_blank" rel="noopener noreferrer">参考</a>(可选)</p>
<div><pre><code><span><span>&lt;?PHP</span>
	<span>$connect</span> <span>=</span> <span>mysqli_connect</span><span>(</span><span>'localhost'</span><span>,</span><span>'root'</span><span>,</span><span>'password'</span><span>,</span><span>'myDB'</span><span>,</span><span>'3306'</span><span>)</span><span>;</span>
    <span>//2.定义sql语句</span>
     <span>$sql</span><span>=</span><span>'select * from table'</span><span>;</span>
        <span>mysqli_query</span><span>(</span><span>$connect</span><span>,</span><span>'set names utf8'</span><span>)</span><span>;</span>
    <span>//3.发送SQL语句</span>
        <span>$result</span><span>=</span><span>mysqli_query</span><span>(</span><span>$connect</span><span>,</span><span>$sql</span><span>)</span><span>;</span>
<span>$arr</span><span>=</span><span>array</span><span>(</span><span>)</span><span>;</span><span>//定义空数组       </span>
        <span>while</span><span>(</span><span>$row</span> <span>=</span><span>mysqli_fetch_array</span><span>(</span><span>$result</span><span>)</span><span>)</span><span>{</span>
                <span>var_dump</span><span>(</span><span>$arr</span><span>)</span><span>;</span>
                <span>echo</span> <span>"&lt;br>"</span><span>;</span>
        <span>}</span>
    <span>//4.关闭连接</span>
       <span>mysqli_close</span><span>(</span><span>$connect</span><span>)</span><span>;</span>
<span>?></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div></li>
</ul>
<h2 id="扩展应用"> 扩展应用</h2>
<p>可以使用织梦、可道云、moodle等应用</p>
<h3 id="可道云"> 可道云</h3>
<ul>
<li>教程其实可以参考官网：https://kodcloud.com/download/</li>
<li><code>wget http://static.kodcloud.com/update/download/kodbox.1.09.zip</code>下载kod的压缩包文件（最新的版本命令可在上面的官网链接获取）</li>
<li><code>unzip kodbox.1.09.zip</code>解压压缩包到当前目录下</li>
<li><code>mv kodbox.1.09.zip /var/www/html/kodbox</code>将文件夹重命名并放置在其他位置</li>
<li><code>cd /var/www/html/kodbox</code>切换到此目录下</li>
<li><code>chmod -Rf 755 ./*</code>按官方说明授予权限</li>
<li>打开浏览器访问<code>localhost/kodbox</code>根据提示进行设置即可</li>
</ul>
<h3 id="织梦"> 织梦</h3>
<ul>
<li>先在官网下载安装压缩包：http://www.dedecms.com/products/dedecms/downloads/</li>
<li><code>tar -xzvf DedeCMS-V5.7-UTF8-SP2.tar.gz</code>下载好之后对其进行解压（文件名视具体情况变动）</li>
<li><code>mv kodbox.1.09.zip /var/www/html/dede</code></li>
<li><code>cd /var/www/html/dede</code>切换到此目录下</li>
<li><code>chmod -Rf 755 dede</code>授予权限</li>
<li>打开浏览器访问<code>localhost/dede/uploads/install/index.php</code>根据提示进行设置即可</li>
</ul>
<h3 id="moodle"> moodle</h3>
<ul>
<li>PHP版本&gt;7.1
<ul>
<li>可以选择在官网下载安装压缩包：https://download.moodle.org/releases/latest/org/</li>
</ul>
</li>
<li>PHP5
<ul>
<li><code>wget https://download.moodle.org/stable30/moodle-3.0.tgz</code>下载历史旧版本</li>
<li><code>tar -xvf moodle-3.0.tgz</code>解压压缩包</li>
<li><code>chmod -R 755 moodle</code>授予权限</li>
<li>打开浏览器访问<code>localhost/moodle/install.php</code>根据提示进行设置即可</li>
</ul>
</li>
</ul>
<h1 id="nfs"> NFS</h1>
<h2 id="概念-9"> 概念</h2>
<p>主要用于linux之间的文件共享</p>
<ul>
<li>网络文件系统（ Network File System,NFS）采
用客户机服务器工作模式</li>
<li>NFS是分布式计算系统的一个组成部分，可实现在异种网络上共享和装配远程文件系统。</li>
<li>NFS提供了一种在类UNX系统上共享文件的方法。</li>
<li>NFS还可以结合远程网络启动实现
<ul>
<li>无盘工作站（PXE启动系统，所有数据均在服务器的磁盘阵列上）</li>
<li>瘦客户工作站（本地启动系统，本地磁盘存储了常用的系统工具，而所有/home目录的用户数据被放在NFS服务器上并且在网络上处处可用）</li>
</ul>
</li>
</ul>
<h3 id="协议模型"> 协议模型</h3>
<ul>
<li>NFS协议提供了一种远程文件系统规范
<img src="./images/linux_notes/image-20200529191504082.png" alt="image-20200529191504082" /></li>
</ul>
<h3 id="nfs协议版本"> NFS协议版本</h3>
<p>RHEL/CentOS7支持NFS V3、NFS V4客户端，默认使用NFS V4协议</p>
<p><img src="./images/linux_notes/image-20200529191534873.png" alt="image-20200529191534873" /></p>
<h3 id="nfs-v4"> NFS V4</h3>
<p>NFSv4内置了远程挂装和文件锁定等协议支持，因此NFSv4不再需要与 rpcbindrpc. mountd、rpc. statd和 locks互动
在 Centos7中，当NFS服务器端使用exportfs命令时仍然需要rpc. mountd守护进程，但它不参与跨越网络线路的操作。
NFSv4的nfs服务仍然监听在tcp:2049端口。</p>
<h3 id="与nfs相关的rpm包"> 与NFS相关的RPM包</h3>
<ul>
<li>nfs- utils:NFS的主要组件。包含有rpc.nfsd及rpc. mountd这两个NFS的核心守护进程及其相关文档、执行文件等</li>
<li>rpcbind：提供RPC的端口映射的守护进程及其相关文档、执行文件等</li>
</ul>
<h3 id="与nfs相关的工具"> 与NFS相关的工具</h3>
<ul>
<li>exportfs：在NFS服务器端，维护NFS共享资源的命令</li>
<li>showmount：用来在NFS客户端查看服务器共享的目录</li>
<li>nfsstat：显示NFS的状态统计信息</li>
<li>recinto：显示由RPC维护的端口映射，显示已经注册的RPC服务列表。</li>
</ul>
<h2 id="动手-4"> 动手</h2>
<h3 id="安装-7"> 安装</h3>
<ul>
<li><code>yum install nfs-utils</code>安装</li>
<li><code>systemctl enable nfs-server</code>开机自启
<ul>
<li>
<p>因为作者做了软连接，所以也可以使用nfs</p>
<p><img src="./images/linux_notes/image-20200528101938996.png" alt="image-20200528101938996" /></p>
</li>
</ul>
</li>
<li><code>systemctl start nfs-server</code>启动nfs服务</li>
</ul>
<h3 id="配置共享文件夹"> 配置共享文件夹</h3>
<ul>
<li>配置文件：<code>/etc/exports</code></li>
<li><code>vim /etc/exports</code>编辑nfs配置文件</li>
<li>格式：<code>共享目录	主机表(参数表)	主机表2(参数表)</code>
<ul>
<li><code>/srv/nfs 192.168.3.0(ro) 192.168.4.45(rw)</code></li>
<li><code>/srv/nfs *(ro)</code>允许所有主机，ro-readonly只读</li>
<li><code>showmount -e localhost</code>查看本机共享情况</li>
</ul>
</li>
<li>参数
<ul>
<li><code>ro</code> 设置共享目录为只读的权限</li>
<li><code>rw</code> 设置共享目录为可读写的权限</li>
<li><code>root_squash</code> 将root哟用户或其所属组映射为匿名用户或组（nfsnobody），这是默认值</li>
<li><code>no_root_squash</code> 将root用户或其所属组映射成匿名用户或组，这样设置很不安全不建议使用</li>
<li><code>all_squaash</code>将所有远程访问的普通用户或组都映射成匿名用户或组，适合公用目录</li>
<li><code>no_all_squash</code> 不将所有远程访问的普通用户或组都映射成匿名用户或组，这是默认值</li>
</ul>
</li>
</ul>
<h3 id="配置防火墙"> 配置防火墙</h3>
<ul>
<li><code>firewall-cmd --add-service=nfs --add-service=mountd --add-service=rpc-bind --permanent</code></li>
<li><code>firewall-cmd --reload</code></li>
</ul>
<h3 id="linux客户端"> Linux客户端</h3>
<h4 id="查询-3"> 查询</h4>
<ul>
<li><code>showmount -e 192.168.3.106</code></li>
</ul>
<h4 id="挂载-2"> 挂载</h4>
<ul>
<li><code>mkdir /mnt/linux_nfs</code>新建文件夹以挂载</li>
<li><code>mount -t nfs nfs服务器地址:/共享目录 挂载点</code></li>
<li><code>mkdir /mnt/linux_nfs</code>新建文件夹以挂载</li>
<li><code>mount -t nfs 192.168.3.106:/srv/nfs /mnt/linux_nfs</code>将主机192.168.3.106的文件夹<code>/srv/nfs</code>挂载到本机的<code>/mnt/linux_nfs</code>上</li>
</ul>
<h4 id="卸载-2"> 卸载</h4>
<ul>
<li><code>umount /srv/nfs</code></li>
</ul>
<h3 id="windwos客户端访问nfs"> windwos客户端访问NFS</h3>
<ul>
<li>一开始windows并不支持NFS，但随后增加了访问功能，但需要安装额外功能，通过映射网络驱动器的方式来使用</li>
<li><code>控制面板&gt;程序&gt;程序和功能&gt;启用或关闭Windows功能&gt;NFS服务</code>将NFS服务勾选上，确定并安装即可</li>
<li>安装完成打开cmd
<ul>
<li><code>showmount -e 192.168.3.105</code>查询NFS，有的windows版本不支持</li>
<li><code>mount 192.168.3.105:/srv/nfs f:</code>映射网络驱动器到f盘</li>
</ul>
</li>
</ul>
<h3 id="开机启动"> 开机启动</h3>
<p><code>ip:/共享目录	挂载点	nfs	_netdwv	0	0</code></p>
<h3 id="其他-5"> 其他</h3>
<ul>
<li>exportfs
<ul>
<li>用于维护NFS共享的目录列表</li>
<li>当修改了/etc/ exports之后，无需重新启动nfs服务，可以使用 exports命令使改动立刻生效。</li>
<li><code>exportfs [-aruv]</code>
<ul>
<li><code>-a</code>全部挂载或卸载/etc/ exports配置文件中的设置</li>
<li><code>-r</code>全部挂载<code>/etc/exports</code>中的设置，同步更新<code>/var/lib/nfs/xtab</code>的内容</li>
<li><code>-u</code>卸载共享目录</li>
<li><code>-v</code>在显示输出列表的同时显示这顶参数</li>
</ul>
</li>
</ul>
</li>
<li>nfsstat</li>
<li>rpcinfo</li>
</ul>
<h1 id="samba"> SAMBA</h1>
<h2 id="概念-10"> 概念</h2>
<p>Samba是在Linux和UNIX系统上实现SMB协议的一个免费软件，由服务器及客户端程序构成。SMB（Server Messages Block，服务消息块）是一种在局域网上共享文件和打印机的一种通信协议，它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。SMB协议是客户机/服务器型协议，客户机通过该协议可以访问服务器上的共享文件系统、打印机及其他资源。通过设置“NetBIOS over TCP/IP”使得Samba不但能与局域网络主机分享资源，还能与全世界的电脑分享资源。</p>
<p>SMB/CIFS协议和SAMBA，Linux用NFS，Windows用SMB，由于Linux觉得SMB不错，但win不理睬，Linux是后面才将SAMBA补上</p>
<ul>
<li>SMB( Server Message Block,服务信息块)协议是个高层协议,它提供了在网络上的不同计算机之间共享文件、打印机和不同通信资料的手段</li>
<li>SMB使用NetBIOS API实现面向连接的协议,该协议为 Windows客户程序和服务提供了一个通过虚电路按照请求一响应方式进行通信的机制。</li>
<li>SMB的工作原理就是让NetBIOS与SMB协议运行在TCP/IP上,并且使用 NetBIOS的名字解释器让Linux机器可以在 Windows的网上邻居中被看到,从而和 Windows9X/NT200X进行相互沟通,共享文件和打印机。</li>
<li>Samba允许 Linux服务器与 Windows系統之间进行通信，使跨平台的互访成为可能。 Samba采用C/S模式，其工作机制是让 Netbios( Windows网上邻居的通信协议）和SMB两个协议运行于TCP/IP通信协议之上并且用 Vetbeult协议让 Windows在“网上邻居”中能浏览Linux服务器</li>
<li>Sambar服务器可实现如下功能：WINS和DNS服务；网络浏览服务； Linux和 Windows城之间的认证和授权； UNICODE字符集和城名映射满足CFS协议的UNX共享等。 Sambal服务器可实现如下功能：WINS和DNS服务；网络浏览服务； Linux和 Windows城之间的认证和授权；UNICODE字符集和坂名映射满足CIFS协议的UNX共享等</li>
</ul>
<h3 id="samba主要服务"> Samba主要服务</h3>
<ul>
<li>文件和打印机共享</li>
<li>用户验证和授权</li>
<li>名称解析</li>
<li>流浪（服务通告）</li>
</ul>
<h3 id="samba守护进程"> Samba守护进程</h3>
<ul>
<li>Smbd：实现共享和验证授权服务</li>
<li>Nmbd：实现名字解析和浏览服务</li>
</ul>
<p>mba服务器包括两个后台应用程序：Smbd和Nmbd.Smbd是 Samba的核心，主要负责建立 Linux Samba服务器与 Samba客户机之间的对话，验正用户身份并提供对文件和打印系统的访；Nmbd主要负责对外发布 Linux Samba服务器可以提供的 Netbios：名称和浏览服务，使 Windows用户可以在“网上邻居”中浏览 Linux Samba服务器中共享的源另外 Samba还包括一些管理工具，如smb- client, smbmount, testp arm, smbpasswd等</p>
<h3 id="服务概览"> 服务概览</h3>
<ul>
<li>软件包：<code>samba</code>,<code>samba-common</code></li>
<li>服务类型：由Systemd启动的守护进程</li>
<li>配置单元：<code>/usr/lib/systemd/system/[smb|nmb]d.service</code></li>
<li>守护进程：<code>/usr/sbin/nmbd</code>,<code>/usr/sbin/smbd</code></li>
<li>监听端口：
<ul>
<li>NetBIOS <code>UDP:137(-ns)</code>,<code>UDP:138(-dgm)</code>,<code>TCP:139(-ssn)</code></li>
<li>SMB over TCP <code>TCP:445(-ds)</code></li>
</ul>
</li>
<li>配置文件：<code>/etc/samba/</code></li>
<li>相关软件包：<code>samba-swat</code>,<code>samba-client</code>,<code>testoarm</code>,<code>cifs-utils</code></li>
</ul>
<h2 id="动手-5"> 动手</h2>
<h3 id="安装-8"> 安装</h3>
<ul>
<li><code>yum install samba</code></li>
</ul>
<h3 id="编辑配置文件"> 编辑配置文件</h3>
<ul>
<li>
<p><code>mkdir -p /srv/samba/example</code> 配置一个共享文件夹</p>
<ul>
<li><code>touch test.txt</code>放置文件以验证</li>
</ul>
</li>
<li>
<p><code>semanage fcontext -a -t samba_share_t &quot;/srv/samba/example(/.*)?&quot;</code>修改文件类型</p>
</li>
<li>
<p><code>restorecon -Rv /srv/samba/example/</code>用于恢复selinux文件属性即恢复文件的安全上下文，-R 连同子目录一起修改，-v 将过程显示到屏幕上</p>
</li>
<li>
<p><code>vim /etc/samba/smb.conf</code>编辑配置文件</p>
<div><pre><code>[global] #段
	workgroup = SAMBA-name	#工作组
	netbios name = Server
	security = user
	log file = /var/log/samba/%m.log
	log level = 1
[bit] #自定义的名字
	path = /srv/smaba/example/
	read only = no
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></li>
<li>
<p><code>testparm</code>检查<code>sam.conf</code>配置文件</p>
</li>
</ul>
<h3 id="创建smb用户"> 创建smb用户</h3>
<p>Linux共享必须是单独的系统用户，nologin创建系统用户但不能登录</p>
<ul>
<li><code>useradd -M -s /sbin/nologin example</code>创建一个用户以添加到smb中，直接新建用户smb是不能使用的</li>
<li><code>passwd example</code>配置密码</li>
<li><code>smbpasswd -a example</code>添加到smb账户中以供远程访问
<ul>
<li><code>-a</code>添加用户，要添加的用户必须是系统用户</li>
<li><code>-d</code>冻结用户，将这个用户冻结，禁止使用</li>
<li><code>-c</code>恢复用户，将用户解冻，允许使用</li>
<li><code>-n</code>吧用户的密码设置成空，要在global中写入 null passwords -ture</li>
<li><code>-x</code>删除用户</li>
</ul>
</li>
</ul>
<h3 id="启动服务"> 启动服务</h3>
<ul>
<li><code>systemctl start smb</code>启动smb服务</li>
<li><code>firewall-cmd --add-service=samba --permanent</code>允许smb服务通过</li>
<li><code>firewall-cmd --reload</code>重新载入配置文件</li>
<li><code>systemctl enable smb</code>设置开机自启</li>
</ul>
<h3 id="访问测试-2"> 访问测试</h3>
<ul>
<li><code>\\192.168.3.105</code>在外部windows机器的文件管理器输入Linux的IP，账户密码是刚刚创建的example</li>
</ul>
<h3 id="删除-2"> 删除</h3>
<p>如果想重新连接，则需要先在cmd中将其删除</p>
<ul>
<li><code>net use \\192.168.3.105 /del</code></li>
</ul>
<h1 id="定时任务"> 定时任务</h1>
<p>Scheduling tasks，定时循环执行指定操作以保障系统长久化使用，这是系统自带的服务，无需安装</p>
<ul>
<li>
<p>cron</p>
</li>
<li>
<p>文件位置：<code>/etc/cron.d</code></p>
</li>
<li>
<p>计划任务保存的地方：<code>/var/spool/cron/</code></p>
</li>
<li>
<p><code>cat /etc/crontab</code>查看</p>
<div><pre><code><span>[</span>root@centos /<span>]</span><span># cat /etc/crontab</span>
<span><span>SHELL</span></span><span>=</span>/bin/bash
<span><span>PATH</span></span><span>=</span>/sbin:/bin:/usr/sbin:/usr/bin
<span>MAILTO</span><span>=</span>root

<span># For details see man 4 crontabs</span>

<span># Example of job definition:</span>
<span># .---------------- minute (0 - 59)</span>
<span># |  .------------- hour (0 - 23)</span>
<span># |  |  .---------- day of month (1 - 31)</span>
<span># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span>
<span># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span>
<span># |  |  |  |  |</span>
<span># *  *  *  *  * user-name  command to be executed</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div></li>
</ul>
<h2 id="动手-6"> 动手</h2>
<h3 id="设置任务"> 设置任务</h3>
<ul>
<li><code>crontab -e</code>一般用户使用这个命令为这个用户的任务
<ul>
<li><code>-e</code>需要编辑</li>
</ul>
</li>
<li><code>crontab -e -u username</code>管理员可以给指定用户添加任务</li>
</ul>
<h4 id="格式"> 格式</h4>
<p>执行的最小时间间隔是每分钟，每分钟检查一次需要做什么任务</p>
<ul>
<li>
<p><code>分钟、小时、日、月、星期、用户名(管理员下)、命令</code></p>
</li>
<li>
<p>minute <code>0-59</code></p>
</li>
<li>
<p>hour <code>0-23</code></p>
</li>
<li>
<p>month <code>1-12</code></p>
</li>
<li>
<p>day of week <code>0-7(0=0,星期天)</code></p>
</li>
<li>
<p><code>*</code>代表任意允许的值</p>
</li>
<li>
<p><code>8,19</code>如果有多个值用逗号隔开</p>
</li>
<li>
<p><code>0-23/2</code>或<code>*/2</code>代表偶数的值（0,2,4,6...22）</p>
</li>
<li>
<p>具体</p>
<div><pre><code># 分钟、小时、日、月、星期、[用户名(管理员下,可选)]、命令
# 每年的一月一日 重启一次电脑 `*`表示都匹配
0	0	1	1	*	reboot
# 每个新七天的凌晨3点钟 重启一次httpd
0	3	*	*	0	systemctl restart httpd
# 每个工作日的8点和19点执行 记录一个日志
0	8,19	*	*	1-5	logger message rom root
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
</ul>
<h3 id="查看计划任务"> 查看计划任务</h3>
<p>如果设置了任务，可以在<code>/var/spool/cron/</code>这个目录下查看，文件名为设置任务的指定用户名，不建议直接使用vim编辑，标准的编辑是使用<code>crontab -e</code></p>
<ul>
<li><code>cat /car/spool/cron/root</code>查看root用户设置的计划任务</li>
<li><code>crontab -l</code>当前用户的任务</li>
</ul>
<h3 id="安全"> 安全</h3>
<p>计划是默认所有用户都能使用，默认系统使用黑名单<code>cron.deny</code></p>
<ul>
<li>
<p><code>/etc/cron.allow</code>在其中填写用户名则能使<strong>指定用户可以使用</strong><code>crontab</code>命令，<strong>其他用户不允许</strong></p>
</li>
<li>
<p><code>/etc/cron.deny</code>在其中填写用户名则能使<strong>指定用户不可以使用</strong><code>crontab</code>命令，<strong>其他用户允许</strong></p>
<ul>
<li>
<p>这里将用户bit添加至<code>cron.deny</code>中</p>
<div><pre><code><span>[</span>bit@centos cron.hourly<span>]</span>$ <span>crontab</span> -e
You <span>(</span>bit<span>)</span> are not allowed to use this program <span>(</span>crontab<span>)</span>
See crontab<span>(</span><span>1</span><span>)</span> <span>for</span> <span>more</span> information
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
</ul>
</li>
</ul>
<h3 id="定时执行临时任务"> 定时执行临时任务</h3>
<p>只能临时执行一次，而<strong>不是循环执行</strong>.(at.d)</p>
<ul>
<li>
<p>at（windows下也有）</p>
<ul>
<li>
<p><code>ctrl+D</code>保存并退出编辑</p>
</li>
<li>
<p>在十一点执行一个任务</p>
<div><pre><code><span>[</span>root@centos /<span>]</span><span># at 11:00</span>
at<span>></span> <span>dir</span> / <span>></span> /rootdir.txt
at<span>></span> <span>&lt;</span>EOT<span>></span>
job <span>1</span> at Thu Jun  <span>4</span> <span>11</span>:00:00 <span>2020</span>
<span>[</span>root@centos cron.hourly<span>]</span><span># atq</span>
<span>1</span>	Thu Jun  <span>4</span> <span>11</span>:00:00 <span>2020</span> a root
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
</ul>
</li>
<li>
<p><code>atq</code>查看建立的工作</p>
</li>
<li>
<p><code>atrm [num]</code></p>
</li>
</ul>
<h1 id="log日志"> log日志</h1>
<ul>
<li><code>logger this is a logger</code>记录日志</li>
<li><code>Direct write</code>（Apache samba）服务个体记录的日志</li>
<li><code>rsyslogd</code> 系统本身服务记录的日志
<ul>
<li>unix上是使用了syslogd，后来的rsyslogd是他的升级版（r：更可靠的）</li>
<li>rsyslogd信息多，写带不用文件，可远程</li>
</ul>
</li>
<li><code>journald</code>（sysemd-journald）与系统进程绑定的服务记录的日志
<ul>
<li>二进制保存的文件，不能直接查看，自开机启动以来的日志信息（重启后会重新开始记录，旧记录会丢失）</li>
<li><code>journal</code>可以通过这个命令查看开机启动以来的日志</li>
</ul>
</li>
</ul>
<h2 id="rsyslogd"> rsyslogd</h2>
<ul>
<li>
<p>获取信息的途径</p>
<ul>
<li><code>/var/log/*</code>通常的信息会写入到此目录中</li>
<li><code>journalctl</code></li>
<li><code>systemctl status 服务名</code></li>
</ul>
</li>
<li>
<p>查看日志文件</p>
<ul>
<li><code>tail /var/log/messages</code>查看日志文件
<ul>
<li><code>tail -f /var/log/messages</code>实时查看日志文件</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>/etc/rsyslog.conf</code>系统自带的日志文件配置</p>
<ul>
<li>
<p>模块、全局指令、规则</p>
</li>
<li>
<p><code>facility、priority、destination</code>服务、信息级别、目的文件</p>
<ul>
<li>
<p><code>rsyslog.conf</code></p>
<div><pre><code># mail服务 .*代表全部的级别 /../..什么级别的信息保存在什么地方
mail.*                                                  -/var/log/maillog
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
</ul>
</li>
<li>
<p>信息级别：<code>debug、info、notice、warning、error、crit、alert、emerg</code>越来越严重</p>
</li>
</ul>
</li>
</ul>
<h2 id="journalctl"> journalctl</h2>
<ul>
<li><code>journalctl --no-pager</code></li>
<li><code>journalctl --follow</code>实时查看日志信息</li>
<li><code>journalctl -f</code>实时查看日志信息</li>
<li><code>journalctl _UID=0</code></li>
<li><code>journalctl -n 20</code>等同于<code>tail -n 20</code></li>
<li><code>journalctl -p eror</code>只显示错误信息</li>
<li><code>journalctl --since yesterday -p err</code>自什么时间到什么时间的错误</li>
<li><code>journalctl --since --until（YYYY-MM-DD hh:mm:ss）</code>从什么时候到什么时候</li>
<li><code>journalctl -o verbose</code></li>
<li><code>journalctl _SYSTEMD_UNIT=sshd.service</code></li>
<li>保存journal信息
<ul>
<li><code>/run/log/journal</code></li>
<li><code>/var/log/journal monthly</code>保存总空间10%或15%就开始清理之前的记录</li>
<li><code>/etc/systemd/journald.conf</code>配置文件</li>
</ul>
</li>
</ul>
<h2 id="rotaing-log-files"> rotaing log files</h2>
<ul>
<li>按时间归档日志文件（每周）</li>
<li><code>/etc/logrotate.conf</code></li>
<li><code>/etc/logrotatd.d</code></li>
</ul>
<h1 id="ssl"> SSL</h1>
<ul>
<li>web安全-&gt;HTTPS</li>
<li>Secure Sockets Layer（SSL）
<ul>
<li>v2与v3都有漏洞，逐渐被TLS</li>
</ul>
</li>
<li>Transport Layer Security （TLS）</li>
<li>CA（Certificate Authority）</li>
</ul>
<h2 id="配置https"> 配置HTTPS</h2>
<h3 id="环境搭建"> 环境搭建</h3>
<ul>
<li><code>yum install http</code></li>
<li><code>yum install mod_ssl</code></li>
</ul>
<h3 id="ssl配置文件"> ssl配置文件</h3>
<p>此处做介绍无需配置<code>/etc/httpd/conf.d/ssl.conf</code></p>
<div><pre><code>...
# 启用ssl
SSLEngine on
# sslv2喝sslv3都有爆过出现漏洞
# 与所有ssl协议兼容，排除SSLv2与SSLv3
SSLProtocol all -SSLv2 -SSLv3
# 建议的写法，排除所有只使用1、1.1、1.2版本
# SSLProtocol -all +TLSv1 +TLSv1.1 +TLSv1.2
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="生成ssl"> 生成SSL</h3>
<ul>
<li><code>openssl rsa -text -in /etc/pki/tls/private/localhost.key</code></li>
<li><code>openssl x509 -text -in /etc/pki/tls/certs/localhost.crt</code></li>
</ul>
<h3 id="验证ssl和tls协议"> 验证SSL和TLS协议</h3>
<ul>
<li>格式：<code>openssl s_client -connect hostname:port -protocol</code></li>
<li><code>openssl s_client -connect localhost:443 -tls1</code></li>
</ul>
<h3 id="防火墙配置"> 防火墙配置</h3>
<ul>
<li><code>firewall-cmd --add-service=https</code></li>
</ul>
<h3 id="验证-2"> 验证</h3>
<ul>
<li><code>ip a</code>得到本机IP：<code>192.168.1.2</code></li>
<li>打开浏览器输入：<code>https://192.168.1.2</code></li>
</ul>
<h2 id="配置ftps"> 配置FTPS</h2>
<h3 id="环境配置"> 环境配置</h3>
<ul>
<li><code>yum install vsftpd</code></li>
<li><code>yum install mod_ssl</code></li>
</ul>
<h3 id="生成ssl-2"> 生成SSL</h3>
<ul>
<li><code>openssl rsa -text -in /etc/pki/tls/private/localhost.key</code></li>
<li><code>openssl x509 -text -in /etc/pki/tls/certs/localhost.crt</code></li>
</ul>
<h3 id="验证ssl和tls协议-2"> 验证SSL和TLS协议</h3>
<ul>
<li>格式：<code>openssl s_client -connect hostname:port -protocol</code></li>
<li><code>openssl s_client -connect localhost:443 -tls1</code></li>
</ul>
<h3 id="配置ftp"> 配置FTP</h3>
<p><code>vim /etc/vsftpd/vsftpd.conf</code></p>
<div><pre><code>...
# 末尾添加如下内容
ssl_enable=YES
ssl_tlsv1_2=YES
ssl_tlsv1_1=YES
ssl_tlsv1=NO
ssl_tlsv1=NO
ssl_sslv2=NO
ssl_sslv3=NO

allow_anon_ssl=NO
force_local_data_ssl=YES
force_local_logins_ssl=YES
require_ssl_reuse=NO
ssl_ciphers=HIGH
rsa_cert_file=/etc/pki/tls/certs/localhost.crt
rsa_private_key_file=/etc/pki/tls/private/localhost.key
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id="其他-6"> 其他</h3>
<p>如果登录失败或不能访问可以尝试关闭selinux与防火墙</p>
<ul>
<li><code>setenforce 0</code></li>
<li><code>systemctl stop firewalld</code></li>
</ul>
<h3 id="验证-3"> 验证</h3>
<p>使用<code>FileZilla</code>新建站点，使用<code>SFTP</code>协议输入主机IP、账号密码即可</p>
]]></content:encoded>
    </item>
    <item>
      <title>各大笔记平台比较</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/opinions/%E5%90%84%E5%A4%A7%E7%AC%94%E8%AE%B0%E5%B9%B3%E5%8F%B0%E6%AF%94%E8%BE%83/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/opinions/%E5%90%84%E5%A4%A7%E7%AC%94%E8%AE%B0%E5%B9%B3%E5%8F%B0%E6%AF%94%E8%BE%83/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">各大笔记平台比较</source>
      <category>杂谈</category>
      <pubDate>Wed, 09 Jun 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="比较"> 比较</h1>
<p>话不多说先看表</p>
<table>
<thead>
<tr>
<th>名字</th>
<th>编辑逻辑</th>
<th>分享查看逻辑</th>
<th>同步速度</th>
<th>推荐指数</th>
</tr>
</thead>
<tbody>
<tr>
<td>notion</td>
<td>⭐⭐⭐⭐⭐</td>
<td>⭐⭐⭐⭐</td>
<td>⭐⭐</td>
<td>⭐⭐⭐⭐⭐</td>
</tr>
<tr>
<td>语雀</td>
<td>⭐⭐⭐⭐</td>
<td>⭐⭐⭐⭐⭐</td>
<td>⭐⭐⭐⭐⭐</td>
<td>⭐⭐⭐⭐⭐</td>
</tr>
<tr>
<td>有道云笔记</td>
<td>⭐⭐⭐</td>
<td>⭐⭐⭐⭐</td>
<td>⭐⭐⭐⭐⭐</td>
<td>⭐⭐⭐⭐</td>
</tr>
<tr>
<td>印象笔记</td>
<td>⭐⭐</td>
<td></td>
<td>⭐⭐⭐⭐⭐</td>
<td>⭐⭐⭐</td>
</tr>
<tr>
<td>github page</td>
<td>⭐</td>
<td>⭐⭐⭐⭐⭐</td>
<td>⭐⭐</td>
<td>⭐⭐⭐⭐⭐</td>
</tr>
<tr>
<td>专注笔记</td>
<td>⭐⭐⭐⭐</td>
<td></td>
<td>⭐⭐⭐</td>
<td>⭐⭐</td>
</tr>
</tbody>
</table>
<h2 id="详细说明"> 详细说明</h2>
<ul>
<li>
<p>notion</p>
<ul>
<li>
<p>全平台在线，但无本地</p>
</li>
<li>
<p>记录逻辑舒服，但上手需要过程，有完整的页面编辑逻辑，但share功能不太行，对文件逻辑层次表现不佳（没有标题导航）</p>
<ul>
<li>（对作者友好，对观众不有好系列）</li>
</ul>
</li>
<li>
<p>搜索功能齐全，虽然不能识别图片，但是搜索到的内容可以跳转到搜索的文字段，比到标题还好！</p>
</li>
<li>
<p>速度较慢，有时还会上不去</p>
</li>
</ul>
</li>
<li>
<p>语雀</p>
<ul>
<li>
<p>仅支持web与电脑端，但无本地</p>
</li>
<li>
<p>导出导入方便，支持md图片（压缩包）</p>
</li>
<li>
<p>记录逻辑奇怪。。但输出效果好，有当前专辑文章还有标题导航栏，有完整的页面浏览逻辑</p>
<ul>
<li>（对作者不友好，对观众友好系列）</li>
</ul>
</li>
<li>
<p>搜索功能有，而且还能识别图片（不愧是阿里），但搜索到的内容不能跳转到指定位置而是单纯的点开文章</p>
</li>
<li>
<p>同步速度很快</p>
</li>
</ul>
</li>
<li>
<p>印象</p>
<ul>
<li>全平台在线，有本地数据库（加密了，安全）</li>
<li>导出导入麻烦（收费）而且还有上传下载流量限制</li>
<li>做啥事情都体现一个字：收费！</li>
<li>界面设计颜色讨喜，但是用户交互不好</li>
<li>由于不能无限套娃，文章文件夹层次有限制，而且编辑的功能感觉不完全，有点不是太舒服所以记录逻辑有点奇怪，</li>
<li>同步速度很快</li>
</ul>
</li>
<li>
<p>有道云笔记</p>
<ul>
<li>全平台在线，有本地数据（未加密！不安全）</li>
<li>导出导入还行，有3G容量限制，不过够用是真的！</li>
<li>整体文件放置逻辑和印象一致，界面设计还过得去，但用户交互比印象稍好</li>
<li>编辑功能还行，起码比印象好点，也是有点不太舒服</li>
<li>同步速度很快</li>
</ul>
</li>
<li>
<p>github page类</p>
<ul>
<li>
<p>需要经历：本地编辑→本地部署→本地上传</p>
</li>
<li>
<p>仅限本地编辑部署和上传，而且不是全平台</p>
<ul>
<li>（对作者不友好，对观众友好系列）</li>
</ul>
</li>
<li>
<p>速度较慢，有时还会上不去</p>
</li>
<li>
<p>可以白嫖域名</p>
</li>
</ul>
</li>
<li>
<p>专注笔记</p>
<ul>
<li>全平台，云同步1G限制，本地无限制</li>
<li>功能新颖，但实际体验一般，网页剪影中对大型页面不有好，会出现卡壳无法退出的情况</li>
<li>无共享功能</li>
</ul>
</li>
</ul>
<h1 id="花钱-自购服务器系列"> 花钱（自购服务器系列</h1>
<ul>
<li>
<p>wordpress</p>
<ul>
<li>web半个全平台，还有后端编辑功能，具备完整的网站逻辑</li>
<li>框架有点臃肿，对网速要求高
<ul>
<li>对网络要求高就贵啊QAQ</li>
</ul>
</li>
</ul>
</li>
<li>
<p>nextcloud</p>
<ul>
<li>云盘，对笔记的支持局限于文件，虽然能编辑但是何必呢？</li>
</ul>
</li>
</ul>
<h1 id="总结"> 总结</h1>
<p>对于我来说，notion和语雀都是不错的选择，但自由度来说我比较喜欢notion，即使他有时候会上不去。。如果你在意稳定性还是建议你用语雀，他们都是很棒的产品！
​</p>
<p>以上仅仅是我个人的一些微不足道的看法，仅仅是我个人的看法，合不合适还是得自己去尝试的！</p>
]]></content:encoded>
    </item>
    <item>
      <title>mysql课记</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/notes/mysql_note/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/notes/mysql_note/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">mysql课记</source>
      <category>笔记</category>
      <pubDate>Tue, 27 Aug 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="前言"> 前言</h2>
<h1 id="sql常用命令集"> SQL常用命令集</h1>
<ul>
<li><strong>SELECT</strong>-从数据库在提取数据</li>
<li><strong>UPDATE</strong>-在数据库中更新数据</li>
<li><strong>DELETE</strong>-从数据库中删除数据</li>
<li><strong>INSERT INTO</strong>- 插入新的数据到数据库中</li>
<li><strong>CREATE DATABASE</strong>-创建一个新的数据库</li>
<li><strong>ALTER DATABASE</strong>-创建一个新的数据库</li>
<li><strong>CREATE TABLE</strong>-创建新表</li>
<li><strong>ALTER TABLE</strong>-修改表</li>
<li><strong>DROP TABLE</strong>-删除一个表</li>
<li><strong>CREATE INDEX</strong>-创建索引（搜索键）</li>
<li><strong>DROP INDEX</strong>-删除索引</li>
</ul>
<h1 id="数据类型"> 数据类型</h1>
<ul>
<li>INT整数 （长度若很长，则默认修改BIGINT）</li>
<li>FLOAT小数</li>
<li>CHAR字符串（保存0和1）</li>
<li>DATE日期（也是字符串，但是指定了日期）</li>
<li>TEXT可变长度的字符串</li>
<li>DECIMAL十进制（小数）10,2（表示为长度，小数位）</li>
<li>Blob是一个二进制的对象</li>
<li>长度，长度会占系统的空间，太长则占用很大空间，太短用户使用的时候则会被限制输入长度</li>
</ul>
<h1 id="基础"> 基础</h1>
<ol>
<li>SQL语句是不区分大小写的</li>
<li>此篇的SQL固定语句都会用大写英文来表示</li>
<li>小写的内容一般为可改的内容</li>
<li>在SQL中命名不建议使用中文</li>
</ol>
<h1 id="上手"> 上手</h1>
<h3 id="查看数据库与数据表"> 查看数据库与数据表</h3>
<div><pre><code><span># 查看数据库</span>
<span>SHOW</span> <span>DATABASES</span><span>;</span>
<span># 查看database_name数据库内所有的数据表</span>
<span>USE</span> database_name<span>;</span>
<span>SHOW</span> <span>TABLES</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="创建表"> 创建表</h3>
<div><pre><code><span># 在database_name里面创建数据表bookname</span>
<span>USE</span> database_name<span>;</span>
<span>CREATE</span> <span>TABLE</span> book_station<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="添加新列到数据表"> 添加新列到数据表</h3>
<div><pre><code><span>USE</span> database_name<span>;</span>
<span>ALTER</span> <span>TABLE</span> book_station<span>;</span>
<span>ADD</span> book_name <span>VARCHAR</span><span>(</span><span>10</span><span>)</span> <span>NOT</span> <span>NULL</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="删除旧列"> 删除旧列</h3>
<div><pre><code><span>USE</span> database_name<span>;</span>
<span>ALTER</span> <span>TABLE</span> book_station<span>;</span>
<span>DROP</span> <span>COLUMN</span> book_name<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="复制表"> 复制表</h3>
<div><pre><code><span># 这里只是复制表的框架，并不会带走里面的数据</span>
<span>CREATE</span> <span>TABLE</span> book_station LINK book_station_copy<span>;</span>
<span># 如果要完全复制</span>
<span>CREATE</span> <span>TABLE</span> book_station_copy2 <span>AS</span> <span>(</span><span>SELECT</span> <span>*</span> <span>FROM</span> book_station<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="重命名数据表"> 重命名数据表</h3>
<div><pre><code><span>USE</span> database_name<span>;</span>
<span>ALTER</span> <span>TABLE</span> book_station_copy<span>;</span>
<span>RENAME</span> <span>TO</span> new_book_station_copy<span>;</span>
<span># 批量的</span>
<span>RENAME</span> <span>TABLE</span> new_book_station_copy <span>TO</span> copy_book1<span>,</span> book_station_copy2 <span>TO</span> copy_book2<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="查看数据库内的指定列的结构"> 查看数据库内的指定列的结构</h3>
<div><pre><code><span>USE</span> database_name<span>;</span>
<span>DESC</span> book_station book_name<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="单表内数据修改"> 单表内数据修改</h3>
<div><pre><code><span># 修改数据表数据值</span>
<span>UPDATE</span> name <span>SET</span> name <span>=</span>‘xiaoming’<span>;</span>
<span># 对数据表内的值进行运算</span>
<span>UPDATE</span> bookname <span>SET</span> code <span>=</span> code <span>+</span> <span>10</span> <span>(</span><span>WHERE</span> name <span>=</span> <span>'小明'</span><span>)</span><span>;</span>
<span># 对数据表内多个值进行运算</span>
<span>UPDATE</span> bookname1<span>,</span>bookname2 <span>SET</span> bookname1<span>.</span>code <span>=</span> bookname1<span>.</span>code<span>+</span><span>10</span><span>,</span> book2<span>.</span>code <span>=</span> bookname2<span>.</span>code<span>+</span><span>20</span> <span>(</span><span>WHERE</span> bookname1<span>.</span>name<span>=</span><span>'小明'</span> <span>and</span> bookname1<span>.</span>name<span>=</span><span>'小红'</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="表的操作"> 表的操作</h2>
<p>mysql语句的解析</p>
<h3 id="添加数据"> 添加数据</h3>
<div><pre><code><span>/*语法：INSERT INTO 表名 (字段) VALUES (字段的值)*/</span>
<span>insert</span> <span>into</span>     <span>`</span><span>user</span><span>`</span> <span>(</span><span>`</span>id<span>`</span><span>,</span> <span>`</span>username<span>`</span><span>)</span> <span>values</span> <span>(</span><span>1</span><span>,</span> <span>'silence'</span><span>)</span><span>;</span>
<span>/*插入   往哪里   表名	    (字段)          值     (字段值)*/</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="删除数据"> 删除数据</h3>
<div><pre><code><span>/*语法：DELETE FROM 表名*/</span>
<span>delete</span> form <span>user</span><span>;</span>
<span>/*删除   从   表名*/</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="修改数据"> 修改数据</h3>
<div><pre><code><span>/*语法：UPDATE user SET username = 'test'*/</span>
<span>update</span> <span>user</span>   <span>set</span>  username <span>=</span> <span>'test'</span><span>;</span>
<span>/*修改   表名  设置   字段    = 字段值*/</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="查询数据"> 查询数据</h3>
<div><pre><code><span>/*语法：SELECT * FROM user*/</span>
<span>select</span>   <span>*</span>  <span>from</span>  <span>user</span><span>;</span>
<span>/*查询   字段  从   表名*/</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="联表查询"> 联表查询</h3>
<ul>
<li>
<p>多张表找到像关联的点，然后进行查询组合成一张表</p>
</li>
<li>
<p>as是用于另外起名</p>
</li>
<li>
<p>假设这里有两张表</p>
<div><pre><code>表1:school表内数据：
id     name
1      school1
2      school2
表2:teacher表内数据：
id    sid        name
1       2        小明
2       1        小红
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></li>
<li>
<p>两种简单的联表查询方法</p>
<div><pre><code><span>select</span> <span>*</span> <span>from</span> school <span>as</span> s <span>inner</span> <span>join</span> teacher <span>as</span> t <span>on</span> s<span>.</span>id <span>=</span> sid<span>;</span>
<span>select</span> <span>*</span> <span>from</span> school <span>as</span> s<span>,</span> teacher <span>as</span> t <span>where</span> s<span>.</span>id <span>=</span> sid<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
</ul>
<h2 id="select查询"> SELECT查询</h2>
<ul>
<li>
<p>最基本的查询：</p>
<div><pre><code><span>SELECT</span> <span>*</span> <span>FROM</span> book_station<span>;</span>
<span>/* 你也可以限制输出的数量（如果数据量大可以节省内存并快速输出）*/</span>
<span>/* 显示0-30行 */</span>
<span>SELECT</span> <span>*</span> <span>FROM</span> book_station <span>LIMIT</span> <span>0</span><span>,</span> <span>30</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
</ul>
<h3 id="as输出新的列表名"> AS输出新的列表名</h3>
<ul>
<li>
<p>这里AS可以定义新的列表名</p>
<div><pre><code><span>SELECT</span> sid <span>AS</span> 工号<span>,</span> name <span>AS</span> <span>"教师 名称"</span> <span>FROM</span> teacher<span>;</span>
<span>/*
工号        教师 名称
2        小明
1        小红
*/</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>
<li>这里假设有<code>book_name、book_date</code>这两个字段</li>
<li>AS可以让SELECT输出的时候将book_name这些字段替换成指定的名字</li>
<li>若指定的名字不连续，可以使用 双引号<code>&quot;&quot;</code> 或 单引号 <code>''</code> 括起来</li>
</ul>
</li>
</ul>
<h3 id="消除重复行结果distinct"> 消除重复行结果<code>DISTINCT</code></h3>
<ul>
<li>
<p>利用<code>DISTINCT</code> 可以将输出结果重复的列进行剔除</p>
<div><pre><code><span>/*假设teacher的数据为
id    sid        name
1       2        小明
2       1        小红
3       1        小红
*/</span>
<span>SELECT</span> <span>DISTINCT</span> sid<span>,</span> name <span>FROM</span> teacher<span>;</span>
<span>/*结果为：
sid      name
2        小明
1        小红
*/</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><ul>
<li>这里数据库会自动将重复的两个字段剔除掉一个并输出</li>
</ul>
</li>
</ul>
<h3 id="模拟匹配like"> 模拟匹配<code>LIKE</code></h3>
<ul>
<li>
<p>用LIKE表达式可以匹配数据，语法如同正则表达式那样，这里只列出一点</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>%</td>
<td>表示0个或多个字符</td>
</tr>
<tr>
<td>_</td>
<td>表示单个字符</td>
</tr>
<tr>
<td>#</td>
<td>#表示转义字符，和python中\一样,’#%’就是’%’而不是匹配字符</td>
</tr>
</tbody>
</table>
<div><pre><code><span>/*假设teacher的数据为
id    sid        name
1     1001        小明
2     100        小红
3     2002        小C
*/</span>
<span>SELECT</span> <span>*</span> <span>FROM</span> teacher <span>WHERE</span> sid <span>LIKE</span> <span>'100%'</span><span>;</span>
<span>/*结果为：
id    sid        name
1     1001        小明
2     100        小红
*/</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><ul>
<li>这里只匹配符合头为100的sid字段，%后面可以有许多个</li>
</ul>
</li>
</ul>
<h3 id="范围比较"> 范围比较</h3>
<ul>
<li>
<p>输出一定范围内的数字，这里使用的是<code>&gt; &lt; &gt;= &lt;= =</code></p>
<div><pre><code><span>/*假设teacher的数据为
id    sid        name
1     1001        小明
2     1110        小红
3     2002        小C
*/</span>
<span>SELECT</span> <span>*</span> <span>FROM</span> teacher <span>WHERE</span> sid sid <span>>=</span> <span>1000</span> <span>AND</span> sid <span>&lt;=</span> <span>2000</span><span>;</span>
<span>/*结果为：
id    sid        name
1     1001        小明
2     1110        小红
*/</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div></li>
</ul>
<h3 id="统计数据-count"> 统计数据 <code>COUNT</code></h3>
<ul>
<li>
<p>利用<code>COUNT()</code>可以统计输出的数据表内有多少条数据</p>
<div><pre><code><span>/*假设teacher的数据为
id    sid        name
1     1001        小明
2     1110        小红
3     2002        小C
*/</span>
<span>SELECT</span> <span>COUNT</span><span>(</span><span>*</span><span>)</span> <span>FROM</span> teacher <span>WHERE</span> <span>TRUE</span>
<span>/* 结果为
count(*)
3
*/</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><ul>
<li>COUNT(*) 表示统计所有的字段</li>
<li>WHERE TRUE可以理解为只要是存在的都输出</li>
</ul>
</li>
</ul>
<h3 id="条件输出语句-case"> 条件输出语句 <code>CASE</code></h3>
<ul>
<li>
<p>CASE ··· THEN ··· ELSE···END</p>
<div><pre><code><span>/*假设teacher的数据为
id    sid        name
1     1001        小明
2     1110        小红
*/</span>
<span>CASE</span> <span>*</span> <span>CASE</span>
<span>WHEN</span> sid <span>></span> <span>1100</span>
<span>THEN</span> <span>"他的工号大于1100"</span>
<span>ELSE</span> <span>"他的工号小于1100"</span>
<span>END</span> <span>AS</span> 结果
<span>FROM</span> teacher<span>;</span>
<span>/*结果为：
id    sid        name      结果
1     1001        小明      他的工号小于1100
2     1110        小红      他的工号大于1100
*/</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><ul>
<li>条件输出语句会将得到的结果单独作为一列输出</li>
</ul>
</li>
</ul>
<h3 id="数据计算-sum-求和与avg-求平均值"> 数据计算：SUM()求和与AVG()求平均值</h3>
<ul>
<li>
<p>SUM() 可以指定一些数据进行求和</p>
<div><pre><code><span>/*假设teacher的数据为
id    sid        name
1     1001        小明
2     1110        小红
*/</span>
<span>SELECT</span> <span>SUM</span><span>(</span>sid<span>)</span> <span>AS</span> 工号求和 <span>FROM</span> teacher<span>;</span>
<span>/*结果为
工号求和
2111
*/</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div></li>
</ul>
<h3 id="分组-group"> 分组``GROUP`</h3>
<ul>
<li>
<p>你可以指定一个字段一组一组的输出</p>
<div><pre><code><span>/*假设teacher的数据为
id    sid        name
1     1110        小红
2     1001        小明
3     2002        小红
*/</span>
<span>SELECT</span> <span>*</span> <span>FROM</span> teacher <span>WHERE</span> <span>TRUE</span> <span>GROUP</span> <span>BY</span> name <span>DESC</span><span>;</span>
<span>/*结果为
id    sid        name
1     1110        小红
3     2002        小红
2     1001        小明
*/</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><ul>
<li>GROUP···ASC/DESC
<ul>
<li>ASC为升序排序</li>
<li>DESC为降序排序</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="排序order"> 排序<code>ORDER</code></h3>
<ul>
<li>
<p>可以指定字段对其升序或降序排序，这个可以说是在GROUP的基础上实现的</p>
<div><pre><code><span>/*假设teacher的数据为
id    sid        name
1     1110        小红
2     1001        小明
3     2002        小红
*/</span>
<span>SELECT</span> <span>*</span> <span>FROM</span> teacher <span>WHERE</span> <span>TRUE</span> <span>GROUP</span> <span>BY</span> sid <span>ORDER</span> <span>BY</span> <span>ASC</span><span>;</span>
<span>/*结果为
id    sid        name
2     1001        小明
1     1110        小红
3     2002        小红
*/</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div></li>
</ul>
<h3 id="limit指定范围输出"> LIMIT指定范围输出</h3>
<ul>
<li>
<p>这个上面其实有稍微讲到</p>
<div><pre><code><span>/*假设teacher的数据为
id    sid        name
1     1110        小红
2     1001        小明
3     2002        小红
*/</span>
<span>SELECT</span> <span>*</span> <span>FROM</span> teacher <span>LIMIT</span> <span>2</span><span>;</span>
<span>/*结果为
id    sid        name
1     1110        小红
2     1001        小明
*/</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div></li>
</ul>
<h1 id="主键外键"> 主键外键</h1>
<ul>
<li>
<p>主键：primary key</p>
</li>
<li>
<p>外键：foreign key</p>
<ul>
<li>
<p>在创建表的时候添加外键</p>
<div><pre><code><span>foreign</span> <span>key</span> <span>(</span>表名<span>1</span><span>)</span>
	<span>references</span> book_name <span>(</span>表名<span>2</span><span>)</span>
	<span>(</span>以下按要求可填可不填<span>)</span>
<span>on</span> <span>delete</span> <span>restrict</span>	<span>#若当要删除book_name表名2的值时，若表名1列还有该值的记录时，拒绝对book_name的表名2的删除操作</span>
<span>on</span> <span>update</span> <span>restrict</span>	<span>#若当要更新book_name表名2的值时，若表名1列还有该值的记录时，拒绝对book_name的表名2的更新操作</span>
<span>on</span> <span>delete</span> <span>cascade</span>	<span>#当要删除book_name表名2的值时，同步对book_name的表名2的删除操作</span>
<span>on</span> <span>update</span> <span>cascade</span>	<span>#当要更新book_name表名2的值时，同步对book_name的表名2的更新操作</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
<li>
<p>在已有两个数据表的情况下设置为外键</p>
<div><pre><code><span>alter</span> <span>table</span> 数据表
<span>add</span> <span>foreign</span> <span>key</span> <span>(</span>表名<span>1</span><span>)</span>
	<span>references</span> 数据表<span>2</span> <span>(</span>表名<span>2</span><span>)</span>
		<span>on</span> <span>delete</span> <span>restrict</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
</ul>
</li>
<li>
<p>check约束</p>
<ul>
<li>
<p>约束只能输入指定值</p>
<div><pre><code><span># 若对性别列的内容只能包含男或女的时候可以输入以下内容</span>
<span>Alter</span> <span>table</span> account
<span>Add</span> <span>check</span><span>(</span>性别 <span>in</span> <span>(</span>‘男’<span>,</span>’女’<span>)</span><span>)</span>：

<span># 假设说你要给test表的OnUse字段添加check约束</span>
<span>alter</span> <span>table</span> test
<span>add</span> <span>constraint</span> ck_col <span>check</span><span>(</span>OnUse<span>=</span><span>0</span> <span>or</span> OnUse<span>=</span><span>1</span><span>)</span>
<span># 如果在新建表的时候则</span>
OnUse <span>int</span> <span>check</span><span>(</span>OnUse<span>=</span><span>0</span> <span>or</span> OnUse<span>=</span><span>1</span><span>)</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div></li>
<li>
<p>约束输入的值要大于某值：<code>Check( 出生日期 &gt; ‘1980-01-01’)</code></p>
</li>
<li>
<p>约束某值的所有值来源于某项：<code>check(性别 in (select 性别 from emp))</code></p>
</li>
<li>
<p>约束列表内值大于某值：<code>check (工资&gt;扣款)</code></p>
</li>
</ul>
</li>
</ul>
<h1 id="数据视图"> 数据视图</h1>
<h3 id="创建视图"> 创建视图</h3>
<div><pre><code><span>create</span> <span>view</span> view_name	<span>#创建视图表</span>
<span>as</span>
<span>#查询表product的三个列：productid, catid, name再根据productid排序 where 1的1代表显示数据，0表示不显示数据</span>

<span>select</span> productid<span>,</span> catid<span>,</span> name <span>from</span> product <span>where</span> <span>1</span> <span>order</span> <span>by</span> productid

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h1 id="数据安全"> 数据安全</h1>
<h2 id="账户"> 账户</h2>
<p>保证数据不丢失、不然未授权人员查看、篡改</p>
<h2 id="备份"> 备份</h2>
<p>热备份：在工作中做实时备份，备份的设备不止一台</p>
<p>冷备份：与热备份相比频率不高，一般为一个小时、一天或者一个月备份一次</p>
<ul>
<li>导出可使用第三方工具</li>
<li>导入也可以在第三方工具中导入</li>
</ul>
<h2 id="日志"> 日志</h2>
<p>日志，用来保存系统操作的日志，可大可小（按照规模分），可以记录追溯系统的操作</p>
<p>如果日志系统足够完整也能够恢复一定的内容（困难）</p>
<hr>
<h1 id="后续整理"> 后续整理</h1>
<div><p>整理说明</p>
<p>以下为后续整理的内容，懒得填补内容了...</p>
</div>
<h2 id="增"> 增</h2>
<ol>
<li>容器有两种：数据库、数据表，数据表在数据库内</li>
<li>可以新建一个放东西的容器，或者插入数据</li>
<li>每输入完一条SQL语句记得在末尾添加&quot;;&quot;让编译器知道你输入完了</li>
</ol>
<h3 id="上手-2"> 上手</h3>
<ul>
<li><code>CREATE DATABASE &quot;database_name&quot;;</code>
<ul>
<li>首先先建一个数据库<code>database</code>，数据库他可以装很多的数据表，就像一个放货架的仓库那样，而且在sql里他还是可以扩大的那种，十分方便！</li>
</ul>
</li>
</ul>
<div><pre><code><span># 创建数据库</span>
<span>CREATE</span> <span>DATABASE</span> <span>"database_name"</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>
<p><code>CREATE TABLE IF NOT EXISTS &quot;table_name&quot;(...)</code></p>
<p>现在就来建一个数据表<code>table</code>，数据表是用来存放数据的，这很像excel，他是由行<code>row</code>和列<code>column</code>组成，不同的是在建表的时候我们需要给他加上每列的名字，每行默认用序号代替此时我们可以把数据表看成城市里的一个房子🏠</p>
<div><pre><code><span># 创建数据表</span>
<span>CREATE</span> <span>TABLE</span> <span>IF</span> <span>NOT</span> <span>EXISTS</span> <span>"table_name"</span><span>(</span>
    name <span>CHAR</span><span>(</span><span>10</span><span>)</span> <span>NOT</span> <span>NULL</span> <span>COMMENT</span> <span>'名字'</span><span>,</span>
    id <span>int</span><span>(</span><span>15</span><span>)</span> <span>NOT</span> <span>NULL</span> <span>PRIMARY</span> <span>KEY</span><span>,</span>
    sex <span>CHAR</span><span>(</span><span>5</span><span>)</span> <span>NULL</span> <span>COMMENT</span> <span>'性别'</span><span>,</span>
    address <span>VARCHAR</span><span>(</span><span>20</span><span>)</span> <span>NULL</span>
<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ol>
<li>创建数据表内新一列的结构是这样的：
列名 类型(长度) [是否可空] [主/外键]
示例：<code>name CHAR(10) NOT NULL PRIMARY KEY</code>,
            ....</li>
<li><code>CREATE TABLE IF NOT EXISTS</code>若表不存在则创建，若表存在则跳过，有效避免了报错</li>
<li>每新建一列如果下面还有一列记得不要问忘记在后面加上&quot;,&quot; 否则会报错！</li>
<li>或许你会好奇上述的CHAR是什么？那是存放sql内的<strong>数据类型</strong>，可以参考这个[<a href="https://www.w3school.com.cn/sql/sql_datatypes.asp" target="_blank" rel="noopener noreferrer">传送门</a> ]</li>
<li>主键(PRIMARY KEY)/外键可以参考这个[<a href="https://blog.csdn.net/my98800/article/details/80102662" target="_blank" rel="noopener noreferrer">传送门</a>]</li>
<li><code>COMMENT '备注'</code>这个可以对该字段进行备注</li>
</ol>
</li>
<li>
<p>CREATE VIEW &quot;view_name&quot;(....)</p>
<p>视图是基于 SQL 语句的结果集的可视化的表。
视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。</p>
<div><pre><code><span># 请根据情况使用查询条件</span>
<span>CREATE</span> <span>VIEW</span> <span>"view_name"</span> <span>AS</span> <span>SELECT</span> <span>*</span> <span>FROM</span> <span>"table_name"</span> <span>where</span> <span>'广东省'</span> <span>in</span> address
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>INSERT INTO &quot;table_name&quot;(...) values(...)</p>
<p>当建好了城市的框架，那我们还缺什么？数据！这里你可以把数据看作居住在房子里的人🐇🚶👫👪</p>
<ol>
<li>首先你需要知道数据表的结构才能向其插入对应的数据</li>
<li>如果对应的数据表某列可为空可以则前面括号括起来的时候不写列名即可(详细请看代码)</li>
</ol>
<div><pre><code><span># 这里使用了上面建立的框架插入，请大家根据实际情况插入，以免报错</span>
<span># 插入数据</span>
<span>INSERT</span> <span>INTO</span> <span>"table_name"</span><span>(</span><span>'name'</span><span>,</span><span>'id'</span><span>,</span><span>'sex'</span><span>,</span><span>'address'</span><span>)</span> <span>VALUES</span><span>(</span><span>'小明'</span><span>,</span><span>201908291</span><span>,</span><span>'男'</span><span>,</span><span>'广东省n市'</span><span>)</span><span>;</span>
<span># 以上等同于</span>
<span>INSERT</span> <span>INTO</span> <span>"table_name"</span> <span>VALUES</span><span>(</span><span>'小刚'</span><span>,</span><span>201908292</span><span>,</span><span>'男'</span><span>,</span><span>'湖南省n2市'</span><span>)</span><span>;</span>
<span># 如果你需要插入指定的数据，values不填就好了</span>
<span>INSERT</span> <span>INTO</span> <span>"table_name"</span><span>(</span><span>'name'</span><span>,</span><span>'id'</span><span>,</span><span>'sex'</span><span>)</span> <span>VALUES</span><span>(</span><span>'小红'</span><span>,</span><span>201908293</span><span>,</span><span>'女'</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
</ul>
<h3 id="创建用户"> 创建用户</h3>
<ul>
<li>
<p>允许全部</p>
<p><code>create user &quot;root&quot;@&quot;%&quot; identified by &quot;password&quot;;</code>允许root从<code>任何IP</code>访问（不建议）</p>
</li>
<li>
<p>针对ip</p>
<p><code>create user &quot;root&quot;@&quot;192.168.1.10&quot; identified by &quot;password&quot;;</code>允许root从<code>192.168.1.10</code>通过<code>password</code>访问</p>
</li>
<li>
<p>指定用户通过“指定IP”访问“所有”的数据库</p>
<p><code>grant all privileges on *.* to &quot;root&quot;@&quot;192.168.1.99&quot; identified by &quot;password&quot;;</code>这里指定<code>root</code>只能通过<code>192.168.1.99</code>通过<code>password</code>这个密码来访问<code>所有</code>的数据库</p>
</li>
<li>
<p>指定用户通过“任何ip”访问“指定”的数据库</p>
<p><code>grant all privileges on bit.* to &quot;bit&quot;@&quot;%&quot; identified by &quot;password&quot; with grant option;</code>这里指定<code>bit</code>允许通过<code>任何ip</code>通过<code>password</code>这个密码来访问<code>bit</code>数据库</p>
</li>
</ul>
<h2 id="删"> 删</h2>
<p>删前要看仔细，千万要加上条件！不然全没了 (。﹏。·)</p>
<div><pre><code><span># 删除数据库</span>
<span>DROP</span> <span>DATABASE</span> <span>"database_name"</span><span>;</span>
<span># 删除数据表</span>
<span>DROP</span> <span>TABLE</span> <span>"table_name"</span>
<span># 删除视图表</span>
<span>DROP</span> <span>VIEW</span> <span>"view_name"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>
<li>
<p>你也可以删除数据表里面的数据，这种时候建议加上<code>WHERE</code>条件</p>
<div><pre><code><span># 删除指定数据表所有数据</span>
<span>DELETE</span> <span>FROM</span> <span>"table_name"</span>
<span># 带条件的删除数据</span>
<span>DELETE</span> <span>FROM</span> <span>"TABLE_NAME"</span> <span>WHERE</span> <span>'id'</span> <span>=</span> <span>201908291</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
</ul>
<h2 id="改"> 改</h2>
<div><pre><code><span># 修改数据表数据值</span>
<span>UPDATE</span> name <span>SET</span> name <span>=</span>‘xiaoming’<span>;</span>
<span># 对数据表内的值进行运算</span>
<span>UPDATE</span> bookname <span>SET</span> code <span>=</span> code <span>+</span> <span>10</span> <span>(</span><span>WHERE</span> name <span>=</span> <span>'小明'</span><span>)</span><span>;</span>
<span># 对数据表内多个值进行运算</span>
<span>UPDATE</span> bookname1<span>,</span>bookname2 <span>SET</span> bookname1<span>.</span>code <span>=</span> bookname1<span>.</span>code<span>+</span><span>10</span><span>,</span> book2<span>.</span>code <span>=</span> bookname2<span>.</span>code<span>+</span><span>20</span> <span>(</span><span>WHERE</span> bookname1<span>.</span>name<span>=</span><span>'小明'</span> <span>and</span> bookname1<span>.</span>name<span>=</span><span>'小红'</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="查"> 查</h2>
<ul>
<li>SHOW
<ul>
<li><code>SHOW DATABASES</code> 查看数据库</li>
<li><code>SHOW TABLES</code> 查看数据表</li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>网络安全课记</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/notes/security_note/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/notes/security_note/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">网络安全课记</source>
      <category>笔记</category>
      <pubDate>Mon, 16 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="网络安全"> 网络安全</h1>
<h2 id="kali基础操作"> kali基础操作</h2>
<h3 id="基础"> 基础</h3>
<ul>
<li>
<p>查看网络配置
<code>Ifconfig</code></p>
</li>
<li>
<p>为网卡配置ip地址
<code>Ifconfig eth0 192.168.1.1</code></p>
</li>
<li>
<p>为系统配置网关
<code>Route add default 192.168.1.2</code></p>
</li>
<li>
<p>网络连接状态
<code>Netstat</code>
<code>Netstat –nr # 简洁方式查看</code></p>
</li>
<li>
<p>网络配置文件</p>
<div><pre><code>Vi /etc/resolv.conf
Vi /etc/network/interfaces
	Iface eth0 inet static  <span># 配置静态ip</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p>更新kali软件源
<code>Apt-get update</code></p>
</li>
<li>
<p>更新kali软件</p>
<div><pre><code>Apt-get upgrade
Sudo –-<span>></span>  super <span>do</span> 管理员账号
<span># 出现问题解决方法：</span>
Sudo <span>rm</span> /var/lib/lib/dpkg/lock
Sudo <span>rm</span> /var/cache/apt/archives/lock
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p>查询某个域名下公司的信息</p>
<div><pre><code>whois url地址
	whois baidu.com
<span>dig</span> url地址 any @DNS服务器IP
	<span>dig</span> baidu.com any @8.8.8.8  <span># 更多</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
<li>
<p>向域名服务器发送DNS区域传输请求（获取DNS上有的信息）如果禁用了就不能被下载</p>
<div><pre><code><span>dig</span> @DNS的url地址 axfr 注意
	<span>dig</span> @ns4.baidu.com axfr
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>路径追踪</p>
<div><pre><code><span>dig</span> +trace url地址
	<span>dig</span> +trace www.baidu.com
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>查询帮助文档
man 命令</p>
<div><pre><code>	<span>man</span> <span>nslookup</span>
命令 -h
	<span>dig</span> -h
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p>查询域名的ip地址</p>
<div><pre><code><span>host</span> <span>[</span>-w -num超时时间<span>]</span> 域名
	<span>host</span> www.baidu.com
	<span>host</span> -w -4 www.baidu.com
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p>暴力破解</p>
</li>
</ul>
<ol>
<li>
<p><code>dnsenum -dns DNS地址 -wordlist 字典绝对路径</code></p>
<ul>
<li><code>&gt;dnsenum -dns dns.baidu.com -wordlist /user/.../\*txt</code></li>
</ul>
</li>
<li>
<p><code>dnsmap www.sina.com -w /user/..../*txt</code></p>
</li>
<li>
<p><code>fierce [-dnsserver DNS服务器IP] -dns DNSurl /user/.../\*.txt</code></p>
<div><pre><code>  <span>></span>fierce -dnsserver <span>8.8</span>.8.8 -dns dns.sina.com /user/<span>..</span>./*.txt
 <span>></span>fierce -dnsserver <span>8.8</span>.8.8 -dns sina.com.cn -wordlist /user/<span>..</span>./*.txt
<span>></span>fierce -dns sina.com.cn -wordlist /user/<span>..</span>./<span>\</span>*.txt
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p><code>dnsrecon -d www.baidu.com -D /user/.../\*.txt</code></p>
</li>
</ol>
<ul>
<li>寻找文件<div><pre><code>dpkg -L 命令
dpkg -L dnsenum
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
</ul>
<ul>
<li>
<p>可以查询某个域名下公司的信息</p>
<ul>
<li>
<p>whois url地址
<code>&gt; whois baidu.com</code></p>
</li>
<li>
<p>dig url地址 any @DNS服务器
<code>&gt; dig baidu.com any @8.8.8.8 # 更多</code></p>
</li>
</ul>
</li>
<li>
<p>向域名服务器发送DNS区域传输请求（获取DNS上有的信息），如果禁用了就不能被下载</p>
<ul>
<li>dig @url地址 axfr</li>
</ul>
<blockquote>
<p>dig @ns4.baidu.com axfr</p>
</blockquote>
</li>
<li>
<p>路径追踪</p>
<ul>
<li>dig +trace url地址</li>
</ul>
<blockquote>
<p>dig +trace www.baidu.com</p>
</blockquote>
</li>
<li>
<p>查询帮助文档</p>
<ul>
<li>man 命令</li>
</ul>
</li>
</ul>
<blockquote>
<p>man nslookup</p>
</blockquote>
<div><pre><code>* 命令 -h
    
    &gt; dig -h
</code></pre>
</div><h2 id="tracert追踪"> tracert追踪</h2>
<ul>
<li>tcp类型的trace追踪</li>
</ul>
<blockquote>
<p>tcptraceroute www.baidu.com</p>
</blockquote>
<ul>
<li>trace80端口
<ul>
<li>-i 指定设备追踪</li>
<li>-d  指定目的</li>
</ul>
<blockquote>
<p>tctrace -i eth0 -d www.baidu.com</p>
</blockquote>
</li>
</ul>
<h2 id="搜索引擎"> 搜索引擎</h2>
<p>高级搜索引擎 - 搜索网络在线设备</p>
<ul>
<li>
<p>www.shodan.io
私的账号密码：abcd789/12345678</p>
<ul>
<li>寻找网络摄像头</li>
</ul>
<blockquote>
<p>webcam/wificam</p>
</blockquote>
<ul>
<li>关键字添加：Country:&quot;US&quot;</li>
</ul>
</li>
<li>
<p>theharvester kali自带的搜索引擎</p>
<ul>
<li>-l 可并发搜索</li>
<li>例如：</li>
</ul>
<blockquote>
<p>theharvester -d microsoft.com -l 50 -b baidu</p>
</blockquote>
</li>
<li>
<p>俄罗斯的搜索引擎</p>
</li>
</ul>
<blockquote>
<p>yandex.com</p>
</blockquote>
<ul>
<li>百度文库解析下载</li>
</ul>
<blockquote>
<p>www.baiduvvv.com</p>
</blockquote>
<h2 id="暴力字典生成-照片信息获取"> 暴力字典生成&amp;照片信息获取</h2>
<ul>
<li>
<p>生成自己暴力字典</p>
<blockquote>
<p>git clone https://github.com/Mebus/cupp.git</p>
</blockquote>
<ul>
<li>
<p>生成暴力字典：</p>
<blockquote>
<p>python3 cupp.py -i</p>
</blockquote>
<p>根据要求输入对应的信息，完成后即可得到一个<code>姓.txt</code>的文件，如果不清楚可回车跳过</p>
</li>
</ul>
</li>
<li>
<p>查看照片信息 - exif</p>
<blockquote>
<p>exif photoname.jpg</p>
</blockquote>
<ul>
<li>http://www.gpsspg.com/maps.htm</li>
</ul>
<blockquote>
<p>经纬度查询：38 39 6.48,104 04 35.11</p>
</blockquote>
</li>
</ul>
<h2 id="自动收集信息"> 自动收集信息</h2>
<ul>
<li>
<p><code>recon-ng</code> 启动</p>
<ul>
<li>
<p><code>help</code> 查看当前可用命令</p>
</li>
<li>
<p><code>show model</code> 显示模块</p>
</li>
<li>
<p><code>show schema</code> 显示参数</p>
</li>
<li>
<p><code>workspaces</code> 工作区</p>
<ul>
<li><code>workspaces add spacename</code>添加工作区的名字</li>
<li><code>workspaces list</code> 查看拥有的工作区</li>
<li><code>workspaces select spacename</code> 选择spacename名字的工作区</li>
</ul>
<ol>
<li><code>use recon/domains-hosts/brute_hosts</code> 使用brute暴力破解工具</li>
</ol>
<div><pre><code>  *   `set source baidu.com` 设置指定的目标
  *   `run` 输入了上面的目标之后run就可以开始了
  *   `show options` 查看可用选项
  *   `show hosts/query select * from hosts` 查看结果
</code></pre>
</div><ol start="2">
<li><code>use recon/domains-hosts/bing_domain_web</code> 使用<code>bing_doamin_web</code>模块
<ul>
<li>与上面一样同样设置目标run即可</li>
</ul>
</li>
<li>查看报告
<ul>
<li><code>use reporting/html</code> 使用这个模块生成报告</li>
<li><code>set CREATOR name</code> 设置创建者名字</li>
<li><code>set CUSTOMER name</code> 设置查看者</li>
<li><code>run</code> 输入run运行即可，他会生成在本地上</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="杂谈"> 杂谈</h1>
<p>其实关于此课还是实操颇多，许多关于实操的记录也并未记下，唯想聊胜于无也</p>
]]></content:encoded>
    </item>
    <item>
      <title>网站分享</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/opinions/links/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/opinions/links/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">网站分享</source>
      <category>杂谈</category>
      <pubDate>Mon, 24 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="资讯"> 资讯</h2>
<ul>
<li>安妮薇时报：http://anyway.news/</li>
<li>少数派：https://sspai.com/</li>
<li>吾爱破解：https://www.52pojie.cn/</li>
<li>太平洋电脑网：https://product.pconline.com.cn/</li>
<li>小刀娱乐：https://www.x6d.com/</li>
</ul>
<h2 id="推荐"> 推荐</h2>
<ul>
<li>笔记软件
<ul>
<li>notion：notion.so</li>
<li>flomo：https://flomoapp.com</li>
<li>语雀：https://www.yuque.com/</li>
<li>trello：https://trello.com/</li>
</ul>
</li>
</ul>
<h2 id="软件分享"> 软件分享</h2>
<ul>
<li>果核剥壳：https://www.ghpym.com/</li>
<li>胡萝卜周：http://www.carrotchou.blog/</li>
<li>精品MAC分享：https://xclient.info/</li>
<li>我爱分享网：http://www.zhanshaoyi.com/</li>
<li>吾爱分享网：https://52sharing.cn/</li>
<li>问答库：https://www.asklib.com/</li>
</ul>
<h2 id="学习"> 学习</h2>
<ul>
<li>平台
<ul>
<li>菜鸟教程：https://www.runoob.com/</li>
<li>网易云课堂：https://study.163.com/</li>
<li>中国大学MOOC：https://www.icourse163.org/</li>
<li>爱课程：https://www.icourses.cn/home/</li>
<li>大学资源网：http://www.dxzy163.com/</li>
<li>腾讯课堂：https://ke.qq.com/</li>
<li>实验楼https://www.shiyanlou.com/</li>
<li>微学苑：http://www.weixueyuan.net/</li>
<li>极客时间：https://time.geekbang.org/</li>
<li>GitHub：https://github.com/</li>
<li>gitee：https://gitee.com/</li>
</ul>
</li>
<li>个人
<ul>
<li>oeasy：http://oeasy.org/</li>
<li>小甲鱼：https://fishc.com.cn/</li>
<li>kuangstudy：https://www.kuangstudy.com/course</li>
</ul>
</li>
</ul>
<h2 id="coding💻"> Coding💻</h2>
<ul>
<li>markdown数学公式转换：https://www.codecogs.com/latex/eqneditor.php</li>
<li>快代理：https://www.kuaidaili.com/ops/</li>
<li>md5加解密：https://www.cmd5.com/</li>
<li>IP地址查询：http://tool.cc/ip/</li>
</ul>
<h3 id="在线编程"> 在线编程</h3>
<ul>
<li>deepnote：https://deepnote.com/</li>
<li>菜鸟工具：https://c.runoob.com/</li>
<li>AnyCodes：https://www.anycodes.cn/#/OnlineCode</li>
<li>在线编辑html：https://codepen.io/</li>
</ul>
<h3 id="内网穿透"> 内网穿透</h3>
<ul>
<li>https://diannaobos.com/frp/</li>
</ul>
<h2 id="阅读"> 阅读</h2>
<ul>
<li>温泉学堂：https://www.wqxuetang.com/</li>
<li>一起阅读：https://sobooks.cc/</li>
<li>kindle吧：https://www.kindle8.cc/</li>
<li>IREAD阅读：http://www.iread.cf</li>
</ul>
<h2 id="搜索"> 搜索</h2>
<ul>
<li>西林街搜索：https://xilinjie.cc/</li>
<li>cupfox综合搜索：https://www.cupfox.com/</li>
<li>chrome插件网：https://chromecj.com/</li>
<li>magi：https://magi.com/</li>
<li>鸠摩搜索：https://www.jiumodiary.com/</li>
<li>报告查一查：http://report.seedsufe.com/index#/report</li>
</ul>
<h3 id="ppt"> PPT</h3>
<ul>
<li>ppt模板网站：https://slidesgo.com/</li>
</ul>
<h2 id="设计"> 设计</h2>
<h3 id="设计站"> 设计站</h3>
<ul>
<li>站酷：https://www.zcool.com.cn/</li>
<li>花瓣：https://huaban.com/?md=chrome_ex</li>
<li>千库网：https://588ku.com/</li>
<li>90设计：http://90sheji.com/</li>
<li>浮世绘：https://ja.ukiyo-e.org</li>
</ul>
<h3 id="字体"> 字体</h3>
<p>字魂网（免费字体）：https://izihun.com/</p>
<h3 id="图片素材"> 图片素材</h3>
<ul>
<li>pexels免费图片素材：https://www.pexels.com/zh-cn/</li>
<li>unsplash图片素材：https://unsplash.com/</li>
<li>pixabay图片素材：https://pixabay.com/</li>
<li>动漫插画：https://www.pixiv.net/</li>
<li>logo：http://www.logobook.com/</li>
<li>天空云朵图片素材：https://www.ianfisherart.com/gallery/painting</li>
<li>4K高清壁纸：https://pic.netbian.com/</li>
<li>背景生成器：https://bggenerator.com/zh-cn.php</li>
<li>模板素材：https://elements.envato.com/</li>
<li>恶魔头像生成：http://makemon.starfree.jp/</li>
</ul>
<h3 id="在线设计"> 在线设计</h3>
<ul>
<li>figma：https://www.figma.com/</li>
<li>可画：https://www.canva.cn/</li>
<li>在线PS：https://www.uupoop.com/</li>
<li>fotor在线设计：https://www.fotor.com.cn/</li>
<li>创客贴在线设计：https://www.chuangkit.com/dc.html</li>
<li>在线音频剪辑：https://www.weixinsyt.com/</li>
<li>在线视频剪辑：https://clipchamp.com/</li>
<li>哔哩哔哩云剪辑：https://member.bilibili.com/studio/bs-editor/projects</li>
</ul>
<h3 id="图片处理"> 图片处理</h3>
<ul>
<li>图片处理集合：https://coding.tools/cn</li>
<li>图片EXIF信息删除：https://coding.tools/cn/exif-remover</li>
<li>图片智能放大：https://bigjpg.com/</li>
<li>图片放大：https://icons8.com/upscaler?ref=appinn</li>
<li>图片背景消除：https://www.remove.bg/zh</li>
<li>修复图片：https://www.nvidia.com/en-us/research/</li>
</ul>
<h3 id="图床"> 图床</h3>
<ul>
<li>聚合图床https://www.superbed.cn/</li>
<li>免费图库：https://www.pexels.com/zh-tw/</li>
<li>picx图床：https://picx.xpoet.cn/#/upload</li>
<li>路过图床：https://imgchr.com/</li>
<li>sm图床：https://sm.ms/</li>
</ul>
<h3 id="图片搜索"> 图片搜索</h3>
<ul>
<li>百度识图：https://graph.baidu.com/pcpage/index?tpl_from=pc</li>
<li>图片搜索：https://saucenao.com/</li>
<li>图片搜索：https://trace.moe/</li>
<li>图片搜索：http://www.iqdb.org/</li>
<li>动漫漫画图片搜索：https://ascii2d.net/</li>
</ul>
<h2 id="表单-问卷制作"> 表单/问卷制作</h2>
<ul>
<li>腾讯问卷：https://wj.qq.com/</li>
<li>WPS表单：https://f.wps.cn/</li>
<li>麦客：http://www.mikecrm.com/</li>
<li>问卷星：https://www.wjx.cn/</li>
<li>问卷网：https://www.wenjuan.com/</li>
</ul>
<h2 id="工具"> 工具</h2>
<ul>
<li>文档格式转换（pdf、word、png、jpg）：https://smallpdf.com/cn</li>
<li>数据可视化：https://www.highcharts.com.cn/</li>
</ul>
<h3 id="导航站"> 导航站</h3>
<ul>
<li>安全：http://i.zkaq.org/</li>
</ul>
<h3 id="集合工具箱"> 集合工具箱</h3>
<ul>
<li>孟坤工具箱：http://tool.mkblog.cn/</li>
<li>CC工具箱 ：http://i.tool.cc/t/  查询、域名、调色、编码加密、头像图标、短链生成...</li>
<li>CC工具箱：http://url.tool.cc/</li>
<li>一个工具箱：http://www.atoolbox.net/</li>
<li>一言：https://hitokoto.cn/</li>
<li>万能命令：https://wanneng.run/cn/</li>
</ul>
<h3 id="在线工具"> 在线工具</h3>
<ul>
<li>云桌面：https://uzer.me/</li>
<li>百度脑图：https://naotu.baidu.com/</li>
<li>Process 在线制作流程图：https://www.processon.com/</li>
<li>在线流程图工具：https://online.visual-paradigm.com/cn/diagrams/features/flowchart-tool/</li>
<li>在线Markdoown：https://www.zybuluo.com/mdeditor</li>
</ul>
<h3 id="图片处理-2"> 图片处理</h3>
<ul>
<li>AI图片放大：https://bigjpg.com/</li>
<li>图片压缩 图好快：https://www.tuhaokuai.com/image</li>
<li>图片优化 智图：https://zhitu.isux.us/</li>
<li>在线上色 petalica paint：https://petalica-paint.pixiv.dev/index_zh.html</li>
</ul>
<h3 id="图标"> 图标</h3>
<ul>
<li>bccn：https://www.bccn.net/run/</li>
<li>Emoji表情：http://www.5vmc.com/emoji/index.html</li>
<li>Emoji符号大全http://www.fhdq.net/emoji/emojifuhao.html</li>
<li>easyicon：https://www.easyicon.net/</li>
</ul>
<h3 id="其他"> 其他</h3>
<ul>
<li>bilibili直播插件：https://www.danmuji.org/plugins/</li>
<li>金山文档：https://www.kdocs.cn/latest</li>
<li>默沙东诊疗手册：https://www.msdmanuals.cn/%E9%A6%96%E9%A1%B5</li>
</ul>
<h2 id="文件传输🚚"> 文件传输🚚</h2>
<ul>
<li>奶牛快传：https://cowtransfer.com/</li>
<li>文叔叔：https://www.wenshushu.cn/</li>
<li>firefox send：https://send.firefox.com/</li>
</ul>
<h2 id="英汉词典"> 英汉词典</h2>
<ul>
<li>英汉词典：https://dictionary.cambridge.org/</li>
<li>谷歌翻译：https://translate.google.cn/</li>
</ul>
<h3 id="插件推荐"> 插件推荐</h3>
<ul>
<li>沙拉查词：https://saladict.crimx.com/</li>
</ul>
<h2 id="短链生成"> 短链生成</h2>
<ul>
<li>量子短链：https://dwzz.run/</li>
<li>CC工具箱：http://url.tool.cc/</li>
</ul>
<h2 id="临时邮箱"> 临时邮箱</h2>
<ul>
<li>10分钟邮箱：https://bccto.me/?lang=cn</li>
<li>临时邮箱：http://linshiyouxiang.net/</li>
</ul>
<h2 id="短信接码"> 短信接码</h2>
<ul>
<li>免费解码（短信）：https://www.becmd.com/</li>
<li>超级云短信：https://www.bfkdim.com/</li>
<li>云短信：https://www.materialtools.com/</li>
</ul>
<h2 id="打法时间系列-🚩"> 打法时间系列...🚩</h2>
<ul>
<li>五子棋：https://playtictactoe.org/  电脑蛮厉害的hhh</li>
<li>小霸王：https://www.yikm.net/</li>
</ul>
<h3 id="影视"> 影视</h3>
<ul>
<li>一刻电影：http://www.yikedy.co/</li>
<li>低端影视：https://ddrk.me/</li>
<li>茶杯狐：https://www.cupfox.com/</li>
<li>云猫电影院：https://www.btkittycat.com/</li>
<li>五五影院：https://www.55yyy.cc/</li>
<li>好片网：https://www.cnwml.com/</li>
<li>片库网：http://pianku.cf/</li>
</ul>
<h3 id="动漫"> 动漫</h3>
<ul>
<li>A站：https://www.acfun.cn/</li>
<li>B站：http://www.bilibili.com/</li>
<li>C站：https://clicli.me/</li>
<li>D站：http://diliktv.com/</li>
<li>E站：http://www.ezdmw.com/</li>
<li>M站：http://www.bimibimi.tv/</li>
<li>咪哩咪哩：http://www.milimili.tv/</li>
<li>漫猫：http://www.comicat.org/</li>
</ul>
<h2 id="破解"> 破解</h2>
<h3 id="视频解析"> 视频解析</h3>
<ul>
<li>哔哩哔哩视频解析：https://xbeibeix.com/api/bilibili/</li>
<li>youtube视频解析：https://en.savefrom.net/20/</li>
<li>视频下载：http://douyin.haiya360.com/</li>
</ul>
<h3 id="在线音乐搜索"> 在线音乐搜索</h3>
<ul>
<li>MyFreeMP3：http://tool.liumingye.cn/music/</li>
<li>懒人全网音乐下载：http://www.eggvod.cn/music/</li>
<li>音乐格式解密：https://tool.liumingye.cn/music/unlock-music/</li>
</ul>
<h3 id="漫画"> 漫画</h3>
<ul>
<li>全民漫画：https://github.com/hongchacha/cartoon</li>
</ul>
<h2 id="浏览器插件推荐"> 浏览器插件推荐</h2>
<ul>
<li>Tampermonkey（油猴）：http://www.tampermonkey.net/
<ul>
<li>备：https://chromecj.com/web-development/2017-05/745.html</li>
</ul>
</li>
<li>油猴配合食用GreasyFork💊：https://greasyfork.org/zh-CN</li>
<li>floccus（同步收藏夹）：<a href="https://microsoftedge.microsoft.com/addons/detail/floccus-bookmarks-sync/gjkddcofhiifldbllobcamllmanombji" target="_blank" rel="noopener noreferrer">跳转链接</a></li>
<li>Vimium：<a href="https://microsoftedge.microsoft.com/addons/detail/vimium-c-%E5%85%A8%E9%94%AE%E7%9B%98%E6%93%8D%E4%BD%9C%E6%B5%8F%E8%A7%88%E5%99%A8/aibcglbfblnogfjhbcmmpobjhnomhcdo" target="_blank" rel="noopener noreferrer">跳转链接</a></li>
<li>集装箱：https://a.newday.me/</li>
<li>哔哩哔哩助手：<a href="https://microsoftedge.microsoft.com/addons/detail/%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9%E5%8A%A9%E6%89%8B%EF%BC%9Abilibilicom-%E7%BB%BC%E5%90%88%E8%BE%85%E5%8A%A9%E6%89%A9/fcfebhekhbkhjjimonjmbgmkbclheaoh" target="_blank" rel="noopener noreferrer">跳转链接</a></li>
</ul>
<h2 id="工作"> 工作</h2>
<ul>
<li>职友网：https://www.jobui.com/</li>
<li>牛客网：https://www.nowcoder.com/</li>
<li>电鸭：https://eleduck.com/</li>
</ul>
<h2 id="其他-2"> 其他</h2>
<ul>
<li>jet🐔活：http://idea.medeming.com/jet/</li>
<li>全球台风：https://zoom.earth/storms/</li>
</ul>
<h2 id="你看看人家-多学习学习人家"> 你看看人家，多学习学习人家</h2>
<ul>
<li>你看看人家
<ul>
<li>阮一峰的网络日志：http://www.ruanyifeng.com/blog/</li>
<li>大佬博客：https://ioliu.cn/</li>
<li>大佬博客：http://www.kingname.info/</li>
<li>大佬博客：https://jikeyuedu.cn/hot</li>
<li>大佬博客：http://pengzhihui.xyz/</li>
<li>大佬博客：https://www.playpcesor.com/</li>
</ul>
</li>
<li>多学习学习人家
<ul>
<li>中文排版指南：https://github.com/sparanoid/chinese-copywriting-guidelines</li>
<li>校招指南：https://sspai.com/post/64458</li>
<li>Mathematics 写给文科生的数学：https://courses.lumenlearning.com/waymakermath4libarts/</li>
<li>CS面试指南：https://github.com/CyC2018/CS-Notes</li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>浏览器插件汇总</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/opinions/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/opinions/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">浏览器插件汇总</source>
      <category>杂谈</category>
      <pubDate>Tue, 16 Mar 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>以下是推荐的插件，仅供参考</p>
<ul>
<li>
<p>tampermonkey-油猴</p>
<ul>
<li>HTML5视频播放器增强脚本：
<a href="https://greasyfork.org/zh-CN/scripts/381682-html5%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8%E5%A2%9E%E5%BC%BA%E8%84%9A%E6%9C%AC" target="_blank" rel="noopener noreferrer">HTML5视频播放器增强脚本</a></li>
<li>豆瓣资源下载大师：
<a href="https://greasyfork.org/zh-CN/scripts/329484-%E8%B1%86%E7%93%A3%E8%B5%84%E6%BA%90%E4%B8%8B%E8%BD%BD%E5%A4%A7%E5%B8%88-1%E7%A7%92%E6%90%9E%E5%AE%9A%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1-%E9%9F%B3%E4%B9%90-%E5%9B%BE%E4%B9%A6%E4%B8%8B%E8%BD%BD" target="_blank" rel="noopener noreferrer">豆瓣资源下载大师：1秒搞定豆瓣电影|音乐|图书下载</a></li>
<li>自动跳转某些网站不希望用户直达的外链
<a href="https://greasyfork.org/zh-CN/scripts/412612-open-the-f-king-url-right-now" target="_blank" rel="noopener noreferrer">Open the F**king URL Right Now</a></li>
</ul>
</li>
<li>
<p>pocket
内容收藏夹
<a href="https://chrome.google.com/webstore/detail/save-to-pocket/niloccemoadcdkdjlinkgdfekeahmflj?hl=zh-CN" target="_blank" rel="noopener noreferrer">Save to Pocket</a></p>
</li>
<li>
<p>billfish
图片管理
<a href="https://www.billfish.cn/" target="_blank" rel="noopener noreferrer">Billfish素材管理工具</a>
<a href="https://chrome.google.com/webstore/detail/billfish-free-material-ma/piohkopmiebhgodfkcfcmjbmgkcnjnmf?hl=zh-CN" target="_blank" rel="noopener noreferrer">Billfish - 免费素材管理工具</a></p>
</li>
<li>
<p>vimium
让浏览器可以像VIM那样操作
<a href="https://chrome.google.com/webstore/detail/vimium-c-all-by-keyboard/hfjbmagddngcpeloejdejnfgbamkjaeg?hl=zh-CN" target="_blank" rel="noopener noreferrer">Vimium C - 全键盘操作浏览器</a></p>
</li>
<li>
<p>集装箱
浏览器插件的集合
<a href="https://chrome.google.com/webstore/detail/%E9%9B%86%E8%A3%85%E7%AE%B1/kbgigmcnifmaklccibmlepmahpfdhjch?hl=zh-CN" target="_blank" rel="noopener noreferrer">集装箱</a></p>
</li>
<li>
<p>floccus
浏览器收藏夹同步
<a href="https://chrome.google.com/webstore/detail/floccus-bookmarks-sync/fnaicdffflnofjppbagibeoednhnbjhg?hl=zh-CN" target="_blank" rel="noopener noreferrer">floccus bookmarks sync</a></p>
</li>
<li>
<p>沙拉查词
聚合翻译
<a href="https://chrome.google.com/webstore/detail/%E6%B2%99%E6%8B%89%E6%9F%A5%E8%AF%8D-%E8%81%9A%E5%90%88%E8%AF%8D%E5%85%B8%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91/cdonnmffkdaoajfknoeeecmchibpmkmg?hl=zh-CN" target="_blank" rel="noopener noreferrer">沙拉查词-聚合词典划词翻译</a></p>
</li>
<li>
<p>The Great suspender
注：Edge新版本中添加了自带的休眠功能！
浏览器标签休眠，之前貌似有人嵌入恶意代码...这个版本貌似是修正版
<a href="https://chrome.google.com/webstore/detail/the-great-suspender-origi/ahmkjjgdligadogjedmnogbpbcpofeeo?hl=zh-CN" target="_blank" rel="noopener noreferrer">The Great Suspender Original</a></p>
</li>
<li>
<p>notion boost
能对notion添加一些新功能，例如滑倒最上面、标题导航栏
<a href="https://chrome.google.com/webstore/detail/eciepnnimnjaojlkcpdpcgbfkpcagahd" target="_blank" rel="noopener noreferrer">Notion Boost</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Home</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">Home</source>
    </item>
    <item>
      <title>交换机巡检与备份</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/toss/Econnect/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/toss/Econnect/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">交换机巡检与备份</source>
      <category>折腾</category>
      <pubDate>Sun, 17 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="更新终止🚧"> 更新终止🚧</h2>
<p>由于个人问题，除非bug发生了或者是新的想法冒出来了，项目就暂时搁置于此了。Econnect已经更新到了1.3的版本了，在目前来说也算是较为完善的版本了；最后这里感谢下MIRAI与校NIC</p>
<h2 id="下载"> 下载</h2>
<p>具体文件可在<a href="https://github.com/MLLR-L/Econnect/releases" target="_blank" rel="noopener noreferrer">releases</a>中下载</p>
<h2 id="特色"> 特色</h2>
<p>Econnect由python制作而成，.exe文件为打包好的脚本，无需安装具体环境</p>
<ul>
<li>范围选择</li>
<li>信息录入
<ul>
<li>采用csv文件录入，具体格式请看标题或下面，第一行切记请勿更改！</li>
<li>IP地址, 用户名, 密码, enable密码</li>
</ul>
</li>
<li>备份
<ul>
<li>自带tftp服务器，无需另外开启</li>
<li>自动备份到一个<code>tftp_box</code>的文件夹内，下一层为<code>YYYYMMDDhh</code>，具体备份文件为<code>交换机名+ip第四位.text</code></li>
<li>开启tftp服务前会检测本地是否有程序占用69端口，若占用则会kill对应进程</li>
<li>备份命令：copy flash:config.text tftp://<strong>IP</strong>//<strong>路径</strong>.text</li>
</ul>
</li>
<li>巡检
<ul>
<li>支持巡检后输出excel文档</li>
<li>巡检命令如下：
<ul>
<li>show int status</li>
<li>show memory</li>
<li>show cpu</li>
</ul>
</li>
</ul>
</li>
<li>支持
<ul>
<li>我只测试了如下设备
<ul>
<li>锐捷
<ul>
<li>S2628</li>
<li>S2652</li>
<li>S3760E</li>
<li>S5750</li>
</ul>
</li>
<li>华为
<ul>
<li>S5700</li>
</ul>
</li>
</ul>
</li>
<li>目前锐捷的S3760不能进入特权模式，初步判断是由于设备问题</li>
</ul>
</li>
</ul>
<h2 id="缺点"> 缺点</h2>
<ul>
<li>速度慢，对多设备兼容性差</li>
<li>交互逻辑差，没有GUI界面</li>
</ul>
<h2 id="版本"> 版本</h2>
<ul>
<li>Econnect - 1.1ssh</li>
<li>具备基本巡检备份功能</li>
<li>分支 - Econnect 1.1ssh iso+text文件备份</li>
<li>Econnect 1.2ssh
<ul>
<li>巡检完毕会自动导出excel报告
<ul>
<li>速度加快</li>
<li>文件都塞box里</li>
</ul>
</li>
</ul>
</li>
<li>Econnect 1.3
<ul>
<li>综合版本</li>
</ul>
</li>
</ul>
<h2 id="使用流程"> 使用流程</h2>
<ol>
<li>如果是第一次使用请确保当前路径没有一个叫<code>switch_info.csv</code>的文件，脚本会自动创建一个新的文件请按照格式填写即可，一行一台设备</li>
<li>请输入要执行的数字  1.巡检 2.备份 3.退出：
<ul>
<li>进入请根据需求在此界面输入[1 / 2 / 3]，其他数字无效</li>
</ul>
</li>
<li>具体
<ol>
<li>巡检
<ol>
<li>请选择需要执行的交换机[格式：1、1-5]：
<ul>
<li>按照所提示的设备对应输入单个数字即可</li>
<li>单个模式：[number]；例如：5</li>
<li>批量模式：[number]-[number]；例如：5-10</li>
</ul>
</li>
</ol>
</li>
<li>备份
<ol>
<li>请选择需要执行的交换机[格式：1、1-5]：
<ul>
<li>按照所提示的设备对应输入单个数字即可</li>
<li>单个模式：[number]；例如：5</li>
<li>批量模式：[number]-[number]；例如：5-10</li>
</ul>
</li>
</ol>
</li>
<li>退出</li>
</ol>
</li>
</ol>
<h2 id="常见问题"> 常见问题</h2>
<p>如果遇到奇怪的问题，欢迎互相交流与学习😄️</p>
<ul>
<li>
<p>如果遇到tftp开启失败</p>
<ol>
<li>
<p>如遇防火墙请允许通过，因为tftp服务器需要监听69端口</p>
</li>
<li>
<p>请右键管理员运行（这个问题大多数出现在win8）</p>
</li>
</ol>
</li>
<li>
<p>若端口关闭失败请参考</p>
<ul>
<li>https://jingyan.baidu.com/article/fb48e8be97ddc92e622e14f3.html</li>
</ul>
</li>
<li>
<p>关于netmiko模块ssh交换机遇到more的问题：</p>
<ul>
<li>https://blog.csdn.net/weixin_34217711/article/details/91615805</li>
</ul>
</li>
<li>
<p>关于tftp集成的参考</p>
<ul>
<li>https://stackoverflow.com/questions/57109992/how-to-stop-tftp-server-using-tftpy-on-python</li>
</ul>
</li>
<li>
<p>打包exe使用的命令：</p>
<ul>
<li>pyinstaller  -F -i ./network.ico  Econnect.py</li>
</ul>
</li>
<li>
<p>备份失败没有文件？</p>
<ul>
<li>打开控制面板：<code>控制面板\系统和安全\Windows Defender 防火墙\允许的应用</code>允许<code>Econnect</code>的专用或公用通过</li>
</ul>
</li>
</ul>
<hr>
<h2 id="telnet-版本"> Telnet 版本</h2>
<p>telnet版本已不再更新！</p>
<ul>
<li>具备基本连接巡检备份功能</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>删除远程记录</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/toss/delete_remote_record/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/toss/delete_remote_record/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">删除远程记录</source>
      <category>折腾</category>
      <pubDate>Tue, 17 Dec 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="动手"> 动手</h1>
<ol>
<li>win键+R</li>
<li>输入<code>regedit</code></li>
<li>然后定位到<code>HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Default</code>里面删除对应项即可<br>如下图所示
<img src="./images/delete_remotely_log/1.png" alt="图片" /></li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>交换机环路监听</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/toss/Emonitor/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/toss/Emonitor/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">交换机环路监听</source>
      <category>折腾</category>
      <pubDate>Tue, 30 Jun 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="更新终止🚧"> 更新终止🚧</h1>
<p>由于个人问题，除非bug发生了或者是新的想法冒出来了，项目就暂时搁置于此了。老实说Emonitor还只是一个测试的版本，后面也没有太多的时间可以去进一步的维护更新。最后这里感谢下MIRAI与校NIC</p>
<h1 id="特色"> 特色</h1>
<p>Emonitor由python制作而成，初想是将其挂在服务器上，一直执行查找范围内的交换机日志</p>
<ul>
<li>只适用于win</li>
<li>只适用于思科系，不支持华为系。目前只测试了锐捷的交换机</li>
<li>使用了配置文件进行核心配置（需要关闭再开启）</li>
<li>逻辑
<ul>
<li>从用户模式中使用<code>show logging</code>命令，用一个循环打印出所有分屏信息</li>
<li>正则出数据后找到环路日志并上传数据库</li>
<li>找到环路现象后通过其他联动通知</li>
</ul>
</li>
</ul>
<h2 id="数据库"> 数据库</h2>
<p>数据库中只记录环路的设备与记录，正常的设备不记录，需要手动创建一个数据库<code>emonitor</code>然后在数据库里执行添加下面数据表即可</p>
<ul>
<li>创建数据库
<code>CREATE DATEBASE emotion;</code></li>
<li>创建数据表</li>
</ul>
<div><pre><code><span>CREATE</span> <span>TABLE</span> <span>`</span>eswitch_log<span>`</span> <span>(</span>
  <span>`</span>log_id<span>`</span> <span>int</span><span>(</span><span>11</span><span>)</span> <span>NOT</span> <span>NULL</span> <span>COMMENT</span> <span>'日志id，唯一的'</span><span>,</span>
  <span>`</span>sw_name<span>`</span> <span>varchar</span><span>(</span><span>25</span><span>)</span> <span>NOT</span> <span>NULL</span> <span>DEFAULT</span> <span>''</span> <span>COMMENT</span> <span>'交换机的主机名'</span><span>,</span>
  <span>`</span>sw_ip<span>`</span> <span>varchar</span><span>(</span><span>16</span><span>)</span> <span>NOT</span> <span>NULL</span> <span>DEFAULT</span> <span>''</span> <span>COMMENT</span> <span>'交换机的IP地址'</span><span>,</span>
  <span>`</span>last_run_time<span>`</span> <span>datetime</span> <span>DEFAULT</span> <span>NULL</span> <span>COMMENT</span> <span>'上一次执行的时间'</span><span>,</span>
  <span>`</span>last_inside_time<span>`</span> <span>datetime</span> <span>DEFAULT</span> <span>NULL</span> <span>COMMENT</span> <span>'交换机内日志的最新时间记录（使用日志最后一个时间记录）'</span><span>,</span>
  <span>`</span>loop_time<span>`</span> <span>text</span> <span>COMMENT</span> <span>'发生环路的时间'</span><span>,</span>
  <span>`</span>loop_port<span>`</span> <span>varchar</span><span>(</span><span>40</span><span>)</span> <span>NOT</span> <span>NULL</span> <span>DEFAULT</span> <span>'0'</span> <span>COMMENT</span> <span>'环路的端口'</span><span>,</span>
  <span>`</span>loop_text<span>`</span> <span>longtext</span> <span>COMMENT</span> <span>'如果is_loop=1则此处有内容，is_loop=0则为空'</span>
<span>)</span> <span>ENGINE</span><span>=</span>MyISAM <span>DEFAULT</span> <span>CHARSET</span><span>=</span>utf8<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="其他"> 其他</h2>
<h3 id="gitee"> gitee</h3>
<p>https://gitee.com/bittrabbit/Emonitor</p>
<h3 id="ini配置文件"> ini配置文件</h3>
<p>mode ：配置模式，可重新载入此配置文件；执行模式，循环执行监察
loop_text ：环路的关键字，找到的日志根据这个关键字来查找
log_level ：记录日志的等级 [debug、info、warning、error]，默认为info
sleep_time ：执行一轮后的阻塞时间（分钟），默认为40分钟，请输入蠢数字
sql_ip ：数据库的ip地址
sql_user ：数据库的用户名
sql_pwd ：数据库的密码
sql_db ：连接的数据库名</p>
<h3 id="华为"> 华为</h3>
<ul>
<li>华为设备不能将环路情况写入日志，所以不支持华为设备</li>
<li>华为关闭分屏模式，执行一次命令能将所有内容放回，此分屏模式为一次性所用</li>
</ul>
<div><pre><code><span># 关闭分屏模式</span>
switch_connect<span>.</span>send_command<span>(</span><span>'screen-length 0 temporary'</span><span>)</span>
<span># 等待8s直到出现&lt;</span>
output_text_more <span>=</span> switch_connect<span>.</span>send_command<span>(</span><span>'display logbuffer'</span><span>,</span> expect_string<span>=</span><span>'&lt;'</span><span>,</span> delay_factor<span>=</span><span>8</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>JAVA环境部署</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/toss/JAVA%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/toss/JAVA%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">JAVA环境部署</source>
      <category>折腾</category>
      <pubDate>Fri, 17 Sep 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="jdk8安装教程"> JDK8安装教程</h1>
<ol>
<li>下载
<ul>
<li>于官网下载jdk8，他会内置jdk和jre</li>
<li><a href="https://java.com/zh-CN/download/" target="_blank" rel="noopener noreferrer">https://java.com/zh-CN/download/</a></li>
<li><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener noreferrer">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></li>
</ul>
</li>
<li>安装
<ul>
<li>这里建议新建一个路径文件夹，注意路径要全英</li>
<li>第一次为安装jdk，第二次为安装jre</li>
<li>注意jre需要安装到其他文件夹中，不能安装到jdk中，这会产生冲突！</li>
</ul>
</li>
<li>配置环境
<ul>
<li>复制jdk的安装路径，并打开【环境变量】</li>
<li>在系统变量中新建
<ol>
<li>JAVA_HOME
<ul>
<li>变量名 <code>JAVA_HOME</code></li>
<li>值 <code>C:\Program Files\Java\jdk1.8.0_144</code> （jdk的安装路径）</li>
</ul>
</li>
<li>CLASSPATH
<ul>
<li>变量名 <code>CLASSPATH</code></li>
<li>值 <code>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar</code></li>
</ul>
</li>
</ol>
</li>
<li>在系统变量中编辑<code>Path</code>变量
<ul>
<li>新建
<ul>
<li><code>%JAVA_HOME%\bin</code></li>
<li><code>%JAVA_HOME%\jre\bin</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>验证
<ul>
<li><code>win+x</code>打开<code>powershell</code></li>
<li>输入<code>java</code>、<code>java -version</code> ，没报错即安装成功啦！</li>
</ul>
</li>
</ol>
<h1 id="idea安装教程"> Idea安装教程</h1>
<ul>
<li>idea可以参考这一篇文章：<a href="https://blog.csdn.net/diane5229/article/details/102301078" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/diane5229/article/details/102301078</a></li>
<li>当你解决了安装问题后想测试Idea是否安装成功可以参考这一篇运行<code>helloworld</code>示例程序：<a href="https://blog.csdn.net/weixin_44505194/article/details/104452880" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/weixin_44505194/article/details/104452880</a></li>
</ul>
<h1 id="多jdk版本切换问题"> 多JDK版本切换问题</h1>
<ul>
<li>**注意！！**为了避免冲突，多版本jdk不建议安装在一个文件夹里，且记得使用全英路径</li>
<li>当你遇到这个问题的时候，估计你已经安装了多个版本的jdk，那么这里记录下jdk版本切换的问题（这里拿jak8和jdk17来做演示，仅供参考）</li>
<li>jdk8是手动配置系统环境，jdk17是自动配置的，在系统环境变量中哪个在最上面则系统将默认读取最上面的</li>
<li>若要使用jdk17（将jdk17向上移即可）
<img src="./images/JAVA环境部署.assets/1631965236068-3235788f-831d-4916-9040-143b3bda9b3d.png" alt="image.png" /></li>
<li>若要使用jdk8（将jdk8向上移即可）
<img src="./images/JAVA环境部署.assets/1631965284265-42aca488-db7a-413a-aecf-f72461012d34.png" alt="image.png" /></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>git-hexo基础命令</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/toss/hexo_command/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/toss/hexo_command/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">git-hexo基础命令</source>
      <category>折腾</category>
      <pubDate>Mon, 26 Aug 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="前言"> 前言</h2>
<p>此篇文章乃开篇的第一篇，emmm就一笔记本没啥的
<br>废话不多说我们进入正题，要如何写一篇文章？
<a href="https://hexo.io/docs/commands" target="_blank" rel="noopener noreferrer">首先肯定是看官方文档啦！</a></p>
<ul>
<li>这篇文章讲了git bash的命令行操作（懒..）</li>
<li>这个博客是用了github+hexo(主题为<a href="https://github.com/ikeq/hexo-theme-inside" target="_blank" rel="noopener noreferrer">inside</a>)搭建起来的</li>
</ul>
<h2 id="hexo-new-title"> hexo new &quot;title&quot;</h2>
<ul>
<li>创建一篇新的文章，标题用&quot;&quot;圈起来</li>
<li>在新建文章如果&quot;&quot;内的内容如果有空格默认会用-代替</li>
</ul>
<div><pre><code>	$ hexo new [layout] <span>"我是标题"</span>
</code></pre>
<div><span>1</span><br></div></div><p>此处的<code>layout</code>是<code>post</code>的默认值，默认省略不写</p>
<h2 id="删除文章"> 删除文章</h2>
<ul>
<li>此处需要手动去路径内删除文件！</li>
<li>先在<code>.source\_posts</code>找到<code>我是标题.md</code>把这个文件删除掉即可！
其实如果误删了在<code>.public\post</code>也是可以找到之前删除的内容的</li>
</ul>
<h2 id="hexo-s"> hexo s</h2>
<ul>
<li>在本地上运行服务，可用于预览主题，本地的默认地址为：<a href="http://localhost:4000" target="_blank" rel="noopener noreferrer">http://localhost:4000</a></li>
<li>如果修改了 Hexo 根目录 _config.yml ，那就需要重启本地服务器后才能预览新的效果。</li>
<li>由于github只支持静态页面，所以只能在本地制作完成后再上传github上，你可以使用admin模块进行本地编写，请参考：<a href="https://blog.csdn.net/smileyan9/article/details/86666824" target="_blank" rel="noopener noreferrer">传送门</a></li>
</ul>
<div><pre><code>$ hexo s
</code></pre>
<div><span>1</span><br></div></div><p>此处的s为简写，也可以输入</p>
<div><pre><code>$ hexo server
</code></pre>
<div><span>1</span><br></div></div><h2 id="hexo-clean"> hexo clean</h2>
<ul>
<li>在执行hexo g生成html文件和hexo d部署到仓库前兔砸建议你们先清理一遍缓存以免出现错误！</li>
</ul>
<div><pre><code>$ hexo clean
</code></pre>
<div><span>1</span><br></div></div><h2 id="hexo-g"> hexo g</h2>
<ul>
<li>执行命令生成静态的html到默认设置的 public 文件夹中</li>
</ul>
<div><pre><code>$ hexo g
</code></pre>
<div><span>1</span><br></div></div><p>此处g为缩写，你也可以</p>
<div><pre><code>$ hexo generate
</code></pre>
<div><span>1</span><br></div></div><h2 id="hexo-d"> hexo d</h2>
<ul>
<li>自动生成网站静态文件，并部署到设定的仓库</li>
<li>切记部署到仓库前要使用<code>hexo g</code>来渲染html文件</li>
</ul>
<div><pre><code>$ hexo d
</code></pre>
<div><span>1</span><br></div></div><p>此处的d为缩写，也可以</p>
<div><pre><code>$ hexo deploy
</code></pre>
<div><span>1</span><br></div></div><h2 id="hexo-g-d"> hexo g -d</h2>
<p>单独用hexo g和hexo d很麻烦啊<br>
使用这条命令你可以一条命令搞定渲染+部署的操作</p>
<div><pre><code>$ hexo g -d
</code></pre>
<div><span>1</span><br></div></div><p>更多请参考官网：<a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener noreferrer">传送门</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>hexo admin自动启动</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/toss/hexo_admin_service/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/toss/hexo_admin_service/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">hexo admin自动启动</source>
      <category>折腾</category>
      <pubDate>Wed, 28 Aug 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="需求"> 需求</h1>
<ol>
<li>一键部署本地服务器</li>
<li>能自动帮我打开浏览器进入admin的管理页面</li>
<li>编辑完毕了关闭能自动上传到github仓库上</li>
</ol>
<h1 id="解决"> 解决</h1>
<p>其实没什么..人人都能做出来的一个小脚本</p>
<h4 id="_1-部署本地服务器"> 1. 部署本地服务器</h4>
<ul>
<li>要在本地部署服务命令是<code>hexo s</code></li>
<li>前提! 只有将路径修改至本地存放hexo的路径，才能在cmd中输入hexo命令</li>
<li>python更改路径的方法是<code>os.chdir()</code>，更改的路径是<code>放置hexo仓库的路径</code></li>
<li>更改完路径就可以输入命令了！输入命令的方式是<code>os.popen()</code></li>
<li>关于上述的用法说明：</li>
</ul>
<ul>
<li><code>os.chdir('路径')</code>可以改变当前的工作目录到指定的</li>
<li><code>os.popen('cmd命令')</code>输入cmd的命令</li>
</ul>
<div><pre><code><span># 导入os模块来使用chdir和popen方法</span>
<span>import</span> os
os<span>.</span>chdir<span>(</span><span>r'C:\git\hexo'</span><span>)</span>
<span># 使用一个容器box接收从os.open传出的东西</span>
box <span>=</span> os<span>.</span>popen<span>(</span><span>'hexo s'</span><span>)</span>
<span># 使用box.read()可以将从os.popen()获得的打印出文字</span>
<span>print</span><span>(</span>box<span>.</span>read<span>(</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h4 id="_2-打开浏览器进入admin的管理页面"> 2. 打开浏览器进入admin的管理页面</h4>
<ul>
<li>admin的url地址为：<code>http://localhost:4000/admin</code></li>
<li>用python的<code>webbrowser</code>模块的<code>open</code>方法可以实现打开页面</li>
<li><code>webbrowser.open('url地址')</code>使用系统默认浏览器打开指定的<code>url地址</code></li>
</ul>
<div><pre><code><span># 导入webbrowser模块来使用open方法</span>
<span>import</span> webbrowser
<span># 打开localhost:4000/admin这个页面</span>
webbrowser<span>.</span><span>open</span><span>(</span><span>'localhost:4000/admin'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id="_3-上传到github仓库"> 3. 上传到github仓库</h4>
<ul>
<li>上次至github仓库命令为<code>hexo g -d</code></li>
<li>像<a href="./post/python%E9%83%A8%E7%BD%B2%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8#1-%E9%83%A8%E7%BD%B2%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8">上面☝</a>提到的使用<code>os.popen()</code>命令即可</li>
</ul>
<div><pre><code>os<span>.</span>popen<span>(</span><span>'hexo g -d'</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><h1 id="后面"> 后面</h1>
<ul>
<li>缺点</li>
</ul>
<ol>
<li>开启速度..慢</li>
<li>要按两次ctrl+c才能退出上传</li>
</ol>
<div><pre><code><span>from</span> time <span>import</span> sleep
<span>from</span> webbrowser <span>import</span> <span>open</span>
<span>import</span> os
<span>import</span> threading



<span>def</span> <span>open_web</span><span>(</span><span>)</span><span>:</span>
      sleep<span>(</span><span>3</span><span>)</span>
	webbrowser<span>.</span><span>open</span><span>(</span><span>'http://localhost:4000/admin'</span><span>)</span>

<span>print</span><span>(</span><span>'运行中.....'</span><span>)</span>
os<span>.</span>chdir<span>(</span><span>r'F:\git\hexo'</span><span>)</span>
threading<span>.</span>Thread<span>(</span>target<span>=</span>open_web<span>)</span><span>.</span>start<span>(</span><span>)</span>
os<span>.</span>popen<span>(</span><span>'hexo s'</span><span>)</span><span>.</span>read<span>(</span><span>)</span>
<span>print</span><span>(</span><span>'已退出本地模式，正在上传...'</span><span>)</span>
os<span>.</span>popen<span>(</span><span>'hexo g -d'</span><span>)</span><span>.</span>read<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h1 id="其他问题"> 其他问题</h1>
<p>可能会出现一些问题，所以在这里贴出来</p>
<ol>
<li>ModuleNotFoundError: No module named 'webbrowser'<br>
如果出现了类似以上的问题，首先你要去安装模块，本章需要安装的模块为<code>webbrowser</code>，<strong>win+R 然后输入 cmd 然后输入以下内容即可</strong><br></li>
</ol>
<div><pre><code>pip install webbrowser
</code></pre>
<div><span>1</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>wordpress安全配置</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/toss/build-wp-precautions/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/toss/build-wp-precautions/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">wordpress安全配置</source>
      <category>折腾</category>
      <pubDate>Thu, 19 Mar 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="前言"> 前言</h1>
<p>最近有一个弄部门的wp的想法，于是就想记录一些关于建站的小问题
由于我们部门是网络中心，目前的模式都是按照你报故障我上门的模式来执行，到了后期故障慢慢都少了许多，于是就有了建wp的想发，可以让出了小问题的同学在上面自行解决，这样估计能省去一大堆人手吧哈哈</p>
<h1 id="区别"> 区别</h1>
<p>上面所写的wp是指wordpress，可能你会问有了hexo为啥还需要wp呢？
我想列一下我所了解的区别</p>
<ol>
<li>WP
<ul>
<li>优点
<ul>
<li>wordpress的好处在于几乎所有事情都能在浏览器上完成，无论你是在本机电脑还是在服务器搭建，登录账号你就能编辑写文章装插件调主题等等的操作！</li>
<li>你可以在多平台下在线操作网站</li>
</ul>
</li>
<li>缺点
<ul>
<li>让我最不喜欢的<strong>小缺点</strong>就是没有文章的导航..</li>
<li>由于是动态网页，而且整体上了浏览器，在加载页面上会导致处理一些处理速度底下</li>
<li>CDN和域名是刚需！</li>
</ul>
</li>
</ul>
</li>
<li>Hexo
<ul>
<li>优点
<ul>
<li>由于是静态页面所以加载速度比较快，还可以免费托管在不同的git平台上，所以你没有服务器都行</li>
<li>主题较为简洁，wp东西多了还是会容易臃肿的</li>
</ul>
</li>
<li>缺点
<ul>
<li>由于是静态页面且托管在第三方git平台，所以无法在线编辑，在其他电脑上部署环境麻烦（痛点！）</li>
<li>需要在本地或安装hexo-admin用npm调用才能完成一篇文章</li>
<li>严重依靠git平台</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="正文"> 正文</h1>
<p>说了那么多也还是为了铺垫，目前为止我两个平台都些许有用，由于我都是使用md作为笔记使用，所以就打算在hexo中放我的笔记，在wp中放文章，虽然wp可以md但是图片如果依赖第三方图床还是比较麻烦的，不见了怎么办233</p>
<h2 id="操作"> 操作</h2>
<h3 id="允许任意访问"> 允许任意访问</h3>
<p>默认是只允许一个域名，在使用wp的时候也可以指定特定的域名，就是菜单与链接是写死的，这个算是硬伤之一，那我就是要怎么弄？</p>
<ol>
<li>在wp文站更目录下找到wp-config.php，找到指定行</li>
</ol>
<div><pre><code><span>require_once</span><span>(</span><span>ABSPATH</span> <span>.</span> 'wp<span>-</span>settings<span>.</span>php’<span>)</span><span>;</span> 
</code></pre>
<div><span>1</span><br></div></div><ol start="2">
<li>在他的前面添加：</li>
</ol>
<div><pre><code><span>$yovisunhome</span> <span>=</span> <span>'http://'</span><span>.</span><span>$_SERVER</span><span>[</span><span>'HTTP_HOST'</span><span>]</span><span>;</span>    
<span>$yovisunsiteurl</span> <span>=</span> <span>'http://'</span><span>.</span><span>$_SERVER</span><span>[</span><span>'HTTP_HOST'</span><span>]</span><span>;</span>    
<span>define</span><span>(</span><span>'WP_HOME'</span><span>,</span> <span>$yovisunhome</span><span>)</span><span>;</span>     
<span>define</span><span>(</span><span>'WP_SITEURL'</span><span>,</span> <span>$yovisunsiteurl</span><span>)</span><span>;</span>  
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ol start="3">
<li>添加完之后，上面的变量能用来获取当前访问的域名，这样就能根据这个域名实现多域名绑定，当然这也算是个治标不治本的方法，毕竟许多按钮的链接是写死的绝对路径</li>
</ol>
<h3 id="允许指定域名访问"> 允许指定域名访问</h3>
<p>目前我自己是使用这种方法，起码比起允许任意访问来的安全</p>
<ol>
<li>在wp文站更目录下找到wp-config.php，找到指定行</li>
</ol>
<div><pre><code><span>require_once</span><span>(</span><span>ABSPATH</span> <span>.</span> 'wp<span>-</span>settings<span>.</span>php’<span>)</span><span>;</span> 
</code></pre>
<div><span>1</span><br></div></div><ol start="2">
<li>在他的前面添加以下代码，记得修改<code>&quot;link1.com&quot;, &quot;link2.net&quot;</code>：</li>
</ol>
<div><pre><code><span>$domain</span> <span>=</span> <span>array</span><span>(</span><span>"link1.com"</span><span>,</span> <span>"link2.net"</span><span>)</span><span>;</span>
<span>if</span><span>(</span><span>in_array</span><span>(</span><span>$_SERVER</span><span>[</span><span>'HTTP_HOST'</span><span>]</span><span>,</span> <span>$domain</span><span>)</span><span>)</span><span>{</span>
<span>define</span><span>(</span><span>'WP_SITEURL'</span><span>,</span> <span>'http://'</span> <span>.</span> <span>$_SERVER</span><span>[</span><span>'HTTP_HOST'</span><span>]</span><span>)</span><span>;</span>
<span>define</span><span>(</span><span>'WP_HOME'</span><span>,</span> <span>'http://'</span> <span>.</span> <span>$_SERVER</span><span>[</span><span>'HTTP_HOST'</span><span>]</span><span>)</span><span>;</span>
<span>}</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ol start="3">
<li>修改了link1和link2之后你就可以通过指定的域名访问你的站点了！</li>
</ol>
<h3 id="保护wp-config-php文件"> 保护wp-config.php文件</h3>
<p><code>wp-config.php</code>这个文件如同wp的指路牌，所以要保护好他</p>
<ol>
<li>在.·htaccess·文件中的最后面添加：</li>
</ol>
<div><pre><code># 保护 wp-config.php 文件

&lt;Files wp-config.php&gt;

Order allow,deny

Deny from All

&lt;/Files&gt;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="保管好你的密码"> 保管好你的密码</h3>
<p>安全起见建议最好密码时不时更换一下，即使你的密码有100位长，只要有时间照样能穷举出来</p>
<h3 id="即使更新"> 即使更新</h3>
<p>wp时不时会发布新版本，虽然说wp更新可能会导致插件不兼容或者其他问题，所以这个看个人，切记时不时备份一次wp</p>
<h3 id="保护安装文件"> 保护安装文件</h3>
<p>在根目录下的wp-admin/install.php的文件，他可以安装或者重装你的wp站点，你可以删除他，这并不会对你的站点造成影响（要重装除外）</p>
<h3 id="移除登录错误信息"> 移除登录错误信息</h3>
<p>在wp登录的时候你会发现如果输入了存在的用户输错了密码会提示<code>密码错误</code>，而输入不存在的用户则会提醒<code>用户不存在</code>，按这个思路我就能穷举出你的用户名，如何修改？</p>
<ol>
<li>找到目录<code>/wp-content/themes/你的站点主题/functions.php</code>的后面添加一行代码</li>
</ol>
<div><pre><code><span>function</span> <span>no_wordpress_errors</span><span>(</span><span>)</span><span>{</span>
	<span>return</span> <span>'用户名或密码错误!'</span><span>;</span>
<span>}</span>
<span>add_filter</span><span>(</span> <span>'login_errors'</span><span>,</span> <span>'no_wordpress_errors'</span> <span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="插件推荐"> 插件推荐</h2>
<ol>
<li><a href="https://wordpress.org/plugins/login-lockdown/" target="_blank" rel="noopener noreferrer"> Login LockDown</a>  登录超过次数直接扳掉</li>
<li>WP-China-Yes 国内访问wp必备，这个需要第三方安装<a href="https://github.com/sunxiyuan/wp-china-yes" target="_blank" rel="noopener noreferrer">点我跳转</a></li>
<li><a href="https://wordpress.org/plugins/https://wordpress.org/plugins/wp-super-cache/" target="_blank" rel="noopener noreferrer">WP Super Cache</a> 缓存</li>
<li><a href="http://wordpress.org/plugins/wp-statistics/" target="_blank" rel="noopener noreferrer">WP Statistics</a> wp仪盘表分析和统计工具</li>
<li><a href="https://wordpress.org/plugins/wenprise-pinyin-slug/" target="_blank" rel="noopener noreferrer">Wenprise Pinyin Slug</a>将标题的名字自动转换成拼音，也可以翻译，不过需要获得API</li>
<li><a href="https://wordpress.org/plugins/external-media-without-import/" target="_blank" rel="noopener noreferrer">External Media without Import</a>将外部图片作为链接保存在图库，而不是下载下来</li>
</ol>
<h1 id="写在后面"> 写在后面</h1>
<p>说不定真香警告突然出现又转去其他阵营了？折腾哇QAQ</p>
<p><br><br><br><br><br></p><center>无法逃避的是自我，而无法挽回的是过去。
-- 机动战士高达</center></p>
]]></content:encoded>
    </item>
    <item>
      <title>markdown流程图与其他</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/toss/markdown_orther_useing/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/toss/markdown_orther_useing/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">markdown流程图与其他</source>
      <category>折腾</category>
      <pubDate>Wed, 08 Apr 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="前言"> 前言</h1>
<p>有的时候想直接在markdown上写一些流程图什么的扩展语法，奈何太菜只能在这里留下笔记希望自己能记得</p>
<p><a href="https://www.jianshu.com/p/847b56e28d50" target="_blank" rel="noopener noreferrer">转载于此</a></p>
<h1 id="上手"> 上手</h1>
<h2 id="流程图-flowchart"> 流程图（Flowchart）</h2>
<i>Not supported content</i><p><img src="./images/markdown扩展/flowchart.png" alt="哦豁图片被吃了" /></p>
<h2 id="流程图-mermaid"> 流程图（Mermaid）</h2>
<Mermaid id="mermaid-382ee166" data-code="graph%20TD%3B%0A%20%20%20%20%E5%BC%80%E5%A7%8B--%3E%E6%9D%A1%E4%BB%B6B%3B%0A%20%20%20%20%E6%9D%A1%E4%BB%B6A--%3E%E6%9D%A1%E4%BB%B6C%3B%0A%20%20%20%20%E6%9D%A1%E4%BB%B6B--%3E%E6%9D%A1%E4%BB%B6D%3B%0A%20%20%20%20%E6%9D%A1%E4%BB%B6C--%3E%E6%9D%A1%E4%BB%B6D%3B%0A%20%20%20%20%E6%9D%A1%E4%BB%B6A--%3E%E6%9D%A1%E4%BB%B6D%3B%0A%20%20%20%20%E5%BC%80%E5%A7%8B--%3E%E6%9D%A1%E4%BB%B6C%3B%0A%20%20%20%20%E5%BC%80%E5%A7%8B--%3E%E6%9D%A1%E4%BB%B6A%3B%0A%20%20%20%20%E6%9D%A1%E4%BB%B6D--%3E%E7%BB%93%E6%9D%9F%3B%0A"></Mermaid><p><img src="./images/markdown扩展/mermaid.png" alt="哦豁图片被吃了" /></p>
<h2 id="时序图-mermaid"> 时序图（Mermaid）</h2>
<Mermaid id="mermaid-382ee16d" data-code="sequenceDiagram%0A%20%20%20%20participant%20Alice%0A%20%20%20%20participant%20Bob%0A%20%20%20%20Alice-%3E%3EJohn%3A%20Hello%20John%2C%20how%20are%20you%3F%0A%20%20%20%20loop%20Healthcheck%0A%20%20%20%20%20%20%20%20John-%3E%3EJohn%3A%20Fight%20against%20hypochondria%0A%20%20%20%20end%0A%20%20%20%20Note%20right%20of%20John%3A%20Rational%20thoughts%20%3Cbr%2F%3Eprevail...%0A%20%20%20%20John--%3E%3EAlice%3A%20Great!%0A%20%20%20%20John-%3E%3EBob%3A%20How%20about%20you%3F%0A%20%20%20%20Bob--%3E%3EJohn%3A%20Jolly%20good!%0A"></Mermaid><p><img src="./images/markdown扩展/mermaid_2.png" alt="哦豁图片被吃了" /></p>
<h2 id="时序图-sequence"> 时序图（sequence）</h2>
<Mermaid id="mermaid-382ee189" data-code="sequenceDiagram%0A%20%20%20%20Alice-%3E%3EJohn%3A%20Hello%20John%2C%20how%20are%20you%3F%0A%20%20%20%20Note%20right%20of%20John%3A%20Rational%20thoughts%0A%20%20%20%20John--%3E%3EAlice%3A%20Great!%0A%20%20%20%20John-%3E%3EBob%3A%20How%20about%20you%3F%0A%20%20%20%20Bob--%3E%3EJohn%3A%20Jolly%20good!%0A"></Mermaid><p><img src="./images/markdown扩展/sequence.png" alt="哦豁图片被吃了" /></p>
<h2 id="甘特图-mermaid"> 甘特图 （mermaid）</h2>
<Mermaid id="mermaid-382ee1a5" data-code="gantt%0A%20%20%20%20%20%20%20%20dateFormat%20%20YYYY-MM-DD%0A%20%20%20%20%20%20%20%20title%20Adding%20GANTT%20diagram%20functionality%20to%20mermaid%0A%20%20%20%20%20%20%20%20section%20A%20section%0A%20%20%20%20%20%20%20%20Completed%20task%20%20%20%20%20%20%20%20%20%20%20%20%3Adone%2C%20%20%20%20des1%2C%202014-01-06%2C2014-01-08%0A%20%20%20%20%20%20%20%20Active%20task%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Aactive%2C%20%20des2%2C%202014-01-09%2C%203d%0A%20%20%20%20%20%20%20%20Future%20task%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3A%20%20%20%20%20%20%20%20%20des3%2C%20after%20des2%2C%205d%0A%20%20%20%20%20%20%20%20Future%20task2%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3A%20%20%20%20%20%20%20%20%20des4%2C%20after%20des3%2C%205d%0A%20%20%20%20%20%20%20%20section%20Critical%20tasks%0A%20%20%20%20%20%20%20%20Completed%20task%20in%20the%20critical%20line%20%3Acrit%2C%20done%2C%202014-01-06%2C24h%0A%20%20%20%20%20%20%20%20Implement%20parser%20and%20jison%20%20%20%20%20%20%20%20%20%20%3Acrit%2C%20done%2C%20after%20des1%2C%202d%0A%20%20%20%20%20%20%20%20Create%20tests%20for%20parser%20%20%20%20%20%20%20%20%20%20%20%20%20%3Acrit%2C%20active%2C%203d%0A%20%20%20%20%20%20%20%20Future%20task%20in%20critical%20line%20%20%20%20%20%20%20%20%3Acrit%2C%205d%0A%20%20%20%20%20%20%20%20Create%20tests%20for%20renderer%20%20%20%20%20%20%20%20%20%20%20%3A2d%0A%20%20%20%20%20%20%20%20Add%20to%20mermaid%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3A1d%0A"></Mermaid><p><img src="./images/markdown扩展/mermaid_3.png" alt="哦豁图片被吃了" /></p>
<h2 id="其他-mermaid-图"> 其他 Mermaid 图</h2>
<Mermaid id="mermaid-382ee1c1" data-code="classDiagram%0AClass01%20%3C%7C--%20AveryLongClass%20%3A%20Cool%0AClass03%20*--%20Class04%0AClass05%20o--%20Class06%0AClass07%20..%20Class08%0AClass09%20--%3E%20C2%20%3A%20Where%20am%20i%3F%0AClass09%20--*%20C3%0AClass09%20--%7C%3E%20Class07%0AClass07%20%3A%20equals()%0AClass07%20%3A%20Object%5B%5D%20elementData%0AClass01%20%3A%20size()%0AClass01%20%3A%20int%20chimp%0AClass01%20%3A%20int%20gorilla%0AClass08%20%3C--%3E%20C2%3A%20Cool%20label%0A"></Mermaid><p><img src="./images/markdown扩展/classDiagram.png" alt="哦豁图片被吃了" /></p>
<h1 id="后面"> 后面</h1>
<p>markdown还蛮强的，你说到时候会不会他成熟了，就不用我手打笔记了[doge]</p>
]]></content:encoded>
    </item>
    <item>
      <title>使用vuepress搭建github page</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/toss/vuepress_to_github/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/toss/vuepress_to_github/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">使用vuepress搭建github page</source>
      <category>折腾</category>
      <pubDate>Tue, 25 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="前言"> 前言</h2>
<p>博客没记错是从2019年的时候开始规划的，那个时候还是在本地使用wordpress搭建，后来知道可以用github page来搭建静态的网站就转去hexo+github page，直到最近经朋友介绍才知道vuepress，加上自己的博客已然太旧，所以近日打算将其进行更新改造！</p>
<h2 id="常用链接"> 常用链接</h2>
<div><p>温馨提示</p>
<p>本教程使用<a href="https://vuepress-theme-hope.github.io/zh/" target="_blank" rel="noopener noreferrer">vuepress-theme-hope</a>主题，不同的主题可能配置内容会有些区别，具体参考主题文档</p>
<ul>
<li>常用链接：
<ul>
<li><a href="https://vuepress-theme-hope.github.io/zh/guide/layout/navbar/" target="_blank" rel="noopener noreferrer">导航栏</a></li>
<li><a href="https://vuepress-theme-hope.github.io/zh/guide/layout/sidebar/" target="_blank" rel="noopener noreferrer">侧边栏</a></li>
<li><a href="https://vuepress-theme-hope.github.io/zh/guide/layout/footer/" target="_blank" rel="noopener noreferrer">页脚</a></li>
<li><a href="https://vuepress-theme-hope.github.io/zh/guide/blog/home" target="_blank" rel="noopener noreferrer">博客首页配置</a></li>
<li><a href="https://vuepress-theme-hope.github.io/guide/interface/icon/#featured-icons" target="_blank" rel="noopener noreferrer">Icon</a></li>
</ul>
</li>
</ul>
</div>
<h2 id="前期准备"> 前期准备</h2>
<p>为避免不必要的报错，建议在cmd或powershell中使用命令</p>
<ul>
<li>git<div><pre><code>$ <span>git</span> config --global user.name <span>"bit"</span>
$ <span>git</span> config --global user.email bit@qq.com
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>node.js的配置
<a href="https://www.cnblogs.com/lgx5/p/10732016.html" target="_blank" rel="noopener noreferrer">node.js配置</a></li>
<li>安装yarn：<code>npm install -g yarn</code></li>
<li>初始化：<code>yarn config set registry https://registry.npm.taobao.org</code></li>
<li>新建文件夹以存放项目：<code>mkdir vuepress-blog &amp;&amp; cd vuepress-blog</code></li>
<li>生成 vuepress-theme-hope：<code>yarn vreate vuepress-theme-hope docs</code>
<ul>
<li>在执行的后续会需要你确认，默认无脑回车即可</li>
</ul>
</li>
<li>运行成功后即可在浏览器输入 <code>localhost:8080/zh/</code>
<ul>
<li>若选择了不立即运行，可在之后输入 <code>yarn docs:dev</code> 进行本地启动运行</li>
</ul>
</li>
<li>这个时候其实已经完成了一个模板，你可以在次模板上进行修改操作，下面是我对模板的一些修改说明</li>
</ul>
<h2 id="配置主题"> 配置主题</h2>
<h3 id="文章架构说明"> 文章架构说明</h3>
<ul>
<li>具体的文件结构可以参考主题文档：<a href="https://vuepress-theme-hope.github.io/zh/basic/vuepress/file/#%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84" target="_blank" rel="noopener noreferrer">文件结构介绍 | vuepress-theme-hope</a></li>
<li>总的说
<ul>
<li><strong>docs</strong>文章都放在这个文件夹里
<ul>
<li><strong>readme.md</strong>：vuepress会自动生成为主页，即<code>***.com/</code></li>
<li><strong>links.md</strong>：访问的时候只需输入<code>***.io/links</code>即可</li>
<li><strong>play_note</strong>：文件夹
<ul>
<li><strong>readme.md</strong>：访问的时候只需输入<code>***.io/play_note</code>即可</li>
<li><strong>vuepress.md</strong>：访问的时候只需输入<code>***.io/play_note/vuepress</code>即可</li>
</ul>
</li>
</ul>
</li>
<li><strong>dist</strong>后续生成部署的时会放到这个文件夹里</li>
</ul>
</li>
</ul>
<h3 id="更改语言为中文"> 更改语言为中文</h3>
<div><p>温馨提示</p>
<ul>
<li>参考：<a href="https://vuepress-theme-hope.github.io/zh/config/i18n/#%E6%A0%B9%E7%9B%AE%E5%BD%95%E8%AF%AD%E8%A8%80%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener noreferrer">多语言</a></li>
<li>此主题有中英文两个版本，若只是要中文，则需要设置<code>./docs/.vuepress/config.js</code>文件</li>
</ul>
</div>
<ol>
<li>
<p>找到config.js下locales语言配置</p>
</li>
<li>
<p>将键为&quot;/zh/&quot;的都删掉</p>
</li>
<li>
<p>将键为&quot;/&quot;的lang改为&quot;zh-CN&quot;</p>
<div><pre><code>locales<span>:</span> <span>{</span>
    <span>"/"</span><span>:</span> <span>{</span>
        <span>// 设置需要的语言	</span>
        lang<span>:</span> <span>"zh-CN"</span><span>,</span>
    <span>}</span><span>,</span>
<span>}</span><span>,</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
<li>
<p>将 <code>./docs/zh/</code> 下的文件移动到 <code>./docs/</code> 下，并替换英文的文件</p>
</li>
</ol>
<h3 id="关于config-js"> 关于config.js</h3>
<p>这个大部分可在主题文档中查找，这里只做出一点演示</p>
<h4 id="导航栏"> 导航栏</h4>
<ul>
<li>下面是之前做的片段，仅供参考，你也可以在初始化后的配置的基础上进行配置</li>
</ul>
<details><summary>详情</summary>
<div><pre><code>nav<span>:</span> <span>[</span>
      <span>{</span> text<span>:</span> <span>"主页"</span><span>,</span> link<span>:</span> <span>"/"</span><span>,</span> icon<span>:</span> <span>"home"</span> <span>}</span><span>,</span>
      <span>{</span> text<span>:</span> <span>"博客"</span><span>,</span> link<span>:</span> <span>"/blog"</span><span>,</span> icon<span>:</span> <span>"form"</span><span>,</span>
      items<span>:</span><span>[</span>
        <span>{</span>text<span>:</span> <span>"课记"</span><span>,</span> icon<span>:</span> <span>"search"</span><span>,</span> link<span>:</span> <span>"/category/课记/"</span><span>,</span><span>}</span><span>,</span>
        <span>{</span>text<span>:</span> <span>"玩记"</span><span>,</span> icon<span>:</span> <span>"activity"</span><span>,</span> link<span>:</span> <span>"/category/玩记/"</span><span>,</span><span>}</span><span>,</span>
        <span>{</span>text<span>:</span> <span>"用记"</span><span>,</span> icon<span>:</span> <span>"creative"</span><span>,</span> link<span>:</span> <span>"/category/用记/"</span><span>,</span><span>}</span><span>,</span>
        <span>]</span>
      <span>}</span><span>,</span>
      <span>{</span> text<span>:</span> <span>"links"</span><span>,</span> link<span>:</span> <span>"/links"</span><span>,</span> icon<span>:</span> <span>"link"</span><span>}</span><span>,</span>
      <span>{</span> text<span>:</span> <span>"关于我"</span><span>,</span> link<span>:</span> <span>"/intro"</span><span>,</span> icon<span>:</span> <span>"people"</span><span>}</span><span>,</span>
      <span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div></details>
<h4 id="左侧边栏"> 左侧边栏</h4>
<ul>
<li>下面是之前做的片段，仅供参考，你也可以在初始化后的配置的基础上进行配置</li>
</ul>
<details><summary>详情</summary>
<div><pre><code>  sidebar<span>:</span> <span>{</span>
      <span>"/"</span><span>:</span> 
      <span>[</span>
        <span>{</span>
          title<span>:</span> <span>"导航"</span><span>,</span>
          icon<span>:</span> <span>"home"</span><span>,</span>
          prefix<span>:</span> <span>"/"</span><span>,</span>
          collapsable<span>:</span> <span>false</span><span>,</span>
          children<span>:</span> <span>[</span><span>""</span><span>,</span><span>"blog"</span><span>,</span><span>"links"</span><span>,</span><span>]</span>
        <span>}</span><span>,</span>
        <span>{</span>
            title<span>:</span> <span>"课记"</span><span>,</span>
            icon<span>:</span> <span>"search"</span><span>,</span>
            prefix<span>:</span> <span>"/class_note/"</span><span>,</span>
            children<span>:</span> <span>[</span><span>"mysql_note"</span><span>,</span><span>"linux_note"</span><span>,</span><span>"data_security"</span><span>]</span><span>,</span>
        <span>}</span><span>,</span>
        <span>{</span>
            title<span>:</span> <span>"玩记"</span><span>,</span>
            icon<span>:</span> <span>"activity"</span><span>,</span>
            prefix<span>:</span> <span>"/play_note/"</span><span>,</span>
            children<span>:</span> <span>[</span><span>"vuepress_to_github"</span><span>,</span><span>"Econnect"</span><span>,</span><span>"一言"</span><span>,</span><span>]</span><span>,</span>
        <span>}</span><span>,</span>
        <span>{</span>
            title<span>:</span> <span>"用记"</span><span>,</span>
            icon<span>:</span> <span>"write"</span><span>,</span>
            prefix<span>:</span> <span>"/use_note/"</span><span>,</span>
            children<span>:</span> <span>[</span><span>"UDP_get_ip"</span><span>,</span><span>"python_ini"</span><span>,</span><span>"markdown_orther_useing"</span><span>,</span><span>]</span><span>,</span>
        <span>}</span><span>,</span>
      <span>]</span>
  <span>}</span><span>,</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div></details>
<h5 id="仅包含当前页面的侧边栏"> 仅包含当前页面的侧边栏</h5>
<p>如果你仅仅想要包含当前页面的侧边栏，而不想与其他的混合在一起的，你可以在markdown文章的头部添加</p>
<div><pre><code><span><span>---</span>
<span>sidebar: auto</span>
<span>---</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id="页脚"> 页脚</h4>
<div><pre><code>footer<span>:</span> <span>{</span>
      display<span>:</span> <span>true</span><span>,</span>
      <span>// 修改content则可以更改默认的页脚</span>
      content<span>:</span> <span>"MIT Licensed | Copyright © 2021 RoarRabbit"</span><span>,</span>
<span>}</span><span>,</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="评论服务"> 评论服务</h4>
<p>主题配备了Waline、Vssue 和 Valine，评论服务默认是使用Waline，但Waline需要服务器后台支持，这里我推荐使用Valine，你也可以<a href="https://vuepress-theme-hope.github.io/zh/guide/feature/comment/#valine" target="_blank" rel="noopener noreferrer">参考这里</a></p>
<ul>
<li>注册LeanCloud：<a href="https://console.leancloud.cn/#/signup" target="_blank" rel="noopener noreferrer">Link</a></li>
<li>登陆进去点击创建应用，完成后找到<code>设置-&gt;应用Keys</code>，将AppID和AppKey复制到comment中</li>
</ul>
<div><pre><code>comment<span>:</span> <span>{</span>
      type<span>:</span> <span>"valine"</span><span>,</span>
      appId<span>:</span> <span>"*****"</span><span>,</span> <span>// your appId</span>
      appKey<span>:</span> <span>"*****"</span><span>,</span> <span>// your appKey</span>

    <span>}</span><span>,</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="文章"> 文章</h3>
<p>文章头部建议参考这种格式进行配置，若不需要使用设置将其删除或注释即可</p>
<div><pre><code><span><span>---</span>
<span># 这是页面的图标，可以参考常用链接中的Icon
icon: page
# 这是文章的标题
title: 使用vuepress搭建github page
# 设置写作时间
time: 2021-05-25
# 页脚
footer: I am a nonexistent footer. [doge]
# 分类
category: 玩记
# 标签
tag:
  - 玩记
  - vuepress
  - github page</span>
<span>---</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id="关于图片"> 关于图片</h3>
<ul>
<li>图片的部分是默认放在<code>public</code>中，为了方便我是直接将图片文件进行覆盖修改，这样就可以不用去修改代码了</li>
</ul>
<h2 id="部署静态页面并上传github-page"> 部署静态页面并上传github page</h2>
<ul>
<li>
<p>这样部署出来的文件需要后续手动部署上传，会有点不太方便</p>
</li>
<li>
<p>这里默认你已经配置好了github仓库的内容，不会的话可以<a href="https://www.jianshu.com/p/1f199ee49e4c" target="_blank" rel="noopener noreferrer">参考这里</a></p>
</li>
<li>
<p>手敲</p>
<details><summary>详细</summary>
<div><pre><code>  <span># 生成静态文件</span>
  <span>yarn</span> docs:build
  <span># 进入生成的文件夹</span>
  <span>cd</span> /dist
  <span># 如果是发布到自定义域名</span>
  <span># echo 'www.example.com' > CNAME</span>
  <span>git</span> init
  <span>git</span> <span>add</span> -A
  <span>git</span> commit -m <span>'deploy'</span>
  
  <span># 如果发布到 https://&lt;USERNAME>.github.io</span>
  <span>git</span> push -f git@github.com:<span>&lt;</span>USERNAME<span>></span>/<span>&lt;</span>USERNAME<span>></span>.github.io.git master
  
  <span># 如果发布到 https://&lt;USERNAME>.github.io/&lt;REPO></span>
  <span># git push -f git@github.com:&lt;USERNAME>/&lt;REPO>.git master:gh-pages</span>
  
  <span># 把上面的 &lt;USERNAME> 换成你自己的 Github 用户名，&lt;REPO> 换成仓库名，比如我这里就是：</span>
  <span>#git push -f git@github.com:wtyqer/blog.git master:gh-pages</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div></details>
</li>
</ul>
<h2 id="参考链接"> 参考链接</h2>
<ul>
<li>vuepress-theme-hope：https://vuepress-theme-hope.github.io/zh</li>
<li>vuepress-theme-hope小白教程：https://vuepress-theme-hope.github.io/zh/basic/tutorial/</li>
<li>部署上传vuepress到github page：https://www.jianshu.com/p/1f199ee49e4c</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>一言</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/toss/%E4%B8%80%E8%A8%80/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/toss/%E4%B8%80%E8%A8%80/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">一言</source>
      <category>折腾</category>
      <pubDate>Mon, 03 Feb 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="前言"> 前言</h1>
<p>一言，有的时候会想看到或者用到一些句子，于是这个脚本就出现了（就是这么突然😅）</p>
<h1 id="动手"> 动手</h1>
<p>这里主要是使用了https://hitokoto.cn/ 的 <a href="https://v1.hitokoto.cn/" target="_blank" rel="noopener noreferrer">API</a> 进行操作，结合之前的几篇文章还将他复制到剪贴板内并发送通知</p>
<div><pre><code><span>import</span> requests<span>,</span> json<span>,</span> win10toast<span>,</span> pyperclip
html <span>=</span> requests<span>.</span>get<span>(</span><span>'https://v1.hitokoto.cn/'</span><span>)</span><span>.</span>content<span>.</span>decode<span>(</span><span>)</span>
html_dict <span>=</span> json<span>.</span>loads<span>(</span>html<span>)</span>
show_txt <span>=</span> <span>'%s\n -- %s'</span><span>%</span><span>(</span>html_dict<span>[</span><span>'hitokoto'</span><span>]</span><span>,</span>html_dict<span>[</span><span>'from'</span><span>]</span><span>)</span>
pyperclip<span>.</span>copy<span>(</span>show_txt<span>)</span>
Tn <span>=</span> win10toast<span>.</span>ToastNotifier<span>(</span><span>)</span>
<span>while</span> Tn<span>.</span>notification_active<span>(</span><span>)</span><span>:</span> sleep<span>(</span><span>2</span><span>)</span>
Tn<span>.</span>show_toast<span>(</span><span>'一言'</span><span>,</span> show_txt<span>,</span> duration<span>=</span><span>10</span><span>)</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>python使用配置文件</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/toss/python_ini/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/toss/python_ini/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">python使用配置文件</source>
      <category>折腾</category>
      <pubDate>Sun, 10 May 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="前言"> 前言</h1>
<p>为了能更好更快的直接通过修改配置文件，例如ini这种来达到程序的不同操作，这里将记录configparser这个模块</p>
<h1 id="快速"> 快速</h1>
<p>简单快速的说明读与写的方法</p>
<h2 id="写入"> 写入</h2>
<div><pre><code><span>import</span> configparser
config <span>=</span> configparser<span>.</span>ConfigParser<span>(</span><span>)</span>
config<span>[</span><span>'说明'</span><span>]</span> <span>=</span> <span>{</span><span>"上面那个框框"</span><span>:</span><span>"叫做节点"</span><span>,</span>
						<span>"我叫OPTION"</span><span>:</span><span>"我是值"</span><span>,</span>
                        <span>"配置1"</span><span>:</span><span>"我是路径1"</span><span>,</span>
                        <span>"配置2"</span><span>:</span><span>"我是路径2"</span><span>,</span>
                        <span>"配置3"</span><span>:</span><span>"123"</span><span>}</span>
<span>with</span> <span>open</span><span>(</span><span>'配置文件.ini'</span><span>,</span> <span>'w'</span><span>,</span> encoding<span>=</span><span>'utf-8'</span><span>)</span> <span>as</span> f<span>:</span>
    config<span>.</span>write<span>(</span>f<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>配置文件.ini：</p>
<div><pre><code><span>[说明]</span>
<span>上面那个框框</span> <span><span>=</span> 叫做节点</span>
<span>我叫option</span> <span><span>=</span> 我是值</span>
<span>配置1</span> <span><span>=</span> 我是路径1</span>
<span>配置2</span> <span><span>=</span> 我是路径2</span>
<span>配置3</span> <span><span>=</span> 123</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="读取"> 读取</h2>
<div><pre><code><span>import</span> configparser
config <span>=</span> configparser<span>.</span>ConfigParser<span>(</span><span>)</span>
config<span>.</span>read<span>(</span><span>'配置文件.ini'</span><span>,</span> encoding<span>=</span><span>'utf-8'</span><span>)</span>
<span>print</span><span>(</span><span>"输出元组，包括option的key和value："</span><span>,</span>config<span>.</span>items<span>(</span><span>'说明'</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>"所有节点："</span><span>,</span> config<span>.</span>sections<span>(</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>"“说明”节点下所有option："</span><span>,</span>config<span>.</span>options<span>(</span><span>"说明"</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>"获取“说明”下“配置1”的值："</span><span>,</span> config<span>.</span>get<span>(</span><span>"说明"</span><span>,</span> <span>"配置1"</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>"获取方法值为数字的:ini2 ="</span><span>,</span> config<span>.</span>getint<span>(</span><span>"说明"</span><span>,</span> <span>"配置3"</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>输出：</p>
<div><pre><code>输出元组，包括option的key和value ：[('上面那个框框', '叫做节点'), ('我叫option', '我是值'), ('配置1', '我是路径1'), ('配置2', '我是路径2'), ('配置3', '123')]
所有节点： ['说明']
“说明”节点下所有option： ['上面那个框框', '我叫option', '配置1', '配置2', '配置3']
获取“说明”下“配置1”的值： 我是路径1
<span>获取方法值为数字的:ini2</span> <span><span>=</span> 123</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h1 id="说明"> 说明</h1>
<p>这里将其他方法列出</p>
<h2 id="写入-2"> 写入</h2>
<div><pre><code><span>import</span> configparser
config <span>=</span> configparser<span>.</span>ConfigParser<span>(</span><span>)</span>
<span># 第一种方法</span>
config<span>[</span><span>'说明'</span><span>]</span> <span>=</span> <span>{</span><span>"[CONFIG]"</span><span>:</span><span>"里面的东西叫做节点"</span><span>,</span>
                 <span>"我叫OPTION"</span><span>:</span><span>"我是值"</span><span>}</span>
<span># 第二种方法</span>
config<span>[</span><span>'CONFIG'</span><span>]</span> <span>=</span> <span>{</span><span>}</span>
config<span>[</span><span>'CONFIG'</span><span>]</span><span>[</span><span>'配置1'</span><span>]</span> <span>=</span> <span>'我是路径1'</span>
config<span>[</span><span>'CONFIG'</span><span>]</span><span>[</span><span>'配置2'</span><span>]</span> <span>=</span> <span>'我是路径2'</span>
<span># 第三种方法</span>
config<span>[</span><span>'第三种方法'</span><span>]</span> <span>=</span> <span>{</span><span>}</span>
topsecret <span>=</span> config<span>[</span><span>'第三种方法'</span><span>]</span>
topsecret<span>[</span><span>'ini1'</span><span>]</span> <span>=</span> <span>'内容'</span>
topsecret<span>[</span><span>'ini2'</span><span>]</span> <span>=</span> <span>'123456'</span>

<span>with</span> <span>open</span><span>(</span><span>'配置文件示例.ini'</span><span>,</span> <span>'w'</span><span>,</span> encoding<span>=</span><span>'utf-8'</span><span>)</span> <span>as</span> f<span>:</span>
    config<span>.</span>write<span>(</span>f<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>配置文件示例.ini：</p>
<div><pre><code><span>[说明]</span>
<span>[config]</span> <span><span>=</span> 里面的东西叫做节点</span>
<span>我叫option</span> <span><span>=</span> 我是值</span>

<span>[CONFIG]</span>
<span>配置1</span> <span><span>=</span> 我是路径1</span>
<span>配置2</span> <span><span>=</span> 我是路径2</span>

<span>[第三种方法]</span>
<span>ini1</span> <span><span>=</span> 内容</span>
<span>ini2</span> <span><span>=</span> 123456</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="读取-2"> 读取</h2>
<div><pre><code><span>import</span> configparser
config <span>=</span> configparser<span>.</span>ConfigParser<span>(</span><span>)</span>

config<span>.</span>read<span>(</span><span>'配置文件示例.ini'</span><span>,</span> encoding<span>=</span><span>'utf-8'</span><span>)</span>
<span>print</span><span>(</span><span>"输出元组，包括option的key和value"</span><span>,</span>config<span>.</span>items<span>(</span><span>'CONFIG'</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>"所有节点==>"</span><span>,</span> config<span>.</span>sections<span>(</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>"CONFIG节点下所有option的key，包括默认option==>"</span><span>,</span>config<span>.</span>options<span>(</span><span>"CONFIG"</span><span>)</span><span>)</span>
<span># 获取值</span>
<span># 方式1</span>
<span>print</span><span>(</span><span>"CONFIG下配置1的值==>"</span><span>,</span>config<span>[</span><span>"CONFIG"</span><span>]</span><span>[</span><span>"配置1"</span><span>]</span><span>)</span>
topsecret <span>=</span> config<span>[</span><span>'CONFIG'</span><span>]</span>
<span># 方法2</span>
<span>print</span><span>(</span><span>"bitbucket.org下user的值==>"</span><span>,</span>topsecret<span>[</span><span>"配置1"</span><span>]</span><span>)</span>

<span># 方法3</span>
<span>print</span><span>(</span><span>"获取CONFIG下配置1的值==>"</span><span>,</span> config<span>.</span>get<span>(</span><span>"CONFIG"</span><span>,</span> <span>"配置1"</span><span>)</span><span>)</span>
<span>print</span><span>(</span><span>"获取第三种方法值为数字的:ini2="</span><span>,</span> config<span>.</span>getint<span>(</span><span>"第三种方法"</span><span>,</span> <span>"ini2"</span><span>)</span><span>)</span>

<span>print</span><span>(</span><span>"包含实例范围默认值的词典==>"</span><span>,</span> config<span>.</span>defaults<span>(</span><span>)</span><span>)</span>

<span>for</span> item <span>in</span> config<span>[</span><span>"说明"</span><span>]</span><span>:</span>
    <span>print</span><span>(</span><span>"循环节点说明下所有option==>"</span><span>,</span>item<span>)</span>

<span>print</span><span>(</span><span>"判断CONFIG节点是否存在==>"</span><span>,</span><span>'CONFIG'</span> <span>in</span> config<span>)</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>输出：</p>
<div><pre><code>输出元组，包括option的key和value [('配置1', '我是路径1'), ('配置2', '我是路径2')]
<span>所有节点</span><span><span>=</span><span>=</span>> ['说明', 'CONFIG', '第三种方法', 'config']</span>
<span>CONFIG节点下所有option的key，包括默认option</span><span><span>=</span><span>=</span>> ['配置1', '配置2']</span>
<span>CONFIG下配置1的值</span><span><span>=</span><span>=</span>> 我是路径1</span>
<span>bitbucket.org下user的值</span><span><span>=</span><span>=</span>> 我是路径1</span>
<span>获取CONFIG下配置1的值</span><span><span>=</span><span>=</span>> 我是路径1</span>
<span>获取第三种方法值为数字的:ini2</span><span><span>=</span> 123456</span>
<span>包含实例范围默认值的词典</span><span><span>=</span><span>=</span>> OrderedDict()</span>
<span>循环节点说明下所有option</span><span><span>=</span><span>=</span>> [config]</span>
<span>循环节点说明下所有option</span><span><span>=</span><span>=</span>> 我叫option</span>
<span>判断CONFIG节点是否存在</span><span><span>=</span><span>=</span>> True</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h1 id="后面"> 后面</h1>
<p>这个漫长的寒假有点懒了呢...</p>
]]></content:encoded>
    </item>
    <item>
      <title>windows日常调整</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/toss/windows_daily_regulate/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/toss/windows_daily_regulate/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">windows日常调整</source>
      <category>折腾</category>
      <pubDate>Fri, 15 May 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="前言"> 前言</h1>
<p>平时用windows的时候自己知道那个是什么却总是记不住，所以就在这里记下</p>
<h1 id="快速"> 快速</h1>
<p>大概就是这些</p>
<ul>
<li>dns缓存清理：<code>ipconfig/flushdns</code></li>
<li>开机启动文件夹“
<ol>
<li><code>C:\Users\username（你自己的用户名）\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</code></li>
<li><code>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp</code></li>
</ol>
</li>
<li>hosts文件夹所在目录：<code>c:\windows\system32\drivers\etc\</code></li>
</ul>
<h1 id="说明"> 说明</h1>
<h2 id="ipconfig"> ipconfig</h2>
<p>这个命令日常使用蛮多的，他可查看电脑ip参数配置信息，配合参数可以看ip地址、默认网关、子网掩码、DNS（域名服务）、WINS服务器等地址信息</p>
<ul>
<li><code>ipconfig</code> 直接使用可以查看基础的ip地址、子网掩码、网关</li>
<li><code>ipconfig /all</code> 显示本机详细信息，显示全部可显示信息</li>
<li><code>ipconfig /release</code> 释放ip（只适用于自动获取ip参数的情况）</li>
<li><code>ipconfig /renew</code> 更新ip（再次自动获取ip）</li>
<li><code>ipconfig /flushdns</code> 清空本机DNS缓存</li>
<li><code>ipconfig /displaydns</code> 更新所有适配器</li>
</ul>
<h2 id="开机启动文件夹"> 开机启动文件夹</h2>
<p>平时将自己做的小脚本想开机启动就放个快捷方式到这些文件夹里</p>
<h2 id="hosts"> hosts</h2>
<p>hosts文这个文件是将一些常用的网址域名与其对应的IP地址建立一个关联<code>数据库</code>，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析</p>
<ul>
<li>由于是系统文件，所以文件的属性默认是只读，如果无法保存则打开文件的属性吧<code>只读</code>去掉即可</li>
<li><code>#</code>号在前面表示注释</li>
<li>新建一行前面打ip后面空一格让然后再打域名：<code>127.0.0.1 abc.com</code></li>
</ul>
<h3 id="github-hosts文件配置"> Github Hosts文件配置</h3>
<p>有的时候打开github的页面加载半天都出不来，可以试试再hosts文件里面加这个！</p>
<div><pre><code># GitHub Start
151.101.44.249 github.global.ssl.fastly.net
140.82.113.4 github.com
199.232.28.133 assets-cdn.github.com
199.232.28.133 documentcloud.github.com
199.232.28.133 gist.github.com
199.232.28.133 help.github.com
199.232.28.133 nodeload.github.com
199.232.28.133 raw.github.com
199.232.28.133 status.github.com
199.232.28.133 training.github.com
199.232.28.133 www.github.com
199.232.28.133 avatars0.githubusercontent.com
199.232.28.133 avatars1.githubusercontent.com
 # GitHub End
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h1 id="后言"> 后言</h1>
<p>刚刚我要做什么来砸？——老年痴呆这的晚期现状</p>
]]></content:encoded>
    </item>
  </channel>
</rss>